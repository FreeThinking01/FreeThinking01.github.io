

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="记录剑指offer解法">
  
  <meta name="author" content="醉心">
  <meta name="keywords" content="">
  
  <meta name="baidu-site-verification" content="code-bHMYoJFxX1" />
  <meta name="google-site-verification" content="dlGT8DnmMC48-BTTmOm7R2wqNL0vR3kmzSo22BfG3hg" />
  <title>剑指offer - FreeThinking&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"lishuaiyun.cn","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="FreeThinking's blog" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>FreeThinking's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss-fill"></i>
                RSS
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="剑指offer">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-02-06 19:53" pubdate>
        2021年2月6日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      15.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      214
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">剑指offer</h1>
            
            <div class="markdown-body">
              <h1 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h1><h2 id="1-1-数组中重复的数字"><a href="#1-1-数组中重复的数字" class="headerlink" title="1.1 数组中重复的数字"></a>1.1 数组中重复的数字</h2><p>题目：找出数组中重复的数字。</p>
<p>​    在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>​    简单的方法是嵌套循环，但是没有利用题目给出的特殊条件。</p>
<p>​    题目的特殊条件是所有数都在0~n-1范围</p>
<p>​    方法一：利用集合的不可重复性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">//利用集合特性</span><br>    HashSet hashSet1 = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> length = nums.length;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i&lt;length;i++)&#123;<br>        <span class="hljs-keyword">if</span> (hashSet1.add(nums[i]) == <span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[i];<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>​    方法二：利用下标特性</p>
<p>​    所有数都在0~n-1范围，假设数组中没有重复的数字，那么排序后索引i处存储数字为i，不为i则必存在重复数字。同一位置只能存放一个合适的值，若有重复的数字则必发生交换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">while</span> (nums[i]!=i)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]==nums[nums[i]])&#123;<br>                    <span class="hljs-keyword">return</span> nums[i];<br>                &#125;<br>                temp=nums[i];<br>                nums[i]=nums[temp];<br>                nums[temp]=temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-2-二维数组中的查找"><a href="#1-2-二维数组中的查找" class="headerlink" title="1.2 二维数组中的查找"></a>1.2 二维数组中的查找</h2><p>题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>方法一：暴力破解</p>
<p>​    直接遍历二维数组查找，但这样做不够巧妙</p>
<p>方法二：剑指offer解法</p>
<p>​    利用该二维数组的性质：</p>
<ul>
<li>每一行从左到右递增</li>
<li>每一列从上到下递增</li>
</ul>
<p>使用右上角的值m和目标值target比较：</p>
<ol>
<li>当 m &lt; target，由于 m 已经是该行最大的元素，想要更大只有从下面的行，取值下移一位</li>
<li>当 m &gt; target，由于 m 已经是该列最小的元素，想要更小只有从左边的列，取值左移一位</li>
<li>当 m = target，找到该值，返回 true</li>
</ol>
<p>用某行最小或某列最大与 target 比较，每次可剔除一整行或一整列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JZ1</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 在一个二维数组中（每个一维数组的长度相同），每一行都按照从</span><br><span class="hljs-comment">    * 左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</span><br><span class="hljs-comment">    * 请完成一个函数，输入这样的一个二维数组和一个整数，</span><br><span class="hljs-comment">    * 判断数组中是否含有该整数。</span><br><span class="hljs-comment">    * */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> [][] array = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">13</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>&#125;&#125;;<br>        Boolean flag = Find2(<span class="hljs-number">0</span>,array);<br>        System.out.println(flag);<br>    &#125;<br><br>    <span class="hljs-comment">//自己解法，暴力破解（无技术含量）</span><br><br>    <span class="hljs-comment">//官方解法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">Find2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>[][] array)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> column = array[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> rows = array.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (column&lt;<span class="hljs-number">0</span>||rows&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (target==array[row][column])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target&lt;array[row][column])&#123;<br>                column--;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target&gt;array[row][column])&#123;<br>                row++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">while</span> (!(row&gt;rows||column&lt;<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-3-旋转数组中的最小数字"><a href="#1-3-旋转数组中的最小数字" class="headerlink" title="1.3 旋转数组中的最小数字"></a>1.3 旋转数组中的最小数字</h2><p>​    题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>​    输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>​    NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<ol>
<li>简单的方法是直接遍历，但这样没有只有旋转数组的特性。这样时间复杂度为$O(n)$</li>
<li>旋转数组的特性是什么？</li>
</ol>
<p>​    注意到数组旋转前是按关键字有序排列的，也就是说旋转数组在一定程度上是有序的，这很符合二分查找的特性，那么旋转后的数组可不可以使用二分查找呢？或许可以通过适当的改变二分查找解决</p>
<p>​    旋转数组可以划分为两个排序的子数组，前面的子数组元素都大于或等于后面数组的元素，最小的元素刚好是这两个数组的分界线。</p>
<p>一个包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/1.png" srcset="/img/loading.gif" alt="fig1" style="zoom: 33%;" /></p>
<p>​    其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要旋转的目标。</p>
<p>​    我们考虑数组中的最后一个元素 x：在最小值右侧的元素，它们的值一定都小于等于 x；而在最小值左侧的元素，它们的值一定都大于等于 x。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。</p>
<p>​    在二分查找的每一步中，左边界为 $\it low$，右边界为 $\it high$，区间的中点为$ \it pivot$，最小值就在该区间内。我们将中轴元素 $\textit{numbers}[\textit{pivot}]$ 与右边界元素 $\textit{numbers}[\textit{high}]$进行比较，可能会有以下的三种情况：</p>
<p>​    第一种情况是$ \textit{numbers}[\textit{pivot}] &lt; \textit{numbers}[\textit{high}]$。如下图所示，这说明 $\textit{numbers}[\textit{pivot}]$ 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/jianzhi_11/2.png" srcset="/img/loading.gif" alt="fig2" style="zoom:33%;" /></p>
<p>​    </p>
<p>第二种情况是$ \textit{numbers}[\textit{pivot}]$ &gt; $\textit{numbers}[\textit{high}]$。如下图所示，这说明 $\textit{numbers}[\textit{pivot}]$ 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.png" srcset="/img/loading.gif" alt="fig3" style="zoom:33%;" /></p>
<p>第三种情况是$ \textit{numbers}[\textit{pivot}]$ == $\textit{numbers}[\textit{high}]$。如下图所示，由于重复元素的存在，我们并不能确定 $\textit{numbers}[\textit{pivot}]$ 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论$ \textit{numbers}[\textit{high}]$ 是不是最小值，都有一个它的「替代品」$\textit{numbers}[\textit{pivot}]$，因此我们可以忽略二分查找区间的右端点。</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/4.png" srcset="/img/loading.gif" alt="fig4" style="zoom:33%;" /></p>
<p>补充思考： 为什么本题二分法不用$ nums[m]$ 和$ nums[i]$ 作比较？</p>
<p>二分目的是判断<font color='red'> m 在哪个排序数组中</font>，从而缩小区间。而在 $nums[m]&gt;nums[i]$情况下，无法判断 m 在哪个排序数组中。本质上是由于 j 初始值肯定在右排序数组中； i 初始值无法确定在哪个排序数组中。举例如下：</p>
<p>对于以下两示例，当 i = 0, j = 4, m = 2 时，有$ nums[m] &gt; nums[i] $，而结果不同。<br>[1,2,3,4,5] 旋转点 x = 0： m 在右排序数组（此示例只有右排序数组）；<br>[3,4,5,1,2]旋转点 x = 3 ： m 在左排序数组。</p>
<p>排序数组的查找问题首先考虑使用 <strong>二分法</strong> 解决，其可将 <strong>遍历法</strong> 的 <strong>线性级别</strong> 时间复杂度降低至 <strong>对数级别</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (numbers.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = numbers.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">int</span> m = i + (j - i) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[m] &gt; numbers[j]) &#123;<br>                i = m + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[m] &lt; numbers[j]) &#123;<br>                j = m;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">int</span> x = i;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++) &#123;<br>                    <span class="hljs-keyword">if</span>(numbers[k] &lt; numbers[x])&#123;<br>                        x = k;<br>                    &#125; <br>                &#125;<br>                <span class="hljs-keyword">return</span> numbers[x];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[i];<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>二分查找中还涉及了一个知识点：</p>
<p>计算$mid = low+(high-low)/2$，为什么不使用$mid=(low+high)/2$呢。</p>
<p>​    首先第一种写法与第二种数学上得到的结果是完全一样的，这个可以通过取整函数的方法证明。但是low＋high这一步操作很可能会出现整数溢出的风险，而 low + (end-low)/2 写法不会出现比high要大的中间数据，所以比较安全。如果你是用 python 这种自带大数支持的语言，就不用担心这种写法会整数溢出了。除此之外如果low和high是指针或者迭代器的话是无法编译通过的，因为指针和迭代器运算不支持相加运算，却支持相减运算，所以第一种通用性强。</p>
<h2 id="1-4-矩阵中的路径"><a href="#1-4-矩阵中的路径" class="headerlink" title="1.4 矩阵中的路径"></a>1.4 矩阵中的路径</h2><p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p>
<p>​    但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p>​    矩阵搜索问题，求连通块应该使用深度优先搜索（DFS）+剪枝解决。</p>
<p><strong>原理</strong></p>
<ul>
<li><p>深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</p>
</li>
<li><p>剪枝： 在搜索中，遇到这条路不可能和目标字符串匹配成功的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。</p>
</li>
</ul>
<p><strong>分析</strong></p>
<ul>
<li>递归参数： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。</li>
<li>终止条件：<ul>
<li>返回 false ： ① 行或列索引越界 或 ② 当前矩阵元素与目标字符不同 或 ③ 当前矩阵元素已访问过 （③ 可合并至 ② ） 。</li>
<li>返回 true ： 字符串 word 已全部匹配，即 k = len(word) - 1 。</li>
</ul>
</li>
<li>递推工作：<ul>
<li>标记当前矩阵元素： 将 board[i][j] 值暂存于变量 tmp ，并修改为字符 ‘/‘ ，代表此元素已访问过，防止之后搜索时重复访问。</li>
<li>搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需一条可行路径） ，并记录结果至 res 。</li>
<li>还原当前矩阵元素： 将 tmp 暂存值还原至 board[i][j]元素。</li>
</ul>
</li>
<li>回溯返回值： 返回 res ，代表是否搜索到目标字符串。</li>
</ul>
<p><strong>复杂度分析</strong></p>
<blockquote>
<p> M,N 分别为矩阵行列大小， KK 为字符串 word 长度。</p>
</blockquote>
<ul>
<li>时间复杂度 O(3<sup>K</sup>MN)，最差情况下，需要遍历矩阵中长度为 KK 字符串的所有方案，时间复杂度为 O(3<sup>k</sup>)；矩阵中共有 MN个起点，时间复杂度为 O(MN) 。<ul>
<li>方案数计算： 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为 O(3<sup>k</sup>) 。</li>
<li>空间复杂度 O(K) ： 搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K)（因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K = MN ，递归深度为 MN ，此时系统栈使用 O(MN) 的额外空间。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span>[] words = word.toCharArray();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;board.length;i++ )&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;board[<span class="hljs-number">0</span>].length;j++)&#123;<br>            <span class="hljs-keyword">if</span> (dfs(board,words,i,j,<span class="hljs-number">0</span>))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board,<span class="hljs-keyword">char</span>[] word,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    <span class="hljs-comment">//排除不合法选择</span><br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i&gt;= board.length || j &lt; <span class="hljs-number">0</span> || j&gt;= board[<span class="hljs-number">0</span>].length || board[i][j] != word[k])&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//触发结束条件</span><br>    <span class="hljs-keyword">if</span> (k == word.length-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">char</span> tmp = board[i][j];<br>    <span class="hljs-comment">//将该选择从选择列表移除</span><br>    board[i][j] = <span class="hljs-string">&#x27;/&#x27;</span>;<br>    <span class="hljs-comment">//路径.add(选择)</span><br>    <span class="hljs-keyword">boolean</span> res = dfs(board,word,i+<span class="hljs-number">1</span>,j,k+<span class="hljs-number">1</span>) || dfs(board,word,i-<span class="hljs-number">1</span>,j,k+<span class="hljs-number">1</span>) ||<br>                  dfs(board,word,i,j+<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>) || dfs(board,word,i,j-<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//撤销选择</span><br>    board[i][j] = tmp;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-5-调整数组顺序使奇数位于偶数前面"><a href="#1-5-调整数组顺序使奇数位于偶数前面" class="headerlink" title="1.5 调整数组顺序使奇数位于偶数前面"></a>1.5 调整数组顺序使奇数位于偶数前面</h2><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。</p>
<p>​    调整数组的顺序，显然这是排序题。首先简单的想法是遇到从前向后遍历，遇到奇数放在数组1，遇到偶数放在数组2，最后将数组1和数组2拼接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reOrderArray1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] array)</span> </span>&#123;<br>    ArrayList array1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    ArrayList array2 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    <span class="hljs-keyword">int</span> length = array.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;length;i++)&#123;<br>        <span class="hljs-keyword">if</span> ((array[i] &amp; <span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)&#123;<br>            array1.add(array[i]);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            array2.add(array[i]);<br>        &#125;<br>    &#125;<br>    array1.addAll(array2);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;length;i++)&#123;<br>        array[i] = (<span class="hljs-keyword">int</span>)array1.get(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样做时间复杂度是O(n)，空间复杂度为O(n)。</p>
<p>也可以使用双指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] exchange(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = nums.length - <span class="hljs-number">1</span>,tmp;<br>        <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[i] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) i++;<br>            <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[j] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) j--;<br>            tmp = nums[i];<br>            nums[i] = nums[j];<br>            nums[j] = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这样做的时间复杂度是O(n)，空间复杂度为O(1)。</p>
<h2 id="1-6-顺时针打印矩阵"><a href="#1-6-顺时针打印矩阵" class="headerlink" title="1.6 顺时针打印矩阵"></a>1.6 顺时针打印矩阵</h2><p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>示例 1：</p>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p>
<p>示例 2：</p>
<p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
<p>限制：</p>
<p>0 &lt;= matrix.length &lt;= 100<br>0 &lt;= matrix[i].length &lt;= 100</p>
<p>算法流程：</p>
<ul>
<li>空值处理： 当 matrix 为空时，直接返回空列表 [] 即可。</li>
<li>初始化： 矩阵 左、右、上、下 四个边界 l , r , t , b ，用于打印的结果列表 res 。</li>
<li>循环打印： “从左向右、从上向下、从右向左、从下向上” 四个方向循环，每个方向打印中做以下三件事 （各方向的具体信息见下表） ；<ul>
<li>根据边界打印，即将元素按顺序添加至列表 res 尾部；</li>
<li>边界向内收缩 11 （代表已被打印）；</li>
<li>判断是否打印完毕（边界是否相遇），若打印完毕则跳出。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] spiralOrder(<span class="hljs-keyword">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">if</span> (matrix.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, below = matrix.length,x=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[(right+<span class="hljs-number">1</span>)*(below+<span class="hljs-number">1</span>)];<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left;i &lt;= right; i++) &#123;<br>                res[x++] = matrix[top][i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (++top &gt; below) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = top;i &lt;= below; i++) &#123;<br>                res[x++] = matrix[i][right];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (--right &lt; left) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = right;i &gt;= left; i--) &#123;<br>                res[x++] = matrix[below][i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (--below &lt; top) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = below;i &gt;= top; i--) &#123;<br>                res[x++] = matrix[i][left];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (++left &gt; right) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-7-数组中出现次数超过一半的数字"><a href="#1-7-数组中出现次数超过一半的数字" class="headerlink" title="1.7  数组中出现次数超过一半的数字"></a>1.7  数组中出现次数超过一半的数字</h2><p>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<font color=red>摩尔投票法</font>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//x众数,votes票数</span><br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, votes = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)&#123;<br>    <span class="hljs-keyword">if</span> (votes == <span class="hljs-number">0</span>)&#123;x = num;&#125;<br>    votes += num == x ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> x;<br></code></pre></td></tr></table></figure>
<h2 id="1-8-连续子数组的最大和"><a href="#1-8-连续子数组的最大和" class="headerlink" title="1.8 连续子数组的最大和"></a>1.8 连续子数组的最大和</h2><p>​    题目：输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p>
<p>​    使用动态规划</p>
<ul>
<li>状态定义： 设动态规划列表 $dp$ ，$dp[i]$ 代表以元素$ nums[i] $为结尾的连续子数组最大和。<ul>
<li>为何定义最大和$ dp[i]$ 中必须包含元素 $nums[i]$ ：保证$dp[i] $递推到 $dp[i+1]$ 的正确性；如果不包含 $nums[i]$ ，递推时则不满足题目的 <strong>连续子数组</strong> 要求。</li>
</ul>
</li>
<li>转移方程：若 $dp[i−1]≤0$ ，说明$ dp[i−1] $对$ dp[i] $产生负贡献，即 $dp[i−1]+nums[i]$ 还不如$nums[i]$ 本身大。</li>
<li>初始状态： $dp[0]=nums[0]$，即以$nums[0]$ 结尾的连续子数组最大和为$ nums[0]$ 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>     <span class="hljs-comment">//用nums本身做dp数组。maxSub记录值,初始状态dp[0] = nums[0] </span><br>    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-comment">//状态转移方程</span><br>        nums[i] += Math.max(<span class="hljs-number">0</span>,nums[i-<span class="hljs-number">1</span>]);<br>        res = Math.max(res,nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-9-数组中的逆序对"><a href="#1-9-数组中的逆序对" class="headerlink" title="1.9 数组中的逆序对"></a>1.9 数组中的逆序对</h2><p>题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = nums.length;<br><br>    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>        copy[i] = nums[i];<br>    &#125;<br><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>    <span class="hljs-keyword">return</span> reversePairs(copy, <span class="hljs-number">0</span>, len-<span class="hljs-number">1</span>, temp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (left == right)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> mid = left + (right-left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> leftPairs = reversePairs(nums, left, mid, temp);<br>    <span class="hljs-keyword">int</span> rightPairs = reversePairs(nums, mid+<span class="hljs-number">1</span>, right, temp);<br><br>    <span class="hljs-keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="hljs-number">1</span>])&#123;<br>        <span class="hljs-keyword">return</span> leftPairs + rightPairs;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> crossPairs = mergeAndCount(nums,left,mid,right,temp);<br>    <span class="hljs-keyword">return</span> leftPairs + rightPairs + crossPairs;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mergeAndCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid , <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right ; i++) &#123;<br>        temp[i] = nums[i];<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = left;<br>    <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = left; k &lt;= right ; k++) &#123;<br><br>        <span class="hljs-keyword">if</span> (i == mid + <span class="hljs-number">1</span>)&#123;<br>            nums[k] = temp[j];<br>            j++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == right + <span class="hljs-number">1</span>)&#123;<br>            nums[k] = temp[i];<br>            i++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp[i] &lt;= temp[j])&#123;<br>            nums[k] = temp[i];<br>            i++;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            nums[k] = temp[j];<br>            j++;<br>            count += (mid - i + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-10-在排序数组中查找数字"><a href="#1-10-在排序数组中查找数字" class="headerlink" title="1.10 在排序数组中查找数字"></a>1.10 在排序数组中查找数字</h2><p>​    题目：统计一个数字在排序数组中出现的次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> helper(nums,target) - helper(nums,target - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> tar)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= j)&#123;<br>        <span class="hljs-keyword">int</span> m = i + (j - i) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[m] &lt;= tar)&#123;<br>            i = m + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            j = m - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-11-0～n-1中缺失的数字"><a href="#1-11-0～n-1中缺失的数字" class="headerlink" title="1.11 0～n-1中缺失的数字"></a>1.11 0～n-1中缺失的数字</h2><p>题目：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">while</span> (i &lt;= j)&#123;<br>         <span class="hljs-keyword">int</span> m = i + (j - i) / <span class="hljs-number">2</span>;<br>         <span class="hljs-keyword">if</span> (nums[m] == m)&#123;<br>             i = m + <span class="hljs-number">1</span>;<br>         &#125;<span class="hljs-keyword">else</span> &#123;<br>             j = m - <span class="hljs-number">1</span>;<br>         &#125;<br>     &#125;<br><br>     <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = nums.length,mid;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            mid = left + (right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == mid) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] != mid)&#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-12-和为s的两个数字"><a href="#1-12-和为s的两个数字" class="headerlink" title="1.12 和为s的两个数字"></a>1.12 和为s的两个数字</h2><p>​    题目：输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<font color='red'>对撞指针（左右指针）</font>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j)&#123;<br>        <span class="hljs-keyword">int</span> s = nums[i] + nums[j];<br>        <span class="hljs-keyword">if</span> (s == target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;nums[i], nums[j]&#125;;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &lt; target)&#123;<br>            i++;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>正确性证明：</p>
<blockquote>
<p>记每个状态为 $S(i, j)$ ，即 $S(i, j) = nums[i] + nums[j]$。假设 $S(i,j)&lt;target$ ，则执行 $i = i + 1$ ，即状态切换至 $S(i + 1, j)$。</p>
</blockquote>
<ul>
<li><p>状态 $S(i, j)$切换至 $S(i + 1, j)$，则会消去一行元素，相当于 消去了状态集合$ {S(i, i + 1), S(i, i + 2), …, S(i, j - 2), S(i, j - 1), S(i, j) }$ 。（由于双指针都是向中间收缩，因此这些状态之后不可能再遇到）。</p>
</li>
<li><p>由于$nums$ 是排序数组，因此这些 消去的状态 都一定满足 $S(i,j)&lt;target$ ，即这些状态都 不是解 。</p>
</li>
<li><p>结论： 以上分析已证明 “每次指针 $i$ 的移动操作，都不会导致解的丢失” ，即指针 i 的移动操作是 安全的 ；同理，对于指针 $j$ 可得出同样推论；因此，此双指针法是正确的。</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/25bb748e0fc6f829056caf07716b96d02121625350afc012f2c351da73945f65-Picture1.png" srcset="/img/loading.gif" style="zoom:33%;" /></p>
</li>
</ul>
<h2 id="1-13-扑克牌中的顺子"><a href="#1-13-扑克牌中的顺子" class="headerlink" title="1.13 扑克牌中的顺子"></a>1.13 扑克牌中的顺子</h2><p>​    题目：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    HashSet&lt;Integer&gt; repeat = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>, min = <span class="hljs-number">14</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">continue</span>;&#125;<br>        max = Math.max(max,num);<br>        min = Math.min(min,num);<br>        <span class="hljs-keyword">if</span> (repeat.contains(num))&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<br>        repeat.add(num);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max - min &lt; <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-14-构建乘积数组"><a href="#1-14-构建乘积数组" class="headerlink" title="1.14 构建乘积数组"></a>1.14 构建乘积数组</h2><p>​    题目：给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/6056c7a5009cb7a4674aab28505e598c502a7f7c60c45b9f19a8a64f31304745-Picture1.png" srcset="/img/loading.gif" alt="Picture1.png" style="zoom: 33%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] constructArr(<span class="hljs-keyword">int</span>[] a) &#123;<br>    <span class="hljs-keyword">if</span> (a.length == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];&#125;<br>    <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a.length];<br>    b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++)&#123;<br>        b[i] = b[i-<span class="hljs-number">1</span>] * a[i-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-comment">//tmp记录右边部分乘积</span><br>        tmp *= a[i+<span class="hljs-number">1</span>];<br>        b[i] *= tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-15-把数组排成最小的数"><a href="#1-15-把数组排成最小的数" class="headerlink" title="1.15 把数组排成最小的数"></a>1.15 把数组排成最小的数</h2><p>​    题目：输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>快速排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>     String[] strs = <span class="hljs-keyword">new</span> String[nums.length];<br>     <span class="hljs-comment">//整形数组转成字符串数组</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>         strs[i] = String.valueOf(nums[i]);<br>     &#125;<br>     <span class="hljs-comment">//排序</span><br>     fastSort(strs,<span class="hljs-number">0</span>,strs.length - <span class="hljs-number">1</span>);<br>     StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>     <span class="hljs-comment">//字符串数组转成字符串</span><br>     <span class="hljs-keyword">for</span> (String s : strs)&#123;<br>         res.append(s);<br>     &#125;<br>     <span class="hljs-keyword">return</span> res.toString();<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fastSort</span><span class="hljs-params">(String[] strs,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;<br>     <span class="hljs-keyword">if</span> (l &gt;= r)&#123;<span class="hljs-keyword">return</span>;&#125;<br>     <span class="hljs-keyword">int</span> i = l,j = r;<br>     String tmp = strs[i];<br>     <span class="hljs-keyword">while</span> (i &lt; j)&#123;<br>         <span class="hljs-keyword">while</span> ((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; j)&#123;j--;&#125;<br>         <span class="hljs-keyword">while</span> ((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; j)&#123;i++;&#125;<br>         tmp = strs[i];<br>         strs[i] = strs[j];<br>         strs[j] = tmp;<br>     &#125;<br>     strs[i] = strs[l];<br>     strs[l] = tmp;<br>     fastSort(strs,l,i-<span class="hljs-number">1</span>);<br>     fastSort(strs,i+<span class="hljs-number">1</span>,r);<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>内置函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        String[] strs = <span class="hljs-keyword">new</span> String[nums.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>            strs[i] = String.valueOf(nums[i]);<br>        &#125;<br>        Arrays.sort(strs, (x, y) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> ((x + y).compareTo(y + x));<br>        &#125;);<br>        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-comment">// 字符串数组转成字符串</span><br>        <span class="hljs-keyword">for</span> (String s : strs) &#123;<br>            res.append(s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-16-和为s的连续正数序列"><a href="#1-16-和为s的连续正数序列" class="headerlink" title="1.16 和为s的连续正数序列"></a>1.16 和为s的连续正数序列</h2><p>​    题目：输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] findContinuousSequence(<span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-comment">//i是左边界，j是有边界，sum是滑动窗口中数字的和</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    List&lt;<span class="hljs-keyword">int</span>[]&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-keyword">while</span> (i &lt;= target / <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">if</span> (sum &lt; target)&#123;<br>            sum += j;<br>            j++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target)&#123;<br>            sum -= i;<br>            i++;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[j-i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; j; k++)&#123;<br>                arr[k - i] = k;<br>            &#125;<br>            res.add(arr);<br>            <span class="hljs-comment">//左边界向右移动，开始计算下一轮结果</span><br>            sum -= i;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.size()][]);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-17-滑动窗口的最大值"><a href="#1-17-滑动窗口的最大值" class="headerlink" title="1.17 滑动窗口的最大值"></a>1.17 滑动窗口的最大值</h2><p>​    题目：给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p>
<p>​    设窗口区间为$ [i, j]$ ，最大值为 $x_j$  。当窗口向前移动一格，则区间变为 $[i+1,j+1]$ ，即添加了 $nums[j + 1]$，删除了 $nums[i]$。</p>
<p>​    若只向窗口 $[i,j]$ 右边添加数字 $nums[j+1]$ ，则新窗口最大值可以 通过一次对比 使用 O(1) 时间得到，即：</p>
<script type="math/tex; mode=display">
x_{j+1} = \max(x_{j}, nums[j + 1])</script><p>​    而删除的nums[i] 可能恰好是窗口内唯一的最大值 $x<em>j$  ，因此不能通过以上方法计算$ x</em>{j+1}$，而必须使用 O(j-i) 时间， 遍历整个窗口区间 获取最大值，即：</p>
<script type="math/tex; mode=display">
x_{j+1} = \max(nums(i+1), \cdots , num(j+1))</script><p>​    根据以上分析，可得 暴力法 的时间复杂度为 $O((n-k+1)k) \approx O(nk)$ 。</p>
<p>​    设数组 nums 的长度为 n ，则共有 (n-k+1)个窗口；<br>​    获取每个窗口最大值需线性遍历，时间复杂度为 O(k) 。</p>
<p>​    要想在O(1)的时间复杂度取出最大值，可以考虑单调栈的实现方式，但栈的元素进出都在一边，因此可以使用双端队列的数据结构，并维护为单调队列。遍历数组滑动窗口时，保证单调队列deque:</p>
<ol>
<li>deque内仅包含窗口内的元素，每次窗口滑动移除了元素 $nums[i - 1]$ ，需将 $deque$ 内的对应元素一起删除。</li>
<li>deque 内的元素 非严格递减 ⇒ 每轮窗口滑动添加了元素 nums[j + 1]，需将deque 内所有 &lt; nums[j + 1]的元素删除。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];&#125;<br>    Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length - k +<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//未形成窗口区间</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>        <span class="hljs-comment">//每次加入元素时保证队列递减</span><br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt; deque.peekLast())&#123;<br>            deque.removeLast();<br>        &#125;<br>        deque.addLast(nums[i]);<br>    &#125;<br>    <span class="hljs-comment">//窗口区间形成后，把队列首位添加到结果中</span><br>    <span class="hljs-comment">//因为窗口形成后，就需要把队列首位添加到数组中，而下面的循环是直接跳过这一步的，所以需要我们直接添加</span><br>    res[index++] = deque.peekFirst();<br>    <span class="hljs-comment">//窗口区间形成</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k;i &lt; nums.length; i++)&#123;<br>        <span class="hljs-comment">//删除上一个窗口的元素</span><br>        <span class="hljs-keyword">if</span> (deque.peekFirst() == nums[i - k])&#123;deque.removeFirst();&#125;<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i])&#123;<br>            deque.removeLast();<br>        &#125;<br>        deque.addLast(nums[i]);<br>        res[index++] = deque.peekFirst();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h1><h2 id="2-1-从尾到头打印链表"><a href="#2-1-从尾到头打印链表" class="headerlink" title="2.1 从尾到头打印链表"></a>2.1 从尾到头打印链表</h2><p>​    题目：输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<p>​    倒转链表，联想到栈的后进先出的结构。</p>
<p>​    我的想法是使用array List作为栈接收，然后再pop到一个新的数组，这里用的Collections.reverse(arrayList);</p>
<p>​    <font color = 'red'>直接想最优情况，不行再退步寻求次一级情况</font>，首先链表必须遍历一遍，是否可以直接让链表中的元素插入数组时就是反转好的呢，更好的方法是利用list.add(index,value)方法可以在指定位置插入值的特性使用头插法在遍历 listNode 的同时将每个遇到的值插入到 list 的 0 位置，最后输出 listNode 即可得到逆序链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode next;   <span class="hljs-comment">// 下一个链表对象</span><br>    ListNode(<span class="hljs-keyword">int</span> x) &#123;<br>        val = x;<br>    &#125;  <span class="hljs-comment">//赋值链表的值</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JZ3</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</span><br><span class="hljs-comment">    */</span><br><br><br>    <span class="hljs-comment">// 1.使用了Collections进行array list反转</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">printListFromTailToHead1</span><span class="hljs-params">(ListNode listNode)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">if</span> (listNode==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> arrayList;<br>        &#125;<br>        <span class="hljs-keyword">do</span> &#123;<br>            arrayList.add(listNode.val);<br>            listNode = listNode.next;<br>        &#125;<span class="hljs-keyword">while</span> (listNode!=<span class="hljs-keyword">null</span>);<br>        Collections.reverse(arrayList);<br>        <span class="hljs-keyword">return</span> arrayList;<br>    &#125;<br>    <span class="hljs-comment">//  牛客更巧妙的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">printListFromTailToHead2</span><span class="hljs-params">(ListNode listNode)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ListNode tmp = listNode;<br>        <span class="hljs-keyword">while</span>(tmp!=<span class="hljs-keyword">null</span>)&#123;<br>            list.add(<span class="hljs-number">0</span>,tmp.val);<br>            tmp = tmp.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-2-删除链表的节点"><a href="#2-2-删除链表的节点" class="headerlink" title="2.2 删除链表的节点"></a>2.2 删除链表的节点</h2><p>​    题目：给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head.val == val)&#123;<br>        head = head.next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode p1 = head;<br>    ListNode p2 = head.next;<br><br>    <span class="hljs-keyword">while</span>(p2 != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span> (p2.val != val)&#123;<br>            p1 = p1.next;<br>            p2 = p2.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            p1.next = p2.next;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-3-链表中倒数第k个结点"><a href="#2-3-链表中倒数第k个结点" class="headerlink" title="2.3 链表中倒数第k个结点"></a>2.3 链表中倒数第k个结点</h2><p>​    题目：输入一个链表，输出该链表中倒数第k个结点。<font color='red'>快慢指针</font></p>
<p>​    思路1：将链表倒过来再从头开始遍历</p>
<p>​    思路2：将链表放在linkedlist中利用previous，因为java中linkedlist是双向链表。</p>
<p>​    思路3：假设整个链表有n个结点，那么倒数第k个结点就是从头结点开始的第n-k+1个结点。如果我们能够得到链表中结点的个数n，那我们只要从头结点开始往后走n-k+1步就可以了。如何得到结点数n?这个不难，只需要<br>从头开始遍历链表，每经过一个结点，计数器加1就行了。这样做的坏处是需要遍历两次</p>
<p>​    思路4：为了实现只遍历链表一次就能找到倒数第k个结点，我们可以定义两个指针。第-一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动;从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个〈走在前面的）指针到达链表的尾结点时，第二个指针（走在后面的）指针正好是倒数第k个结点。</p>
<p>​    思路4代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode head,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>||k&lt;=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    ListNode listNode1 = head;<br>    ListNode listNode2 = head;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> (count &gt;= k)&#123;<br>            listNode2 = listNode2.next;<br>        &#125;<br>        listNode1 = listNode1.next;<br>        count++;<br>    &#125; <span class="hljs-keyword">while</span> (listNode1.next != <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">if</span> (count &lt; k)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> listNode2;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-4-反转链表"><a href="#2-4-反转链表" class="headerlink" title="2.4 反转链表"></a>2.4 反转链表</h2><p>​    题目：输入一个链表，反转链表后，输出新链表的表头。</p>
<p>​    思路1：可以额外开辟数组空间辅助解决</p>
<p>​    思路2：将第一个结点摘下，后续结点头插法插入</p>
<p>​    代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (head.next == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode p = head.next;<br>    ListNode r;<br>    head.next = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span>(p.next!=<span class="hljs-keyword">null</span>)&#123;<br>        r = p.next;<br>        p.next = head;<br>        head = p;<br>        p = r;<br>    &#125;<br>    p.next = head;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>​    需要注意的是输入结点为空和输入结点为1的情况，以及进入循环之前必须置head.next=null进行断链，否则产生循环链表报错。</p>
<p>也可在头结点之前添加辅助结点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode p = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    p.next = head;<br>    ListNode tmp = head.next;<br>    head.next = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span> (tmp != <span class="hljs-keyword">null</span>) &#123;<br>        ListNode r =  tmp.next;<br>        tmp.next = p.next;<br>        p.next = tmp;<br>        tmp = r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p.next;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-5-合并两个排序的链表"><a href="#2-5-合并两个排序的链表" class="headerlink" title="2.5 合并两个排序的链表"></a>2.5 合并两个排序的链表</h2><p>​    题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>​    显然是个排序问题。</p>
<p>​    思路：将两个链表的值不断比较，值小的链接到新链表（Java中没有指针，不能完成无辅助空间操作）。</p>
<p>​    关键技巧：一般创建单链表，都会设一个虚拟头结点，也叫哨兵，因为这样每一个结点都有一个前驱结点。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> </span>&#123;<br>    ListNode list = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    ListNode cur;<br>    cur = list;<br>    <span class="hljs-keyword">while</span> (list1 != <span class="hljs-keyword">null</span> &amp;&amp; list2 != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (list1.val &lt;= list2.val) &#123;<br>            list.next = list1;<br>            list1 = list1.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            list.next = list2;<br>            list2 = list2.next;<br>        &#125;<br>        list = list.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (list1 == <span class="hljs-keyword">null</span>) &#123;<br>        list.next = list2;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (list2 == <span class="hljs-keyword">null</span>) &#123;<br>        list.next = list1;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur.next;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-6-复杂链表的复制"><a href="#2-6-复杂链表的复制" class="headerlink" title="2.6 复杂链表的复制"></a>2.6 复杂链表的复制</h2><p>​    题目：请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<p>​    给定链表的头节点 head ，复制普通链表很简单，只需遍历链表，每轮建立新节点 + 构建前驱节点 pre 和当前节点 node 的引用指向即可。</p>
<p>​    本题链表的节点新增了 random 指针，指向链表中的 <strong>任意节点</strong> 或者 <em>null</em> 。这个 random 指针意味着在复制过程中，除了构建前驱节点和当前节点的引用指向 pre.next ，还要构建前驱节点和其随机节点的引用指向 pre.random 。</p>
<p><strong>本题难点</strong>： 在复制链表的过程中构建新链表各节点的 random 引用指向。</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/1604747285-ELUgCd-Picture1.png" srcset="/img/loading.gif" alt="Picture1.png" style="zoom: 33%;" /></p>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>       Node cur = head;<br>       Node dum = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>), pre = dum;<br>       <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>) &#123;<br>           Node node = <span class="hljs-keyword">new</span> Node(cur.val); <span class="hljs-comment">// 复制节点 cur</span><br>           pre.next = node;               <span class="hljs-comment">// 新链表的 前驱节点 -&gt; 当前节点</span><br>           <span class="hljs-comment">// pre.random = &quot;???&quot;;         // 新链表的前驱结点的random结点无法复制，因为此时random结点可能还没出现在新链表上</span><br>           cur = cur.next;                <span class="hljs-comment">// 遍历下一节点</span><br>           pre = node;                    <span class="hljs-comment">// 保存当前新节点</span><br>       &#125;<br>       <span class="hljs-keyword">return</span> dum.next;<br>   &#125;<br><br><br></code></pre></td></tr></table></figure>
<p>​    创建一个HashMap<Node,Node>，前面的Node是原来的Nodefui，后面的Node是复制的Node。先把原来的结点值复制，再复制只指向（）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>    HashMap&lt;Node,Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    Node cur = head;<br>	<span class="hljs-comment">//复制结点值</span><br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>        map.put(cur,<span class="hljs-keyword">new</span> Node(cur.val));<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-comment">//复制结点指向</span><br>    cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>)&#123;<br>        map.get(cur).next = map.get(cur.next);<br>        map.get(cur).random = map.get(cur.random);<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-comment">//返回复制链表</span><br>    <span class="hljs-keyword">return</span> map.get(head);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-7-两个链表中的第一个公共结点"><a href="#2-7-两个链表中的第一个公共结点" class="headerlink" title="2.7 两个链表中的第一个公共结点"></a>2.7 两个链表中的第一个公共结点</h2><p>​    题目：输入两个链表，找出它们的第一个公共节点。如下面的两个链表：</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/160_statement.png" srcset="/img/loading.gif" alt="img" style="zoom: 67%;" /></p>
<p>​    在节点 c1 开始相交。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>       ListNode p1 = headA;<br>       ListNode p2 = headB;<br><br>       <span class="hljs-keyword">while</span> (p1 != p2)&#123;<br>           <span class="hljs-keyword">if</span> (p1 == <span class="hljs-keyword">null</span>)&#123;<br>               p1 = headB;<br>           &#125;<span class="hljs-keyword">else</span> &#123;<br>               p1 = p1.next;<br>           &#125;<br>           <span class="hljs-keyword">if</span> (p2 == <span class="hljs-keyword">null</span>)&#123;<br>               p2 = headA;<br>           &#125;<span class="hljs-keyword">else</span> &#123;<br>               p2 = p2.next;<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> p1;<br>   &#125;<br></code></pre></td></tr></table></figure>
<h1 id="3-堆"><a href="#3-堆" class="headerlink" title="3. 堆"></a>3. 堆</h1><h2 id="3-1-最小的k个数"><a href="#3-1-最小的k个数" class="headerlink" title="3.1 最小的k个数"></a>3.1 最小的k个数</h2><p>​    题目：输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p>方法一：直接排序</p>
<p>​    对原数组从小到大排序后取出前 k 个数即可。</p>
<p>方法二：堆</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**输入整数数组 arr ，找出其中最小的 k 个数。例如，</span><br><span class="hljs-comment"> * 输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;<br>    <span class="hljs-keyword">if</span>(arr.length == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">//PriorityQueue默认是小根堆，实现大根堆重写比较器</span><br>    Queue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((v1,v2)-&gt;(v2-v1));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr)&#123;<br>        <span class="hljs-keyword">if</span> (pq.size() &lt; k)&#123;<br>            pq.offer(num);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; pq.peek())&#123;<br>            pq.poll();<br>            pq.offer(num);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//返回堆中元素</span><br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[pq.size()];<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : pq) &#123;<br>        res[idx++] = num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>方法三：快排</p>
<h2 id="3-2-数据流中的中位数"><a href="#3-2-数据流中的中位数" class="headerlink" title="3.2 数据流中的中位数"></a>3.2 数据流中的中位数</h2><p>​    题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addNum(int num)     - 从数据流中添加一个整数到数据结构中。</li>
<li>double findMedian()         - 返回目前所有元素的中位数。</li>
</ul>
<p>方法一：</p>
<blockquote>
<p>​    给定一长度为 N 的无序数组，其中位数的计算方法：首先对数组执行排序O(NlogN) 时间），然后返回中间元素即可（使用 O(1) 时间）。</p>
</blockquote>
<p>​    根据以上思路，可以将数据流保存在一个列表中，并在添加元素时 保持数组有序 。此方法的时间复杂度为 O(N) ，其中包括： 查找元素插入位置 O(logN) （二分查找）、向数组某位置插入元素 O(N) （插入位置之后的元素都需要向后移动一位）。</p>
<p>方法二：</p>
<blockquote>
<p>借助 <strong>堆</strong> 可进一步优化时间复杂度。</p>
</blockquote>
<p>​    建立一个 <strong>小顶堆</strong> <em>A</em> 和 <strong>大顶堆</strong> <em>B</em> ，各保存列表的一半元素，且规定：</p>
<ul>
<li>A 保存 较大 的一半，长度为 $\frac{N}{2} $（ N 为偶数）或 $\frac{N+1}{2}$ （ N 为奇数）；</li>
<li>B 保存 较小 的一半，长度为 $\frac{N}{2} $（ N 为偶数）或 $\frac{N-1}{2}$ （ N 为奇数）；</li>
</ul>
<p>随后，中位数可仅根据 <em>A</em>,<em>B</em> 的堆顶元素计算得到。</p>
<p>算法流程：</p>
<blockquote>
<p>设元素总数为 N = m + n，其中 m 和 n 分别为 A 和 B 中的元素个数。</p>
</blockquote>
<p>addNum(num) 函数：</p>
<ol>
<li><p>当m=n（即 N 为 偶数）：需向 A 添加一个元素。实现方法：将新元素 num 插入至 B ，再将 B 堆顶元素插入至 A ；</p>
</li>
<li><p>当 m!=n（即 N 为奇数）：需向 B 添加一个元素。实现方法：将新元素 num 插入至 A ，再将 A 堆顶元素插入至 B ；</p>
<blockquote>
<p>假设插入数字 num 遇到情况 1. 。由于 num 可能属于 “较小的一半” （即属于 B ），因此不能将 nums 直接插入至 A 。而应先将 num 插入至 B ，再将 B 堆顶元素插入至 A 。这样就可以始终保持 A 保存较大一半、 B 保存较小一半。</p>
</blockquote>
</li>
</ol>
<p>findMedian() 函数：</p>
<p>当 m=n（ N 为 偶数）：则中位数为 ( A 的堆顶元素 + B 的堆顶元素 )/2。</p>
<p>当m!=n（ N 为 奇数）：则中位数为 A 的堆顶元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> </span>&#123;<br><br>    Queue&lt;Integer&gt; A, B;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 小顶堆，保存较大的一半</span><br>        A = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>        <span class="hljs-comment">// 大顶堆，保存较小的一半</span><br>        B = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((x, y) -&gt; (y - x));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(A.size()!=B.size())&#123;<br>            A.add(num);<br>            B.add(A.poll());<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            B.add(num);<br>            A.add(B.poll());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> A.size() != B.size() ? A.peek() : (A.peek() +B.peek())/<span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="4-栈-队列"><a href="#4-栈-队列" class="headerlink" title="4. 栈/队列"></a>4. 栈/队列</h1><h2 id="4-1-用两个栈实现队列"><a href="#4-1-用两个栈实现队列" class="headerlink" title="4.1 用两个栈实现队列"></a>4.1 用两个栈实现队列</h2><p>​    题目：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p>​    队列的特性是先进先出，栈的特性是后进先出，两个栈不就是先进先出了吗，难点在于两个栈怎样配合，因为栈2有值时栈1不能pop(栈2push)，这样无法保持队列先进先出的特性。</p>
<p>​    规则是：栈2空时，栈1才能pop，而且必须全部pop，不然部分pop栈1push仍然会无法保持队列先进先出的特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JZ5</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</span><br><span class="hljs-comment">    * */</span><br><br>    Stack&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    Stack&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>        stack1.push(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack2.empty())&#123;<br>            <span class="hljs-keyword">while</span> (!stack1.empty())&#123;<br>                stack2.push(stack1.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack2.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-2-包含min函数的栈"><a href="#4-2-包含min函数的栈" class="headerlink" title="4.2 包含min函数的栈"></a>4.2 包含min函数的栈</h2><p>​    题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的<font color="red">时间复杂度都是 O(1)</font>。</p>
<blockquote>
<p> 普通栈的 <code>push()</code> 和 <code>pop()</code> 函数的复杂度为 O*(1) ；而获取栈最小值 <code>min()</code> 函数需要遍历整个栈，复杂度为 O(N) 。</p>
</blockquote>
<ul>
<li>难点：将min()函数复杂度降为O(1)，可通过辅助栈实现。<ul>
<li>数据栈A:栈 A 用于存储所有元素，保证入栈 <code>push()</code> 函数、出栈 <code>pop()</code> 函数、获取栈顶 <code>top()</code> 函数的正常逻辑。</li>
<li>辅助栈B:栈 B 中存储栈 A 中所有非严格降序的元素，则栈 A 中的最小元素始终对应栈 B 的栈顶元素，即 min() 函数只需返回栈 B 的栈顶元素即可。</li>
</ul>
</li>
<li>因此，只需设法维护好 栈 B的元素，使其保持非严格降序，即可实现 <code>min()</code> 函数的 O(1)复杂度。</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/f31f4b7f5e91d46ea610b6685c593e12bf798a9b8336b0560b6b520956dd5272-Picture1.png" srcset="/img/loading.gif" alt="Picture1.png" style="zoom: 50%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;<br><br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    Stack&lt;Integer&gt; A,B;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;<br>        A = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        B = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        A.add(x);<br>        <span class="hljs-keyword">if</span>(B.empty() || x&lt;=B.peek())&#123;<br>            B.add(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (A.pop().equals(B.peek()))&#123;<br>            B.pop();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> A.peek();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> B.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>stack.peek()作用为返回栈顶元素而不删除。</li>
<li>注意B.empty() || x&lt;=B.peek()前后不能颠倒，因为先判断前面，||有短路作用。</li>
</ul>
<h2 id="4-3-栈的压入、弹出序列"><a href="#4-3-栈的压入、弹出序列" class="headerlink" title="4.3 栈的压入、弹出序列"></a>4.3 栈的压入、弹出序列</h2><p>​    题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<p>辅助栈，模拟</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pushed, <span class="hljs-keyword">int</span>[] popped)</span> </span>&#123;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : pushed)&#123;<br>        stack.push(num);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[i])&#123;<br>            stack.pop();<br>            i++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-4-队列的最大值"><a href="#4-4-队列的最大值" class="headerlink" title="4.4 队列的最大值"></a>4.4 队列的最大值</h2><p>​    题目：请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] q = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">20000</span>];<br>   <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxQueue</span><span class="hljs-params">()</span> </span>&#123;<br><br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> ans = -<span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = begin; i != end; ++i)&#123;<br>           ans = Math.max(ans,q[i]);<br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>       q[end++] = value;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (begin == end)&#123;<br>           <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> q[begin++];<br>   &#125;<br></code></pre></td></tr></table></figure>
<h1 id="5-树"><a href="#5-树" class="headerlink" title="5. 树"></a>5. 树</h1><h2 id="5-1-重建二叉树"><a href="#5-1-重建二叉树" class="headerlink" title="5.1 重建二叉树"></a>5.1 重建二叉树</h2><p>​    题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p>​    重建二叉树是二叉树中非常基本的题目，在草稿上重建很简单，怎么在代码中实现。</p>
<p>​    在草稿上可以看出重建二叉树是重复的完成动作，不断的在划分出的子序列中去递归子树。因此使用递归。</p>
<p>​    注意<font color='red'>Arrays.copyOfRange(T[ ] original,int from,int to)</font>这个方法，是将一个原始的数组original，从下标from开始复制，复制到上标to，生成一个新的数组。注意这里包括下标from，<strong>不包括</strong>上标to。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>          <span class="hljs-keyword">int</span> val;<br>          TreeNode left;<br>         TreeNode right;<br>         TreeNode(<span class="hljs-keyword">int</span> x) &#123; val = x; &#125;<br>      &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JZ4</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。</span><br><span class="hljs-comment">     * 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</span><br><span class="hljs-comment">     * 例如输入前序遍历序列&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;，</span><br><span class="hljs-comment">     * 则重建二叉树并返回。</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] pre = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>&#125;;<br>        <span class="hljs-keyword">int</span>[] in  = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>&#125;;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pre, <span class="hljs-keyword">int</span>[] in)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pre.length==<span class="hljs-number">0</span>||in.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//递归出口</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(pre[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;in.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (in[i] == pre[<span class="hljs-number">0</span>])&#123;<br>                root.left = 	reConstructBinaryTree(Arrays.copyOfRange(pre,<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>),Arrays.copyOfRange(in,<span class="hljs-number">0</span>,i));<br>                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre,i+<span class="hljs-number">1</span>,pre.length),Arrays.copyOfRange(in,i+<span class="hljs-number">1</span>,in.length));<br>                <span class="hljs-comment">//循环出口</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-2-树的子结构"><a href="#5-2-树的子结构" class="headerlink" title="5.2 树的子结构"></a>5.2 树的子结构</h2><p>​    题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>​    和链表相比，树的操作更多也更复杂，因此与树相关的问题通常会比链表的要难。如果想加大面试的难度，树的题目是很多面试官的选择。</p>
<p>​    首先遍历二叉树A，当A的结点值m_value和B根节点值相同时判断B的结构和m_value是否相同。显然，遍历和判断是两个函数，并且都可使用递归。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (A == <span class="hljs-keyword">null</span> || B == <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;<br>       <span class="hljs-comment">//先序遍历</span><br>       <span class="hljs-keyword">if</span> (A.val == B.val &amp;&amp; recur(A.left, B.left) &amp;&amp; recur(A.right, B.right)) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> isSubStructure(A.left, B) ||  isSubStructure(A.right, B);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;<br>       <span class="hljs-comment">//判断A,b结构是否相同</span><br><br>       <span class="hljs-comment">//递归出口</span><br>       <span class="hljs-keyword">if</span> (B == <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (A == <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;<br><br><br>       <span class="hljs-comment">//向下递归</span><br>       <span class="hljs-keyword">if</span> (A.val == B.val)&#123;<br>           <span class="hljs-keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;<br>       <br>   &#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-3-二叉树的镜像"><a href="#5-3-二叉树的镜像" class="headerlink" title="5.3 二叉树的镜像"></a>5.3 二叉树的镜像</h2><p>题目：请完成一个函数，输入一个二叉树，该函数输出它的镜像</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-comment">//递归出口</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    <br>        &#125;<br><br>        <span class="hljs-comment">//递归,直接交换结点不交换值</span><br>        TreeNode tmp = root.left;<br>        root.left = mirrorTree(root.right);<br>        root.right = mirrorTree(tmp);<br>        <br>        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-4-对称的二叉树"><a href="#5-4-对称的二叉树" class="headerlink" title="5.4 对称的二叉树"></a>5.4 对称的二叉树</h2><p>​    题目：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">//判断树是否是对称</span><br>    <span class="hljs-keyword">return</span> root == <span class="hljs-keyword">null</span> || recur(root.left, root.right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode L, TreeNode R)</span> </span>&#123;<br>    <span class="hljs-comment">//判断两个树是否镜像</span><br>    <span class="hljs-keyword">if</span> (L == <span class="hljs-keyword">null</span> &amp;&amp; R == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (L == <span class="hljs-keyword">null</span> || R == <span class="hljs-keyword">null</span> || L.val != R.val)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> recur(L.left,R.right) &amp;&amp; recur(L.right,R.left);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-5-从上到下打印二叉树Ⅰ"><a href="#5-5-从上到下打印二叉树Ⅰ" class="headerlink" title="5.5 从上到下打印二叉树Ⅰ"></a>5.5 从上到下打印二叉树Ⅰ</h2><p>​    题目：从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p>​    层次遍历二叉树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] levelOrder(TreeNode root) &#123;<br>    <span class="hljs-comment">//利用队列的先进先出特性</span><br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;<br>    ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>        TreeNode treeNode = queue.poll();<br>        ans.add(treeNode.val);<br>        <span class="hljs-keyword">if</span> (treeNode.left != <span class="hljs-keyword">null</span>)&#123;<br>            queue.add(treeNode.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (treeNode.right != <span class="hljs-keyword">null</span>)&#123;<br>            queue.add(treeNode.right);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ans.size()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; ans.size();i++)&#123;<br>        res[i] = ans.get(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-6-从上到下打印二叉树Ⅱ"><a href="#5-6-从上到下打印二叉树Ⅱ" class="headerlink" title="5.6 从上到下打印二叉树Ⅱ"></a>5.6 从上到下打印二叉树Ⅱ</h2><p>​    题目：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>​    <font color='red'>当前层打印循环：</font> 循环次数为当前层节点数（即队列 <code>queue</code> 长度）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>)&#123;<br>        queue.add(root);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = queue.size();i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>            TreeNode node = queue.poll();<br>            tmp.add(node.val);<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(node.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(node.right);<br>            &#125;<br>        &#125;<br>        res.add(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<font color='red'>注意</font>for循环时不能使用下列操作：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; queue.size(); i++)&#123;<br>    TreeNode node = queue.poll();<br>    tmp.add(node.val);<br>    <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;<br>        queue.add(node.left);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;<br>        queue.add(node.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
for循环第二个条件是每次循环都要执行的，而队列的长度一直变化，所以应该使用i--的方式循环。





## 5.7 从上到下打印二叉树Ⅲ

​    题目：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>)&#123;<br>        queue.add(root);<br>    &#125;<br>    Boolean flag = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>        LinkedList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = queue.size();i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>            TreeNode node = queue.poll();<br>            <span class="hljs-keyword">if</span>(!flag)&#123;<br>                tmp.addLast(node.val);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                tmp.addFirst(node.val);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(node.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(node.right);<br>            &#125;<br>        &#125;<br>        flag = !flag;<br>        res.add(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>


## 5.8 二叉搜索树的后序遍历序列

​    题目：输入一个整数数组，判断该数组是不是某<font color='red'>二叉搜索树</font>的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

​    该二叉搜索树并不是给定的，而是判断给定的整数数组是否符合二叉搜索树的后序遍历定义。

方法一：递归分治

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> recur(postorder,<span class="hljs-number">0</span>,postorder.length-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= j)&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<br>    <span class="hljs-keyword">int</span> p = i;<br>    <span class="hljs-keyword">while</span> (postorder[p] &lt; postorder[j])&#123;p++;&#125;<br>    <span class="hljs-keyword">int</span> m = p;<br>    <span class="hljs-keyword">while</span> (postorder[p] &gt; postorder[j])&#123;p++;&#125;<br>    <span class="hljs-keyword">return</span> p == j &amp;&amp; recur(postorder,i,m-<span class="hljs-number">1</span>) &amp;&amp; recur(postorder,m,j-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
这里递归的终止条件是i>=j而不是i==j，因为左子树为空的时候recur(i,m-1)时*i>j*。

方法二：辅助单调栈

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;<br>       Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>       <span class="hljs-keyword">int</span> root = Integer.MAX_VALUE;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = postorder.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>           <span class="hljs-keyword">if</span>(postorder[i] &gt; root) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>           <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &gt; postorder[i])<br>           	root = stack.pop();<br>           stack.add(postorder[i]);<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>


## 5.9 二叉树中和为某一值的路径

​    题目：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

- 记录路径时若直接执行 res.append(path) 是将 path 对象加入了 res 。后续 path 改变时， res 中的 path 对象也会随之改变。应该res.append(list(path))进行<font color = 'red'>深拷贝</font> 。
- 注意path是全局变量，所以回溯前需要将当前结点从path中删除。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;<br>    recur(root,sum);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode root,<span class="hljs-keyword">int</span> tar)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">return</span>;&#125;<br>    path.add(root.val);<br>    tar -= root.val;<br>    <span class="hljs-keyword">if</span> (tar == <span class="hljs-number">0</span> &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)&#123;<br>        res.add(<span class="hljs-keyword">new</span> LinkedList(path));<br>    &#125;<br>    recur(root.left,tar);<br>    recur(root.right,tar);<br>    path.removeLast();<br>&#125;<br></code></pre></td></tr></table></figure>




## 5.10 二叉搜索树与双向链表

题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

为了让您更好地理解问题，以下面的二叉搜索树为例：

 <img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/bstdlloriginalbst.png" srcset="/img/loading.gif" alt="img" style="zoom: 50%;" />





​    我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

​    下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。

 ![img](http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/bstdllreturndll.png)





​        特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"> Node head, pre;<br><br> <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>     &#125;<br>     dfs(root);<br>     head.left = pre;<br>     pre.right = head;<br>     <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node cur)</span></span>&#123;<br>     <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">return</span>;&#125;<br>     dfs(cur.left);<br>     <span class="hljs-keyword">if</span> (pre == <span class="hljs-keyword">null</span>)&#123;<br>         head = cur;<br>     &#125;<span class="hljs-keyword">else</span> &#123;pre.right = cur;&#125;<br>     cur.left = pre;<br>     pre = cur;<br>     dfs(cur.right);<br>&#125;<br></code></pre></td></tr></table></figure>
## 5.11 序列化二叉树

​    题目：

​    请实现两个函数，分别用来序列化和反序列化二叉树。

​    示例: 

​    你可以将以下二叉树：

​    1

   / \
  2   3
     / \
    4   5

序列化为 "[1,2,3,null,null,4,5]"

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[]&quot;</span>;&#125;<br>    StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;[&quot;</span>);<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>        TreeNode node = queue.poll();<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)&#123;<br>            res.append(node.val+<span class="hljs-string">&quot;,&quot;</span>);<br>            queue.add(node.left);<br>            queue.add(node.right);<br>        &#125;<span class="hljs-keyword">else</span> &#123;res.append(<span class="hljs-string">&quot;null,&quot;</span>);&#125;<br>    &#125;<br>    res.deleteCharAt(res.length()-<span class="hljs-number">1</span>);<br>    res.append(<span class="hljs-string">&quot;]&quot;</span>);<br>    <span class="hljs-keyword">return</span> res.toString();<br>&#125;<br><br><span class="hljs-comment">/**Decodes your encoded data to tree.*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (data.equals(<span class="hljs-string">&quot;[]&quot;</span>))&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<br>    String[] vals = data.substring(<span class="hljs-number">1</span>,data.length()-<span class="hljs-number">1</span>).split(<span class="hljs-string">&quot;,&quot;</span>);<br>    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[<span class="hljs-number">0</span>]));<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        TreeNode node = queue.poll();<br>        <span class="hljs-keyword">if</span> (!vals[i].equals(<span class="hljs-string">&quot;null&quot;</span>))&#123;<br>            node.left = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[i]));<br>            queue.add(node.left);<br>        &#125;<br>        i++;<br>        <span class="hljs-keyword">if</span> (!vals[i].equals(<span class="hljs-string">&quot;null&quot;</span>))&#123;<br>            node.right = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[i]));<br>            queue.add(node.right);<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>
## 5.12 二叉搜索树的第k大节点

​    题目：给定一棵二叉搜索树，请找出其中第k大的节点。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> res,k;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.k = k;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.right);<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        k--;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            res = root.val;<br>        &#125;<br>        dfs(root.left);<br>    &#125;<br></code></pre></td></tr></table></figure>


## 5.13 二叉树的深度Ⅰ

​    题目：输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


## 5.14 二叉树的深度Ⅱ

​    题目：输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<br>    <span class="hljs-keyword">return</span> Math.abs(depth(root.left) - depth(root.right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">return</span> Math.max(depth(root.left), depth(root.right)) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
## 5.15 二叉搜索树的最近公共祖先

​    题目：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)

若 root 是 p,q的 最近公共祖先 ，则只可能为以下情况之一：

p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；
p = root，且 q 在 root 的左或右子树中；
q = root，且 p 在 root 的左或右子树中；

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;<br>            root = root.right;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;<br>            root = root.left;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>


## 5.16 二叉树的最近公共祖先

​    题目：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png)

- 三种情况：
  - p q 一个在左子树 一个在右子树 那么当前节点即是最近公共祖先（返回）
  - p q 都在左子树 （递归左子树）
  - p q 都在右子树（递归右子树）

后序遍历，从底至顶回溯

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>       <span class="hljs-comment">//递归出口</span><br>       <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root == p || root == q) &#123;<br>           <span class="hljs-keyword">return</span> root;<br>       &#125;<br>       <span class="hljs-comment">//在左子树中找p或q</span><br>       TreeNode left = lowestCommonAncestor(root.left, p, q);<br>       <span class="hljs-comment">//在右子树中找p或q</span><br>       TreeNode right = lowestCommonAncestor(root.right, p, q);<br>      <br>       <span class="hljs-comment">//都分布在左侧，也就是右侧没找到</span><br>       <span class="hljs-keyword">if</span> (right == <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> left;<br>       &#125;<br>       <span class="hljs-comment">//都分布在右侧，也就是左侧没找到</span><br>       <span class="hljs-keyword">if</span> (left== <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> right;<br>       &#125;<br>       <span class="hljs-comment">//最后一种情况分布在异侧 if(left != null &amp;&amp; right != null)</span><br>       <span class="hljs-keyword">return</span> root;<br>   &#125;<br></code></pre></td></tr></table></figure>


# 6. 动态规划

## 6.1 斐波那契数列

​    题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n<=39

首先斐波那契数列：
$$
f(n)=\begin{cases}
 0, & n=0\\
1, &n=1\\
f(n-1)+f(n-2),&n>1
\end{cases}
$$
公式并不难，经典的递归解法是：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Fibonacci(n-<span class="hljs-number">1</span>) + Fibonacci(n-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
​    这种解法虽然简单，但是有太多的重复计算影响效率。我们以求解f(10)为例来分析递归的求解过程。想求得f(10)，需要先求得f(9)和f(8)。同样，想求得f(9)，需要先求得f(8)和f(7)……这样计算有很多结点是重复的，且重复的结点会随着n的增大而急剧增加，时间复杂度以n的指数的方式递增。

​    实用解法：上述递归算法慢是因为重复计算太多，我们应该想办法避免重复计算。简单的方法是从下往上计算。可以用一个数组把计算过的结果保存起来。比如

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">40</span>];<br>    ans[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    ans[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        ans[i] = ans[i-<span class="hljs-number">1</span>] + ans[i-<span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans[n];<br>&#125;<br></code></pre></td></tr></table></figure>


用数组会占用O(n)的空间，事实上我们只需要存储两个值即可完成计算：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n&lt;<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-keyword">int</span> fibOne = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> fibTwo = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> fibN = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        fibN = fibOne + fibTwo;<br>        fibOne = fibTwo;<br>        fibTwo = fibN;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fibN;<br>&#125;<br></code></pre></td></tr></table></figure>
## 6.2 跳台阶

题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

​    如果青蛙当前在第n级台阶上，那它上一步是在哪里呢？

​    它上一步必定在第n-1,或者第n-2级台阶，也就是说它跳上n级台阶的跳法数是跳上n-1和跳上n-2级台阶的跳法数之和。即：
$$
f(n)=f(n-1)+f(n-2)
$$
那么n<=2的情况，跳上1阶有一种方法，跳到第2阶有两种。即：
$$
f(n)=\begin{cases} 1, & n=1\\2, &n=2\\f(n-1)+f(n-2),&n>2\end{cases}
$$
是斐波那契数列的变形，代码：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">3</span>)&#123;<br>          <span class="hljs-keyword">return</span> n;<br>      &#125;<br>      <span class="hljs-keyword">int</span> fibOne = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">int</span> fibTwo = <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">int</span> fibN = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>          fibN = (fibOne + fibTwo) % <span class="hljs-number">1000000007</span>;<br>          fibOne = fibTwo;<br>          fibTwo = fibN;<br>      &#125;<br>      <span class="hljs-keyword">return</span> fibN;<br>  &#125;<br></code></pre></td></tr></table></figure>
## 6.3 变态跳台阶

题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

还是跳台阶的思路：
$$
f(n) = f(1)+f(2)+...+f(n-1)+1\\
f(n-1) = f(1)+f(2)+...+f(n-2)+1
$$
两式相减得：
$$
f(n)=2f(n-1)
$$
其实根据数学归纳法得到：
$$
f(n)=2^{n-1}
$$
代码：

上面的公式

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">JumpFloorII</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (target==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>    <span class="hljs-keyword">int</span> fibN = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> fibFlag = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=target;i++)&#123;<br>        fibN = <span class="hljs-number">2</span>*fibFlag;<br>        fibFlag = fibN;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fibN;<br>&#125;<br></code></pre></td></tr></table></figure>
下面的公式

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">JumpFloorII2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">2</span>,target-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
## 6.4 剪绳子Ⅰ

​    题目：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

数学推导：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> b = n % <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">3</span>, a);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">3</span>, a-<span class="hljs-number">1</span>)*<span class="hljs-number">4</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">3</span>, a)*<span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
动态规划算法：

首先是暴力递归：

设 *F*(*n*) 为长度为 *n* 的绳子可以得到的最大乘积，对于每一个 *F*(*n*)，可以得到如下分解：

<img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/86e7c3368e2edd8c4bfc907b322204198b56cce7e82e7da9a43a8bbaab50cf9e-14.png" srcset="/img/loading.gif" alt="14.png" style="zoom: 33%;" />

建立一维动态数组 dp：

边界条件：dp[1] = dp[2] = 1，表示长度为 2 的绳子最大乘积为 1；
状态转移方程：$dp[i] = max(dp[i], max((i - j) * j, j * dp[i - j]))$，可以这样理解：

![剪绳子1.jpg](/img/剪绳子1.jpg)

*max(i - j , dp[i - j])*中考虑的是用i-j中的最大乘积是否比i-j大（因为*dp[i-j]*本身不包括自己一刀不剪的情况，*dp[i]=dp[i]*是维持当前状态不剪而不是从头开始一刀不剪）

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//dp[i]是最长度为i的绳子最大乘积</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">int</span> tmp1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> tmp2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//转移方程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (tmp1 &lt; j * dp[i - j]) &#123;<br>                    tmp1 = j * dp[i - j];<br>                &#125;<br>                <span class="hljs-keyword">if</span> (tmp2 &lt; (i-j)*j) &#123;<br>                    tmp2 = (i-j)*j;<br>                &#125;<br>                <br>            &#125;<br>            dp[i] = Math.max(Math.max(tmp1, dp[i]),  tmp2);<br>        &#125;<br><br><br>       <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br></code></pre></td></tr></table></figure>


## 6.5 剪绳子Ⅱ

​    题目：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**大数越界：** 当 a增大时，最后返回的 3^a大小以指数级别增长，可能超出 `int32` 甚至 `int64` 的取值范围(包括double甚至是long long)，导致返回值错误。解决方法是循环求余或快速幂求余，两种方法均基于以下规则推出：
$$
(xy)\odot p = [(x\odot p )(y\odot p)]\odot p
$$
循环求余：

- 根据求余运算性质推出（∵ 本题中x<p，∴ x%p=*x* ）：

  ​    
  $$
  x^a\odot p=[(x^{a-1}\odot p)(x\odot p)]\odot p =[(x^{a-1}\odot p)x]\odot p
  $$

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a - <span class="hljs-number">1</span>; i++)&#123;<br>    rem = (rem * <span class="hljs-number">3</span>) % p;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> b = n % <span class="hljs-number">3</span>, p = <span class="hljs-number">1000000007</span>, a = n/<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">long</span> rem = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a - <span class="hljs-number">1</span>; i++)&#123;<br>        rem = (rem * <span class="hljs-number">3</span>) % p;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">3</span> % p);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">4</span> % p);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">6</span> % p);<br>&#125;<br></code></pre></td></tr></table></figure>
快速幂求余：
$$
x^a\odot p=(x^2)^{a/2}\odot p =(x^2\odot p)^{a/2}\odot p
$$
a为奇数和偶数时：



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">//快速幂求余</span><br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> b = n % <span class="hljs-number">3</span>, p = <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-keyword">long</span> rem = <span class="hljs-number">1</span>, x = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span> - <span class="hljs-number">1</span>; a &gt; <span class="hljs-number">0</span>; a /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span>(a % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            rem = (rem * x) % p;<br>        &#125;<br>        x = (x * x) % p;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">3</span> % p);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">4</span> % p);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">6</span> % p);<br><br>&#125;<br></code></pre></td></tr></table></figure>
数学推导：

同上

贪心算法：

同上

## 6.6 正则表达式匹配

​    题目：请实现一个函数用来匹配包含' . '和' \*‘的正则表达式。模式中的字符'.'表示任意一个字符，而' \*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab\*ac\*a"匹配，但与"aa.a"和"ab\*a"均不匹配。

解题方法：本题使用<font color='red'>动态规划</font>。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    <span class="hljs-comment">//s待匹配，p是正则</span><br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">int</span> m = p.length();<br>    <span class="hljs-keyword">boolean</span>[][] dp= <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;= m; j++)&#123;<br>            <span class="hljs-comment">//空正则</span><br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)&#123;<br>                dp[i][j] = i == <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//非空正则 两种情况*和非*</span><br>                <span class="hljs-keyword">if</span> (p.charAt(j-<span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i-<span class="hljs-number">1</span>) == p.charAt(j-<span class="hljs-number">1</span>) || p.charAt(j-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))&#123;<br>                        dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//遇到*，分为看和不看</span><br>                    <span class="hljs-comment">//看</span><br>                    <span class="hljs-keyword">if</span> (i &gt;=<span class="hljs-number">1</span> &amp;&amp; j&gt;=<span class="hljs-number">2</span> &amp;&amp;(s.charAt(i-<span class="hljs-number">1</span>) == p.charAt(j-<span class="hljs-number">2</span>) || p.charAt(j-<span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))&#123;<br>                        dp[i][j] |= dp[i-<span class="hljs-number">1</span>][j];<br>                    &#125;<br>                    <span class="hljs-comment">//不看</span><br>                    <span class="hljs-keyword">if</span> (j&gt;=<span class="hljs-number">2</span>)&#123;<br>                        dp[i][j] |= dp[i][j-<span class="hljs-number">2</span>];<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure>
##  6.7 礼物的最大价值

​    题目：在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

<font color=red>动态规划</font>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (grid == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++)&#123;<br>        dp[<span class="hljs-number">0</span>][j] = grid[<span class="hljs-number">0</span>][j] + dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; grid.length; i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = grid[i][<span class="hljs-number">0</span>] + dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; grid.length; i++)&#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++)&#123;<br>            dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>])+ grid[i][j];<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-8-最长不含重复字符的子字符串"><a href="#6-8-最长不含重复字符的子字符串" class="headerlink" title="6.8 最长不含重复字符的子字符串"></a>6.8 最长不含重复字符的子字符串</h2><p>​    题目：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<font color=red>动态规划</font>

<ul>
<li><p>状态定义：设动态规划列表 $dp$ ，$dp[j]$ 代表以字符$ s[j]$ 为结尾的 “最长不重复子字符串” 的长度。</p>
</li>
<li><p>状态转移： 固定右边界$ j$，设字符 $s[j]$ 左边距离最近的相同字符为 $s[i]$ ，即 $s[i]=s[j]$ 。</p>
<ol>
<li><p>$i&lt;0$，即 $s[j]$ 左边无相同字符，则 $dp[j] = dp[j-1] + 1$；</p>
</li>
<li><p>当 $dp[j - 1] &lt; j - i$，说明字符 $s[i]$ 在子字符串$ dp[j−1]$ 区间之外 ，则 $dp[j]=dp[j−1]+1$ ；</p>
</li>
<li><p>当 $dp[j - 1] ≥j−i$ ，说明字符$ s[i]$ 在子字符串 $dp[j−1]$ 区间之中 ，则 $dp[j]$ 的左边界由 $s[i]$ 决定，即 $dp[j] = j - i$；</p>
<blockquote>
<p>当 i&lt;0 时，由于 dp[j−1]≤j 恒成立，因而 dp[j−1]&lt;j−i 恒成立，因此分支 1. 和 2. 可被合并。</p>
</blockquote>
<script type="math/tex; mode=display">
dp[j] = \begin{cases} dp[j - 1] + 1 & , dp[j-1] < j - i \\ 
j - i & , dp[j-1] \geq j - i 

\end{cases}</script></li>
</ol>
</li>
</ul>
<p>初始值计算：</p>
<p>方法一：动态规划+哈希表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    Map&lt;Character, Integer&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; s.length(); j++)&#123;<br>        <span class="hljs-keyword">int</span> i = dic.getOrDefault(s.charAt(j), -<span class="hljs-number">1</span>);<br>        dic.put(s.charAt(j),j);<br>        tmp = tmp &lt; j-i ? tmp+<span class="hljs-number">1</span> : j-i;<br>        res = Math.max(res,tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>方法二：滑动窗口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.length() &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> s.length();<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>,res = <span class="hljs-number">0</span>;<br>        HashMap&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (j &lt; s.length()) &#123;<br>            <span class="hljs-comment">//右移窗口</span><br>            <span class="hljs-keyword">char</span> tmpj = s.charAt(j);<br>            j++;<br>            <span class="hljs-comment">//更新数据</span><br>            map.put(tmpj, map.getOrDefault(tmpj, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//判断窗口</span><br>            <span class="hljs-keyword">while</span> (map.get(tmpj) &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">char</span> tmpi = s.charAt(i);<br>                map.put(tmpi, map.get(tmpi) - <span class="hljs-number">1</span>);<br>                i++;<br>            &#125;<br>            res  = Math.max(res, j - i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-9-n个骰子的点数"><a href="#6-9-n个骰子的点数" class="headerlink" title="6.9 n个骰子的点数"></a>6.9 n个骰子的点数</h2><p>​    题目：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] twoSum(<span class="hljs-keyword">int</span> n) &#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>][<span class="hljs-number">6</span> * n + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//1.确定初始状态</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++)&#123;<br>        dp[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//2.转移方程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt;= <span class="hljs-number">6</span> * i; j++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">6</span> &amp;&amp; k &lt;= j; k++)&#123;<br>                dp[i][j] += dp[i-<span class="hljs-number">1</span>][j - k];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">double</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[<span class="hljs-number">6</span> * n - n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &lt;= <span class="hljs-number">6</span> * n;i++)&#123;<br>        ans[i - n] = ((<span class="hljs-keyword">double</span>)dp[n][i]) / (Math.pow(<span class="hljs-number">6</span>,n));<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-10-股票的最大利润"><a href="#6-10-股票的最大利润" class="headerlink" title="6.10 股票的最大利润"></a>6.10 股票的最大利润</h2><p>​    题目：假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cost = Integer.MAX_VALUE, profit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> price : prices) &#123;<br>        cost = Math.min(cost,price);<br>        profit = Math.max(profit,price-cost);<br>    &#125;<br>    <span class="hljs-keyword">return</span> profit;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-11-把数字翻译成字符串"><a href="#6-11-把数字翻译成字符串" class="headerlink" title="6.11 把数字翻译成字符串"></a>6.11 把数字翻译成字符串</h2><p>​    题目：给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p>​    当 $num$ 第 1, 2 位的组成的数字 $\in [10,25]$ 时，显然应有 2 种翻译方法，即 $dp[2] = dp[1] + dp[0] = 2$ ，而显然 $dp[1] = 1$ ，因此推出 $dp[0] = 1$ 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    String s = String.valueOf(num);<br>    <span class="hljs-comment">// dp[0]=dp[1]=1 ，即 “无数字” 和 “第 1 位数字” 的翻译方法数量均为 1 ；</span><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>,b = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= s.length(); i++)&#123;<br>        String tmp = s.substring(i-<span class="hljs-number">2</span>,i);<br>        <span class="hljs-keyword">int</span> c = tmp.compareTo(<span class="hljs-string">&quot;10&quot;</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp.compareTo(<span class="hljs-string">&quot;25&quot;</span>) &lt;= <span class="hljs-number">0</span> ? a+b : a;<br>        b = a;<br>        a = c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="7-DFS-amp-BFS"><a href="#7-DFS-amp-BFS" class="headerlink" title="7. DFS&amp;BFS"></a>7. DFS&amp;BFS</h1><h2 id="7-1-机器人的运动范围"><a href="#7-1-机器人的运动范围" class="headerlink" title="7.1 机器人的运动范围"></a>7.1 机器人的运动范围</h2><p>​    题目：地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p>​    矩阵搜索问题，通常可使用 深度优先搜索（DFS） 或 广度优先搜索（BFS） 解决。在进行具体算法之前先要进行的工作是数位之和的计算和搜索方向的简化。</p>
<p>数位之和的计算：逢10突变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(x + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? s_x + <span class="hljs-number">1</span> : s_x - <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>
<p>搜索方向简化：</p>
<ul>
<li>解的三角形结构：<ul>
<li>根据数位和特点，矩阵中满足数位和的解 构成的几何形状形如多个 等腰直角三角形 ，每个三角形的直角顶点位于 0, 10, 20, …0,10,20,… 等数位和突变的矩阵索引处 。</li>
<li>三角形内的解虽然都满足数位和要求，但由于机器人每步只能走一个单元格，而三角形间不一定是连通的，因此机器人不一定能到达，称之为 不可达解 ；同理，可到达的解称为 可达解 （本题求此解） 。</li>
</ul>
</li>
<li>结论： 根据可达解的结构，易推出机器人可 仅通过向右和向下移动，访问所有可达解 。<ul>
<li>三角形内部： 全部连通，易证；</li>
<li>两三角形连通处： 若某三角形内的解为可达解，则必与其左边或上边的三角形连通（即相交），即机器人必可从左边或上边走进此三角形。</li>
</ul>
</li>
</ul>
<p>深度优先（DFS）:</p>
<ul>
<li><p>深度优先搜索： 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</p>
</li>
<li><p>剪枝： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 可行性剪枝 。</p>
<p>算法解析：</p>
<ul>
<li>递归参数： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 si, sj 。</li>
<li>终止条件： 当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 00 ，代表不计入可达解。</li>
<li>递推工作：<ul>
<li>标记当前单元格 ：将索引 (i, j) 存入 Set visited 中，代表此单元格已被访问过。</li>
<li>搜索下一单元格： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 。</li>
</ul>
</li>
<li>回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。</li>
</ul>
</li>
</ul>
<p>复杂度分析：</p>
<blockquote>
<p>M,N 分别为矩阵行列大小。</p>
</blockquote>
<ul>
<li>时间复杂度 O(MN) ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN) </li>
<li>空间复杂度 O(MN) ： 最差情况下，Set visited 内存储矩阵所有单元格的索引，使用 O(MN) 的额外空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> m,n,k;<br><span class="hljs-keyword">boolean</span>[][] visited;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">//DFS解法</span><br>    <span class="hljs-keyword">this</span>.m = m;<br>    <span class="hljs-keyword">this</span>.n = n;<br>    <span class="hljs-keyword">this</span>.k = k;<br>    <span class="hljs-keyword">this</span>.visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];<br><br>    <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> si, <span class="hljs-keyword">int</span> sj)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= m || j &gt;= n || si + sj &gt; k || visited[i][j] )&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    visited[i][j] = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dfs(i+<span class="hljs-number">1</span>,j,(i+<span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? si+<span class="hljs-number">1</span> : si - <span class="hljs-number">8</span>,sj) + dfs(i,j+<span class="hljs-number">1</span>,si,(j+<span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? sj+<span class="hljs-number">1</span> : sj-<span class="hljs-number">8</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>广度优先（BFS）:</p>
<p>通常使用队列完成广度优先。</p>
<p>算法解析：</p>
<ul>
<li>初始化： 将机器人初始点 (0, 0)(0,0) 加入队列 queue ；</li>
<li>迭代终止条件： queue 为空。代表已遍历完所有可达解。</li>
<li>迭代工作：<ul>
<li>单元格出队： 将队首单元格的 索引、数位和 弹出，作为当前搜索单元格。</li>
<li>判断是否跳过： 若 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，执行 continue 。</li>
<li>标记当前单元格 ：将单元格索引 (i, j) 存入 Set visited 中，代表此单元格 已被访问过 。</li>
<li>单元格入队： 将当前元素的 下方、右方 单元格的 索引、数位和 加入 queue 。</li>
</ul>
</li>
<li>返回值： Set visited 的长度 len(visited) ，即可达解的数量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">//BFS解法</span><br>    <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    Queue&lt;<span class="hljs-keyword">int</span>[]&gt; queue= <span class="hljs-keyword">new</span> LinkedList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;);<br>    <span class="hljs-keyword">while</span>(queue.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span>[] x = queue.poll();<br>        <span class="hljs-keyword">int</span> i = x[<span class="hljs-number">0</span>], j = x[<span class="hljs-number">1</span>], si = x[<span class="hljs-number">2</span>], sj = x[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        visited[i][j] = <span class="hljs-keyword">true</span>;<br>        res ++;<br>        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; i + <span class="hljs-number">1</span>, j, (i + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? si + <span class="hljs-number">1</span> : si - <span class="hljs-number">8</span>, sj &#125;);<br>        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; i, j + <span class="hljs-number">1</span>, si, (j + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? sj + <span class="hljs-number">1</span> : sj - <span class="hljs-number">8</span> &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="7-2-字符串的排列"><a href="#7-2-字符串的排列" class="headerlink" title="7.2 字符串的排列"></a>7.2 字符串的排列</h2><p>​    题目：输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p>全排序问题，DFS回溯</p>
<p>示例：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;acb&quot;</span>,<span class="hljs-string">&quot;bac&quot;</span>,<span class="hljs-string">&quot;bca&quot;</span>,<span class="hljs-string">&quot;cab&quot;</span>,<span class="hljs-string">&quot;cba&quot;</span>]<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">  List&lt;String&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  <span class="hljs-keyword">char</span>[] c;<br><br><br><span class="hljs-comment">/**  输入一个字符串，打印出该字符串中字符的所有排列。</span><br><span class="hljs-comment">  你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。*/</span><br>  <span class="hljs-keyword">public</span> String[] permutation(String s) &#123;<br>      c = s.toCharArray();<br>      dfs(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> String[res.size()]);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>      <span class="hljs-comment">//结束条件</span><br>    <span class="hljs-keyword">if</span> (x == c.length-<span class="hljs-number">1</span>)&#123;<br>      res.add(String.valueOf(c));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x; i &lt; c.length; i++)&#123;<br>        <span class="hljs-comment">//剪枝</span><br>      <span class="hljs-keyword">if</span> (set.contains(c[i]))&#123;<span class="hljs-keyword">continue</span>;&#125;<br>        <span class="hljs-comment">//做选择</span><br>      set.add(c[i]);<br>      swap(x,i);<br>      dfs(x+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//撤销选择</span><br>      swap(x,i);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">char</span> tmp = c[a];<br>    c[a] = c[b];<br>    c[b] = tmp;<br>  &#125;<br></code></pre></td></tr></table></figure>
<h1 id="8-位运算"><a href="#8-位运算" class="headerlink" title="8. 位运算"></a>8. 位运算</h1><h2 id="8-1-二进制中1的个数"><a href="#8-1-二进制中1的个数" class="headerlink" title="8.1 二进制中1的个数"></a>8.1 二进制中1的个数</h2><p>​    题目：输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p>
<p>​    简单的方法是直接遍历二进制每一位进行统计得出结果，但是还要考虑负数补码的问题。但涉及到位运算还有更巧妙的算法：    </p>
<p>两种方法：</p>
<p>逐位判断：</p>
<p>利用无符号右移和与运算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            count += n &amp; <span class="hljs-number">1</span>;<br>            n &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>巧用 n \&amp; (n - 1)：</p>
<p>​    看到二进制，补码等关键字，首先想到位运算。把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。负数在Java内存中默认使用补码存储。基于这种思路，我们可以写出新的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>        n = n &amp; (n-<span class="hljs-number">1</span>);<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="8-2-数组中数字出现的次数Ⅰ"><a href="#8-2-数组中数字出现的次数Ⅰ" class="headerlink" title="8.2 数组中数字出现的次数Ⅰ"></a>8.2 数组中数字出现的次数Ⅰ</h2><p>​    题目：一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<font color='red'>位运算</font>

<p>​    O(n)未必是一次遍历，只要不嵌套循环即可。</p>
<blockquote>
<p>如果除了<strong>一个</strong>数字以外，其他数字都出现了两次，那么如何找到出现一次的数字</p>
</blockquote>
<p>​        全员进行异或操作即可。考虑异或操作的性质：对于两个操作数的每一位，相同结果为 0，不同结果为 1。那么在计算过程中，成对出现的数字的所有位会两两抵消为 0，最终得到的结果就是那个出现了一次的数字。</p>
<p>那么这一方法如何扩展到找出两个出现一次的数字呢？</p>
<p>如果我们可以把所有数字分成两组，使得：</p>
<ol>
<li>两个只出现一次的数字在不同的组中；</li>
<li>相同的数字会被分到相同的组中。</li>
</ol>
<p>那么对两个组分别进行异或操作，即可得到答案的两个数字。这是解决这个问题的关键。</p>
<p>那么如何实现这样的分组呢？</p>
<p>​    记这两个只出现了一次的数字为 a 和 b，那么所有数字异或的结果就等于 a 和 b 异或的结果，我们记为 x。如果我们把 x 写成二进制的形式$ x<em>k x</em>{k - 1} \cdots x_2 x_1 x_0$，其中$ x_i \in { 0, 1 }$,我们考虑一下 $x_i = 0$和 $x_i = 1$ 的含义是什么？它意味着如果我们把 a 和 b 写成二进制的形式，$a_i$和 $b_i的$关系——$x_i = 1$ 表示 $a_i$ 和 $b_i$  不等，$x_i = 0$ 表示 $a_i$  和 $b_i$相等。假如我们任选一个不为 0 的$ x_i $，按照第 i位给原来的序列分组，如果该位为 0 就分到第一组，否则就分到第二组，这样就能满足以上两个条件，为什么呢？</p>
<ul>
<li><p>首先，两个相同的数字的对应位都是相同的，所以一个被分到了某一组，另一个必然被分到这一组，所以满足了条件 2。</p>
</li>
<li><p>这个方法在$ x_i = 1$的时候 a和 b不被分在同一组，因为 $x_i = 1$表示 $a_i$和$ b_i$不等，根据这个方法的定义「如果该位为 0就分到第一组，否则就分到第二组」可以知道它们被分进了两组，所以满足了条件 1。</p>
<p>在实际操作的过程中，我们拿到序列的异或和 x 之后，对于这个「位」是可以任取的，只要它满足$ x_i = 1$。但是为了方便，这里的代码选取的是「不为 0 的最低位」，当然你也可以选择其他不为 0 的位置。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] singleNumbers(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//1.ret是所有数异或结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : nums) &#123;<br>        ret ^= n;<br>    &#125;<br>    <span class="hljs-comment">//2.取ret中不为0的最低位div</span><br>    <span class="hljs-keyword">int</span> div = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>((div &amp; ret) == <span class="hljs-number">0</span>)&#123;<br>        div &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//3.分组</span><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : nums)&#123;<br>        <span class="hljs-keyword">if</span> ((div &amp; n) != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//使用(div &amp; n) == 1不行</span><br>            a ^= n;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            b ^= n;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;a,b&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="8-3-数组中数字出现的次数Ⅱ"><a href="#8-3-数组中数字出现的次数Ⅱ" class="headerlink" title="8.3 数组中数字出现的次数Ⅱ"></a>8.3 数组中数字出现的次数Ⅱ</h2><p>​    题目：在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<font color='red'>位运算</font>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">32</span>];<br>    <span class="hljs-comment">//1.使用counts数组统计各位和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">32</span>; j++) &#123;<br>            <span class="hljs-comment">//更新第j位</span><br>            counts[j] += num &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//移位到j+1位</span><br>            num &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//2.将counts各位对3求余</span><br>    <span class="hljs-comment">//3.将counts数组恢复到res上</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, m = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; counts.length; i++) &#123;<br>        res &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//count的0处索引是最高位</span><br>        res |= counts[<span class="hljs-number">31</span> - i] % m;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="8-4-求1-2-…-n"><a href="#8-4-求1-2-…-n" class="headerlink" title="8.4 求1+2+…+n"></a>8.4 求1+2+…+n</h2><p>​    题目：求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>方法一：逻辑运算符短路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">boolean</span> x = n &gt; <span class="hljs-number">1</span> &amp;&amp; (n += sumNums(n - <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>方法二：try-catch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] test = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> test[n];<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">return</span> sumNums(n-<span class="hljs-number">1</span>)+n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="8-5-不用加减乘除做加法"><a href="#8-5-不用加减乘除做加法" class="headerlink" title="8.5 不用加减乘除做加法"></a>8.5 不用加减乘除做加法</h2><p>​    题目：写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<p>​    本题考察对位运算的灵活使用，即使用位运算实现加法。<br>​    设两数字的二进制形式 a,b ，其求和 s = a + b，a(i) 代表 a 的二进制第 i 位，则分为以下四种情况：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a(i)</th>
<th>b(i)</th>
<th>无进位和n(i)</th>
<th>进位c(i+1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>观察发现，无进位和 与 异或运算 规律相同，进位 和 与运算 规律相同（并需左移一位）。因此，无进位和 n 与进位 c 的计算公式如下；</p>
<script type="math/tex; mode=display">
\begin{cases} n = a \oplus b & 非进位和：异或运算 \\ c = a \& b << 1 & 进位：与运算 + 左移一位 \end{cases}</script><p>（和 s ）=（非进位和 n ）+（进位 c ）。即可将 s = a + b转化为：</p>
<script type="math/tex; mode=display">
s = a + b \Rightarrow s = n + c</script><p>由于n+c不能用加法，循环求 n 和c ，直至进位 c = 0；此时 s=n ，返回 n 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//进位运算</span><br>        <span class="hljs-keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//无进位运算</span><br>        a ^= b;<br>        b = c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="9-数学推导"><a href="#9-数学推导" class="headerlink" title="9. 数学推导"></a>9. 数学推导</h1><h2 id="9-1-数值的整数次方"><a href="#9-1-数值的整数次方" class="headerlink" title="9.1 数值的整数次方"></a>9.1 数值的整数次方</h2><p>​    题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。保证base和exponent不同时为0。</p>
<p>​    简单的方法是直接累乘，但是还有简化计算的方法，4×4要比2×2×2×2方便计算。所以可以递归计算，也可使用循环计算，递归计算的思路很好实现，但会借助递归空间。</p>
<p>​    循环计算是每次将n/2，此时记x*=x，如果是n%2==1就先计入res</p>
<ul>
<li>二分推导：$ x^n = x^{n/2} \times x^{n/2} = (x^2)^{n/2} $  ，令 $n/2$ 为整数，则需要分为奇偶两种情况（设向下取整除法符号为 “//“ ）：<ul>
<li>当 n 为偶数： $x^n = (x^2)^{n//2}$ ;</li>
<li>当 n 为奇数： $x^n = x(x^2)^{n//2}$ ，即会多出一项 x ；</li>
</ul>
</li>
<li>幂结果获取：<ul>
<li>根据二分推导，可通过循环 $x = x^2$  操作，每次把幂从 n 降至 n//2 ，直至将幂降为 0 ；<br>设 res=1 ，则初始状态 $x^n = x^n \times res$  。在循环二分时，每当 n 为奇数时，将多出的一项 x 乘入 res ，则最终可化至 $x^n = x^0 \times res = res$  ，返回 res 即可。</li>
</ul>
</li>
<li>转化为位运算：<ul>
<li>向下整除 n//2 等价于 右移一位 n&gt;&gt;1 ；<br>取余数 n%2 等价于 判断二进制最右一位值 n&amp;1 ；</li>
</ul>
</li>
</ul>
<p>​    Java 代码中 int32 变量 n∈[−2147483648,2147483647] ，因此当 n = -2147483648时执行n=−n 会因越界而赋值出错。解决方法是先将 n 存入 long 变量 b ，后面用 b操作即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">double</span> res = <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">long</span> b = n;<br>        <span class="hljs-keyword">if</span> (b &lt; <span class="hljs-number">0</span>) &#123;<br>            b = -b;<br>            x = <span class="hljs-number">1</span> / x;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((b &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;<br>                res *= x;<br>            &#125;<br>            x *= x;<br>            b&gt;&gt;=<span class="hljs-number">1</span>;<br>        &#125;<br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="9-2-打印从1到最大的n位数"><a href="#9-2-打印从1到最大的n位数" class="headerlink" title="9.2  打印从1到最大的n位数"></a>9.2  打印从1到最大的n位数</h2><p>​    题目：输入数字 <code>n</code>，按输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p>不考虑大数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] printNumbers(<span class="hljs-keyword">int</span> n) &#123;<br>    <span class="hljs-keyword">int</span> end = (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">10</span>,n)-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[end];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; end;i++)&#123;<br>        nums[i] = i+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>考虑大数：</p>
<h2 id="9-3-1～n整数中1出现的次数√"><a href="#9-3-1～n整数中1出现的次数√" class="headerlink" title="9.3 1～n整数中1出现的次数√"></a>9.3 1～n整数中1出现的次数√</h2><p>​    题目：输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
<p>注意low , high, deight, cur 更新的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>, high = n/<span class="hljs-number">10</span>, cur = n % <span class="hljs-number">10</span>; <br>    <span class="hljs-keyword">int</span> dight = <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(high != <span class="hljs-number">0</span> || cur != <span class="hljs-number">0</span> )&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>)&#123;<br>            res += high * dight;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>)&#123;<br>            res += high * dight + low +<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            res += (high + <span class="hljs-number">1</span>) * dight;<br>        &#125;<br>        low += cur * dight;<br>        cur = high % <span class="hljs-number">10</span>;<br>        high /= <span class="hljs-number">10</span>;<br>        dight *= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="9-4-数字序列中某一位的数字"><a href="#9-4-数字序列中某一位的数字" class="headerlink" title="9.4 数字序列中某一位的数字"></a>9.4 数字序列中某一位的数字</h2><p>​    题目：数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p>
<p>​    请写一个函数，求任意第n位对应的数字。</p>
<ul>
<li>限制：<code>0 &lt;= n &lt; 2^31</code></li>
</ul>
<p><font color='red'>注意</font>start和num，count为long，注意计算所在位数要考虑排除开头的0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNthDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//1.确定位数</span><br>        <span class="hljs-keyword">int</span> digit = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">long</span> start = <span class="hljs-number">1</span>, count = <span class="hljs-number">9</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; count)&#123;<br>            n -= count;<br>            start *= <span class="hljs-number">10</span>;<br>            digit++;<br>            count = <span class="hljs-number">9</span> * start * digit;<br>        &#125;<br>        <span class="hljs-comment">//2.确定所在数字</span><br>        <span class="hljs-keyword">long</span> num = start + (n-<span class="hljs-number">1</span>) / digit;<br>        <span class="hljs-comment">//3.n在数字哪一位</span><br>        <span class="hljs-keyword">return</span> Long.toString(num).charAt((n-<span class="hljs-number">1</span>) % digit) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="9-5-丑数"><a href="#9-5-丑数" class="headerlink" title="9.5 丑数"></a>9.5 丑数</h2><p>​    题目：我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p>​    设已知长度为 n 的丑数序列$ x<em>1, x_2, \cdots , x_n$  ，求第 n+1 个丑数 $x</em>{n+1}$ 。根据递推性质，丑数 $x_{n+1}$只可能是以下三种情况其中之一（索引 a, b, c为未知数）：</p>
<script type="math/tex; mode=display">
x_{n+1} = \begin{cases} x_{a} \times 2 & ,a \in [1, n] \\ x_{b} \times 3 & ,b \in [1, n] \\ x_{c} \times 5 & ,c \in [1, n] \end{cases}</script><p>由于 $x_{n+1}$ 是 <strong>最接近</strong> $x_n$ 的丑数，因此索引 <em>a</em>,<em>b</em>,<em>c</em> 需满足以下条件：</p>
<script type="math/tex; mode=display">
\begin{cases} x_{a} \times 2 > x_n \geq x_{a-1} \times 2 & ，即 x_a 为首个乘以 2 后大于 x_n 的丑数 \\ x_{b} \times 3 > x_n \geq x_{b-1} \times 3 & ，即 x_b 为首个乘以 3 后大于 x_n 的丑数 \\ x_{c} \times 5 > x_n \geq x_{c-1} \times 5 & ，即 x_c 为首个乘以 5 后大于 x_n 的丑数 \\ \end{cases}</script><p>​    若索引 a,b,ca,b,c 满足以上条件，则可使用递推公式计算下个丑数 $x_{n+1}$ ，其为三种情况中的最小值，即：</p>
<script type="math/tex; mode=display">
x_{n+1} = \min(x_{a} \times 2, x_{b} \times 3, x_{c} \times 5)</script><p>​    因此，可设置指针 a,b,c指向首个丑数（即 1 ），循环根据递推公式得到下个丑数，并每轮将对应指针执行 +1即可。</p>
<p><img src="https://pic.leetcode-cn.com/837411664f096417badf857fa51e77fd30cb1309a5637c37d24d8a4a48a42b03-Picture1.png" srcset="/img/loading.gif" alt="Picture1.png" style="zoom: 50%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> dp[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">int</span> n2 = dp[a] * <span class="hljs-number">2</span>, n3 = dp[b] * <span class="hljs-number">3</span>, n5 = dp[c] * <span class="hljs-number">5</span>;<br>            dp[i] = Math.min(n2, Math.min(n3, n5));<br>            <span class="hljs-keyword">if</span> (dp[i] == n2) &#123;<br>                a++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] == n3) &#123;<br>                b++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] == n5) &#123;<br>                c++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="9-6-圆圈中最后剩下的数字"><a href="#9-6-圆圈中最后剩下的数字" class="headerlink" title="9.6 圆圈中最后剩下的数字"></a>9.6 圆圈中最后剩下的数字</h2><p>​    题目：0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>​    例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p>题解：</p>
<p>​    我们有n个数，下标从0到n-1，然后从<code>index=0</code>开始数，每次数m个数，最后看能剩下谁。我们假设能剩下的数的<strong>下标</strong>为y，则我们把这件事表示为</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(n,m)</span></span> = y<br></code></pre></td></tr></table></figure>
<p>​    这个y到底表示了啥呢？注意，y是下标，所以就意味着你从<code>index=0</code>开始数，数y+1个数，然后就停，停谁身上谁就是结果。</p>
<p>​    行了，我们假设<code>f(n-1,m)=x</code>，然后来找一找<code>f(n,m)</code>和<code>f(n-1,m)</code>到底啥关系。</p>
<p><code>f(n-1,m)=x</code>意味着啥呢？意味着有n-1个数的时候从<code>index=0</code>开始数，数x+1个数你就找到这结果了。那我不从<code>index=0</code>开始数呢？比如我从<code>index=i</code>开始数？那很简单，你把上面的答案也往后挪i下，就得到答案了。当然了，你要是挪到末尾了你就取个余，从头接着挪。</p>
<p>于是我们来思考<code>f(n,m)</code>时考虑以下两件事：</p>
<ol>
<li>有n个数的时候，要划掉一个数，然后就剩n-1个数了呗，那划掉的这个数，<strong>下标</strong>是多少？</li>
<li>划完了这个数，往后数，数x+1个数，停在谁身上谁就是我们的答案。当然了，数的过程中你得取余</li>
</ol>
<p><strong>问题一</strong>：有n个数的时候，划掉了谁？<strong>下标</strong>是多少？</p>
<p>​    因为要从0数m个数，那最后肯定落到了下标为m-1的数身上了，但这个下标可能超过我们有的最大下标（n-1）了。所以攒满n个就归零接着数，逢n归零，所以要模n。</p>
<p>​    所以有n个数的时候，我们划掉了下标为<code>(m-1)%n</code>的数字。</p>
<p><strong>问题二</strong>：我们划完了这个数，往后数x+1下，能落到谁身上呢，它的下标是几？</p>
<p>​    你往后数x+1，它下标肯定变成了<code>(m-1)%n +x+1</code>，和第一步的想法一样，你肯定还是得取模，所以答案为<code>[(m-1)%n+x+1]%n</code>，则</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(n,m)</span>=[<span class="hljs-params">(m-<span class="hljs-number">1</span>)</span>%<span class="hljs-title">n</span>+<span class="hljs-title">x</span>+1]%<span class="hljs-title">n</span></span><br></code></pre></td></tr></table></figure>
<p>​    其中<code>x=f(n-1,m)</code></p>
<p>​    我们化简它！</p>
<p>定理一：两个正整数a，b的和，模另外一个数c，就等于它俩分别模c，模完之后加起来再模。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">(a+b)%c=((a%c)+(b%c))%c<br></code></pre></td></tr></table></figure>
<p>定理二：一个正整数a，模c，模一遍和模两遍是一样的。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">a<span class="hljs-meta">%</span>c=<span class="hljs-comment">(a%c)</span><span class="hljs-meta">%</span>c<br></code></pre></td></tr></table></figure>
<p>你稍微一琢磨就觉得，嗯，说得对。</p>
<p>所以</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">f(n,<span class="hljs-keyword">m</span>)=[(<span class="hljs-keyword">m</span>-<span class="hljs-number">1</span>)%n+<span class="hljs-keyword">x</span>+<span class="hljs-number">1</span>]%n<br>      =[(<span class="hljs-keyword">m</span>-<span class="hljs-number">1</span>)%n%n+(<span class="hljs-keyword">x</span>+<span class="hljs-number">1</span>)%n]%n<br>      =[(<span class="hljs-keyword">m</span>-<span class="hljs-number">1</span>)%n+(<span class="hljs-keyword">x</span>+<span class="hljs-number">1</span>)%n]%n<br>      =(<span class="hljs-keyword">m</span>-<span class="hljs-number">1</span>+<span class="hljs-keyword">x</span>+<span class="hljs-number">1</span>)%n<br>      =(<span class="hljs-keyword">m</span>+<span class="hljs-keyword">x</span>)%n<br></code></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> f(n,m);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> x = f(n-<span class="hljs-number">1</span>,m);<br>    <span class="hljs-keyword">return</span> (m + x) % n;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="10-字符串"><a href="#10-字符串" class="headerlink" title="10. 字符串"></a>10. 字符串</h1><h2 id="10-1-替换空格"><a href="#10-1-替换空格" class="headerlink" title="10.1 替换空格"></a>10.1 替换空格</h2><p>题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p>​    首先自己实现了一下，思路是遍历字符数组，遇到空格就替换，这样的思路比较简单，事实上在编写时也发现是不可行的，因为“%20”和空格占位是不一样的，简单的把空格替换为”%20”会覆盖掉原本空格后面的空间。</p>
<p>​    正确的思路是不必在原来的字符串上进行操作，而是建立一个新的字符串sb进行接收，判定原来的字符串str中字符为空格时使用sb.append(“%20”)方法操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JZ2</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，</span><br><span class="hljs-comment">    当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        StringBuffer str = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;We Are Happy&quot;</span>);<br><span class="hljs-comment">//        str.replace(0,1,&quot;ok&quot;);</span><br>        String str1 = replaceSpace(str);<br>        System.out.println(str1);<br>    &#125;<br><br>    <span class="hljs-comment">//解法1 使用Java自带函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(StringBuffer str)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> str.toString().replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;%20&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//解法2 使用新的字符串接收</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(StringBuffer str)</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">int</span> slength = str.length();<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;slength;i++)&#123;<br>            <span class="hljs-keyword">char</span> c = str.charAt(i);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                sb.append(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="10-2-第一个只出现一次的字符"><a href="#10-2-第一个只出现一次的字符" class="headerlink" title="10.2 第一个只出现一次的字符"></a>10.2 第一个只出现一次的字符</h2><p>​    题目：在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;<br>     HashMap&lt;Character,Boolean&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>     <span class="hljs-keyword">char</span>[] sc = s.toCharArray();<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : sc)&#123;<br>         dic.put(c,!dic.containsKey(c));<br>     &#125;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : sc)&#123;<br>         <span class="hljs-keyword">if</span> (dic.get(c))&#123;<br>             <span class="hljs-keyword">return</span> c;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="10-3-反转单词顺序"><a href="#10-3-反转单词顺序" class="headerlink" title="10.3 反转单词顺序"></a>10.3 反转单词顺序</h2><p>​    题目：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p>使用内置函数（面试不建议使用）</p>
<p><img src="https://pic.leetcode-cn.com/9ef4a9ea565bf1c2d9209ca94881a77288f90f222476cfd44c418fa3f2d2d7c1-Picture0.png" srcset="/img/loading.gif" alt="Picture0.png" style="zoom: 33%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        String[] strs = s.trim().split(<span class="hljs-string">&quot; &quot;</span>);<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = strs.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (strs[i].equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>           <span class="hljs-comment">//若两单词间有x&gt;1个空格，则在单词列表strs中，此两单词间会多出x - 1个“空单词”(即 &quot;&quot; )</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            sb.append(strs[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString().trim();<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>字符拼接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords2</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        s = s.trim();<br>        <span class="hljs-keyword">int</span> i = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> j = i;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(j) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                i--;<br>            &#125;<br>            sb.append(s.substring(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>)<br>                i--;<br>            j = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="10-4-反转单词顺序"><a href="#10-4-反转单词顺序" class="headerlink" title="10.4 反转单词顺序"></a>10.4 反转单词顺序</h2><p>​    题目：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p>内置函数（不推荐）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s.substring(n)+s.substring(<span class="hljs-number">0</span>,n);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="10-5-把字符串转换成整数"><a href="#10-5-把字符串转换成整数" class="headerlink" title="10.5 把字符串转换成整数"></a>10.5 把字符串转换成整数</h2><p>​    题目：写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span>[] c = str.trim().toCharArray();<br>    <span class="hljs-keyword">if</span> (c.length == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, bndry = Integer.MAX_VALUE / <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (c[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;sign = -<span class="hljs-number">1</span>;&#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;+&#x27;</span>)&#123;i = <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; c.length; j++)&#123;<br>        <span class="hljs-keyword">if</span> (c[j] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c[j] &gt; <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">break</span>;&#125;<br>        <span class="hljs-keyword">if</span> (res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; <span class="hljs-string">&#x27;7&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> sign == <span class="hljs-number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;<br>        &#125;<br>        res = res * <span class="hljs-number">10</span> + (c[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sign * res;<br>&#125;<br></code></pre></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%89%91%E6%8C%87offer/">剑指offer</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/02/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">动态规划</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/02/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">
                        <span class="hidden-mobile">二叉树遍历方法总结</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
