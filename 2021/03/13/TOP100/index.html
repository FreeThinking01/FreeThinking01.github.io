

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="leetcodeTOP100">
  
  <meta name="author" content="醉心">
  <meta name="keywords" content="">
  
  <title>TOP100 - FreeThinking&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="FreeThinking's blog" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>FreeThinking's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/atom.xml">
                <i class="iconfont icon-rss-fill"></i>
                RSS
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="TOP100">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-03-13 18:32" pubdate>
        2021年3月13日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      23.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      357
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">TOP100</h1>
            
            <div class="markdown-body">
              <h1 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h1><h2 id="1-1-两数之和"><a href="#1-1-两数之和" class="headerlink" title="1.1 两数之和"></a>1.1 两数之和</h2><p>与剑指offer和为s的两个数字不同的是给定的整型数组不是有序的，这里遍历每个数的同时查找$target-nums[i]$是否存在，使用hashmap存储结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer,Integer&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(target - nums[i]))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,map.get(target - nums[i])&#125;;<br>        &#125;<br>        map.put(nums[i],i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-2-多数元素"><a href="#1-2-多数元素" class="headerlink" title="1.2 多数元素"></a>1.2 多数元素</h2><p>同剑指offer 数组中出现次数超过一半的数字</p>
<p>摩尔投票法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>	<span class="hljs-comment">//x众数,votes票数</span><br>    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, votes = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)&#123;<br>        <span class="hljs-keyword">if</span> (votes == <span class="hljs-number">0</span>)&#123;x = num;&#125;<br>        votes += num == x ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-3-移动零"><a href="#1-3-移动零" class="headerlink" title="1.3 移动零"></a>1.3 移动零</h2><p>将非0元素填充在首部，剩余元素用0填充</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] != <span class="hljs-number">0</span>)&#123;<br>            nums[j++] = nums[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j &lt; n)&#123;<br>        nums[j++] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-4-找到所有数组中消失的数字"><a href="#1-4-找到所有数组中消失的数字" class="headerlink" title="1.4 找到所有数组中消失的数字"></a>1.4 找到所有数组中消失的数字</h2><p>我们可以用一个哈希表记录数组 $\textit{nums}$ 中的数字，由于数字范围均在$ [1,n]$ 中，记录数字后我们再利用哈希表检查 $[1,n] $中的每一个数是否出现，从而找到缺失的数字。</p>
<p>由于数字范围均在 $[1,n]$ 中，我们也可以用一个长度为 n 的数组来代替哈希表。这一做法的空间复杂度是 O(n) 的。我们的目标是优化空间复杂度到 O(1)。</p>
<p>注意到 $\textit{nums} $的长度恰好也为 n，能否让 $\textit{nums}$ 充当哈希表呢？</p>
<p>由于 $\textit{nums}$ 的数字范围均在$ [1,n]$ 中，我们可以利用这一范围之外的数字，来表达「是否存在」的含义。</p>
<p>具体来说，遍历 $\textit{nums}$，每遇到一个数 x，就让 $\textit{nums}[x-1]$ 增加 n。由于 $\textit{nums}$ 中所有数均在 $[1,n]$ 中，增加以后，这些数必然大于 n。最后我们遍历 $\textit{nums}$，若 $\textit{nums}[i]$ 未大于 n，就说明没有遇到过数 i+1。这样我们就找到了缺失的数字。</p>
<p>注意，当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 n取模来还原出它本来的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        <span class="hljs-keyword">int</span> x = (num - <span class="hljs-number">1</span>) % n;<br>        nums[x] += n;<br>    &#125;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] &lt;= n)&#123;<br>            res.add(i + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-5-盛最多水的容器"><a href="#1-5-盛最多水的容器" class="headerlink" title="1.5 盛最多水的容器"></a>1.5 盛最多水的容器</h2><p>暴力解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>, n = height.length;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            res = Math.max(res,(j - i) * Math.min(height[i],height[j]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>双指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = height.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        res = Math.max(res,(j - i) * Math.min(height[i],height[j]));<br>        <span class="hljs-keyword">if</span>(height[i] &lt; height[j])&#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>移动数字较小指针的正确性证明：</p>
<blockquote>
<p>双指针代表了什么？</p>
</blockquote>
<p>双指针代表的是 可以作为容器边界的所有位置的范围。在一开始，双指针指向数组的左右边界，表示 数组中所有的位置都可以作为容器的边界，因为我们还没有进行过任何尝试。在这之后，我们每次将 对应的数字较小的那个指针 往 另一个指针 的方向移动一个位置，就表示我们认为 这个指针不可能再作为容器的边界了。</p>
<blockquote>
<p>为什么对应的数字较小的那个指针不可能再作为容器的边界了？</p>
</blockquote>
<p>在上面的分析部分，我们对这个问题有了一点初步的想法。这里我们定量地进行证明。</p>
<p>考虑第一步，假设当前左指针和右指针指向的数分别为 x 和 y，不失一般性，我们假设 $x \leq y$。同时，两个指针之间的距离为 t。那么，它们组成的容器的容量为：</p>
<script type="math/tex; mode=display">
\min(x, y) * t = x * t</script><p>我们可以断定，如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 $x * t$了。注意这里右指针只能向左移动，因为 我们考虑的是第一步，也就是 指针还指向数组的左右边界的时候。</p>
<p>我们任意向左移动右指针，指向的数为$ y_1$ ，两个指针之间的距离为 $t_1$ ，那么显然有 $t_1 &lt; t$，并且 $\min(x, y_1) \leq \min(x, y)$ )：</p>
<ul>
<li><p>如果 $y_1 \leq y$，那么 $\min(x, y_1) \leq \min(x, y)$；</p>
</li>
<li><p>如果 $y_1 &gt; y$ 那么 $\min(x, y_1) = x = \min(x, y)$。</p>
</li>
</ul>
<p>因此有：</p>
<script type="math/tex; mode=display">
\min(x, y_t) * t_1 < \min(x, y) * t</script><p>即无论我们怎么移动右指针，得到的容器的容量都小于移动前容器的容量。也就是说，这个左指针对应的数不会作为容器的边界了，那么我们就可以丢弃这个位置，将左指针向右移动一个位置，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。</p>
<p>这样以来，我们将问题的规模减小了 11，被我们丢弃的那个位置就相当于消失了。此时的左右指针，就指向了一个新的、规模减少了的问题的数组的左右边界，因此，我们可以继续像之前 考虑第一步 那样考虑这个问题：</p>
<ul>
<li><p>求出当前双指针对应的容器的容量；</p>
</li>
<li><p>对应数字较小的那个指针以后不可能作为容器的边界了，将其丢弃，并移动对应的指针。</p>
</li>
</ul>
<blockquote>
<p>最后的答案是什么？</p>
</blockquote>
<p>答案就是我们每次以双指针为左右边界（也就是「数组」的左右边界）计算出的容量中的最大值。</p>
<h2 id="1-6-三数之和"><a href="#1-6-三数之和" class="headerlink" title="1.6 三数之和"></a>1.6 三数之和</h2><p>排序+双指针</p>
<p>暴力解法$O(n^3)$，先排序，固定一个数字，剩下两个数字用剑指offer和为s的两个数字的双指针解法移动，注意排除重复元素并添加优化细节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>     Arrays.sort(nums);<br>     <span class="hljs-keyword">int</span> n = nums.length;<br>     List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; n - <span class="hljs-number">2</span>; m++)&#123;<br>         <span class="hljs-comment">//因为已经排序，最小数字&gt;0则无须继续遍历</span><br>         <span class="hljs-keyword">if</span>(nums[m] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>         <span class="hljs-comment">//如果当前固定数字和前一个相同，排除重复答案</span><br>         <span class="hljs-keyword">if</span>(m &gt; <span class="hljs-number">0</span> &amp;&amp; nums[m] == nums[m - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>         <span class="hljs-keyword">int</span> i = m + <span class="hljs-number">1</span>, j = n - <span class="hljs-number">1</span>;<br>         <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>             <span class="hljs-keyword">int</span> s = nums[m] + nums[i] + nums[j]; <br>             <span class="hljs-keyword">if</span>(s &gt; <span class="hljs-number">0</span>)&#123;<br>                 <span class="hljs-comment">//j不满足条件，将nums[j]相等元素排除</span><br>                 <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);<br>             &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s &lt; <span class="hljs-number">0</span>)&#123;<br>                 <span class="hljs-comment">//i不满足条件，将nums[i]相等元素排除</span><br>                 <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);<br>             &#125;<span class="hljs-keyword">else</span>&#123;<br>                 res.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[m], nums[i], nums[j])));<br>                 <span class="hljs-comment">//排除重复答案</span><br>                 <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);<br>                 <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);<br>             &#125;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-7-下一个排列"><a href="#1-7-下一个排列" class="headerlink" title="1.7 下一个排列"></a>1.7 下一个排列</h2><ul>
<li>从后到前找升序对$nums(j - 1),nums(j)$</li>
<li>将$nums[j - 1]$和后面大于$nums[j - 1]$的最小数交换，并将$nums[j]$后面的数字排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--)&#123;<br>        <span class="hljs-keyword">if</span>(nums[j - <span class="hljs-number">1</span>] &lt; nums[j])&#123;<br>            Arrays.sort(nums,j, n);<br>            <span class="hljs-comment">//找排序后第一个比nums[j - 1]大的数(尽量小的大数)</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = j; k &lt; n; k++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[k] &gt; nums[j - <span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-keyword">int</span> tmp = nums[j - <span class="hljs-number">1</span>];<br>                    nums[j - <span class="hljs-number">1</span>] = nums[k];<br>                    nums[] = tmp;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125; <br>    &#125;<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-8-搜索旋转排序数组"><a href="#1-8-搜索旋转排序数组" class="headerlink" title="1.8 搜索旋转排序数组"></a>1.8 搜索旋转排序数组</h2><p>有序数组使用二分法解决</p>
<p>​        可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。</p>
<p>​        这启示我们可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= j)&#123;<br>        mid = i + (j - i) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-comment">//左侧顺序</span><br>        <span class="hljs-keyword">if</span>(nums[mid] &gt;= nums[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-comment">//目标在左侧</span><br>            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;= target &amp;&amp; target &lt;= nums[mid])&#123;<br>                j = mid - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                i = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//右侧顺序</span><br>            <span class="hljs-comment">//目标在右侧</span><br>            <span class="hljs-keyword">if</span>(nums[j] &gt;= target &amp;&amp; target &gt;= nums[mid])&#123;<br>                i = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                j = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-9-旋转图像"><a href="#1-9-旋转图像" class="headerlink" title="1.9 旋转图像"></a>1.9 旋转图像</h2><p>对于矩阵中第 $i$ 行的第 $j$ 个元素，在旋转后，它出现在倒数第 $i$ 列的第 $j$ 个位置。</p>
<p>我们得到：</p>
<script type="math/tex; mode=display">
\left\{
\begin{aligned}
&temp=matrix[n−col−1][row] \\
&matrix[n−col−1][row]=matrix[n−row−1][n−col−1] \\
&matrix[n−row−1][n−col−1]=matrix[col][n−row−1] \\
&matrix[col][n−row−1]=matrix[row][col]
\end{aligned}
\right.</script><p>当我们知道了如何原地旋转矩阵之后，还有一个重要的问题在于：我们应该枚举哪些位置$ (\textit{row}, \textit{col})$\ 进行上述的原地交换操作呢？由于每一次原地交换四个位置，因此：</p>
<ul>
<li>当 n 为偶数时，我们需要枚举 $n^2 / 4 = (n/2) \times (n/2)$个位置，可以将该图形分为四块，以 $4×4 $的矩阵为例：</li>
<li><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/旋转图像1.png" srcset="/img/loading.gif" alt="旋转图像1" style="zoom: 33%;" /></li>
</ul>
<p>保证了不重复、不遗漏；</p>
<p>当 n为奇数时，由于中心的位置经过旋转后位置不变，我们需要枚举$ (n^2-1) / 4 = ((n-1)/2) \times ((n+1)/2)$个位置，需要换一种划分的方式，以 $5×5$ 的矩阵为例：</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/旋转图像2.png" srcset="/img/loading.gif" alt="旋转图像2" style="zoom: 33%;" /></p>
<p>同样保证了不重复、不遗漏，矩阵正中央的点无需旋转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = matrix.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; ++j) &#123;<br>            <span class="hljs-keyword">int</span> temp = matrix[i][j];<br>            matrix[i][j] = matrix[n - j - <span class="hljs-number">1</span>][i];<br>            matrix[n - j - <span class="hljs-number">1</span>][i] = matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>];<br>            matrix[n - i - <span class="hljs-number">1</span>][n - j - <span class="hljs-number">1</span>] = matrix[j][n - i - <span class="hljs-number">1</span>];<br>            matrix[j][n - i - <span class="hljs-number">1</span>] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-10-合并区间"><a href="#1-10-合并区间" class="headerlink" title="1.10 合并区间"></a>1.10 合并区间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br>    <span class="hljs-comment">// 按 start 升序排序</span><br>    Arrays.sort(intervals, (<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];<br>    &#125;);<br>    List&lt;<span class="hljs-keyword">int</span>[]&gt; merged = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">int</span>[]&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intervals.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> L = intervals[i][<span class="hljs-number">0</span>], R = intervals[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (merged.size() == <span class="hljs-number">0</span> || merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] &lt; L) &#123;<br>            <span class="hljs-comment">//结果集为空或与当前区间没有交集</span><br>            merged.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;L, R&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//合并区间</span><br>            merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>] = Math.max(merged.get(merged.size() - <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>], R);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> merged.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[merged.size()][]);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-11-颜色分类"><a href="#1-11-颜色分类" class="headerlink" title="1.11 颜色分类"></a>1.11 颜色分类</h2><p>这是一道排序题，题目要求是使用常数空间的一趟扫描算法。</p>
<p>使用常数空间意味着原地排序，通过比较和交换进行数据排序，即空间复杂度O(1)，时间复杂度O(n)。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>排序方法</th>
<th>时间复杂度(平均)</th>
<th>时间复杂度(最坏)</th>
<th>时间复杂度(最好)</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>复杂性</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
<td>简单</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlog2n)</td>
<td>O(n2)</td>
<td>O(n1.3)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>直接选择排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>简单</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(1)</td>
<td>不稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
<td>简单</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog2n)</td>
<td>O(n2)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>不稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(n)</td>
<td>稳定</td>
<td>较复杂</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(n+r)</td>
<td>稳定</td>
<td>较复杂</td>
</tr>
</tbody>
</table>
</div>
<p>正常的排序算法没有满足的，此题的特殊条件是只有三个元素。</p>
<p>可以借鉴冒泡排序，冒泡排序外层循环n - 1躺，每趟将一个元素放到最终位置，这里一共三种元素，用两次遍历每次将一种元素归位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length, k = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>            nums[i] = nums[k];<br>            nums[k++] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">1</span>)&#123;<br>            nums[i] = nums[k];<br>            nums[k++] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-12-除自身以外数组的乘积"><a href="#1-12-除自身以外数组的乘积" class="headerlink" title="1.12 除自身以外数组的乘积"></a>1.12 除自身以外数组的乘积</h2><p>同剑指offer构建乘积数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] productExceptSelf(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];&#125;<br>    <span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>        b[i] = b[i-<span class="hljs-number">1</span>] * nums[i-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-comment">//tmp记录右边部分乘积</span><br>        tmp *= nums[i+<span class="hljs-number">1</span>];<br>        b[i] *= tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-13-和为k的子数组"><a href="#1-13-和为k的子数组" class="headerlink" title="1.13 和为k的子数组"></a>1.13 和为k的子数组</h2><p>连续子数组首先考虑滑动窗口，但数组中的值允许为负数，所以滑动窗口不可行。</p>
<p>使用前缀和的方法求解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n =nums.length;<br>    <span class="hljs-comment">//map&lt;前缀和，出现次数&gt;</span><br>    HashMap&lt;Integer,Integer&gt; preSum = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">//base case</span><br>    preSum.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, sum0_i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        sum0_i += nums[i];<br>        <span class="hljs-keyword">int</span> sum0_j = sum0_i - k;<br>        <span class="hljs-keyword">if</span>(preSum.containsKey(sum0_j))&#123;<br>            ans += preSum.get(sum0_j);<br>        &#125;<br>        preSum.put(sum0_i,preSum.getOrDefault(sum0_i,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-14-最短无序连续子数组"><a href="#1-14-最短无序连续子数组" class="headerlink" title="1.14 最短无序连续子数组"></a>1.14 最短无序连续子数组</h2><p>最简单思路是将数组排序后的结果和原数组比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] nums2 = Arrays.copyOf(nums, nums.length);<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">int</span> left = -<span class="hljs-number">1</span>, right = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i] != nums2[i])&#123;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>                left = i;<br>                flag = !flag;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right = i;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right - left &gt; <span class="hljs-number">0</span> ? right - left + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-15-无重复字符的最长子串"><a href="#1-15-无重复字符的最长子串" class="headerlink" title="1.15 无重复字符的最长子串"></a>1.15 无重复字符的最长子串</h2><p>同剑指offer最长不含重复字符的子字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    HashMap&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(right);<br>        right++;<br>        <span class="hljs-comment">//更新数据</span><br>        map.put(c,map.getOrDefault(c,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//左侧收缩</span><br>        <span class="hljs-keyword">while</span>(map.get(c) &gt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">char</span> d = s.charAt(left);<br>            left++;<br>            <span class="hljs-comment">//更新数据</span><br>            map.put(d,map.get(d) - <span class="hljs-number">1</span>);<br>        &#125;<br>        res = Math.max(res,right - left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-16-寻找重复数"><a href="#1-16-寻找重复数" class="headerlink" title="1.16 寻找重复数"></a>1.16 寻找重复数</h2><p>同剑指offer数组中重复的数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.length;i++)&#123;<br>        <span class="hljs-keyword">while</span> (nums[i]!=i)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==nums[nums[i]])&#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>            temp=nums[i];<br>            nums[i]=nums[temp];<br>            nums[temp]=temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-17-搜索二维矩阵Ⅱ"><a href="#1-17-搜索二维矩阵Ⅱ" class="headerlink" title="1.17 搜索二维矩阵Ⅱ"></a>1.17 搜索二维矩阵Ⅱ</h2><p>初始化一个指向矩阵左下角的 (row，col) 指针。然后，直到找到目标并返回 true（或者指针指向矩阵维度之外的 (row，col)为止，我们执行以下操作：如果当前指向的值大于目标值，则可以 “向上” 移动一行。 否则，如果当前指向的值小于目标值，则可以移动一列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = matrix.length - <span class="hljs-number">1</span>, col = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(row &gt;= <span class="hljs-number">0</span> &amp;&amp; col &lt;= matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(matrix[row][col] &lt; target)&#123;<br>            col++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[row][col] &gt; target)&#123;<br>            row--;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-18-找到字符串中所有字母异位词"><a href="#1-18-找到字符串中所有字母异位词" class="headerlink" title="1.18 找到字符串中所有字母异位词"></a>1.18 找到字符串中所有字母异位词</h2><p>开始代码是这样，但遇到长的测试用例无法通过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    HashMap&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap();<br>    HashMap&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : p.toCharArray())&#123;<br>        need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>    LinkedList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(right);<br>        right++;<br>        <span class="hljs-keyword">if</span>(need.containsKey(c))&#123;<br>            window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(window.get(c) == need.get(c))&#123;<span class="hljs-comment">//换成equals</span><br>                valid++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right - left &gt;= p.length())&#123;<br>            <span class="hljs-keyword">if</span>(valid == need.size())&#123;<br>                res.add(left);<br>            &#125;<br>            <span class="hljs-keyword">char</span> d = s.charAt(left);<br>            left++;<br>            <span class="hljs-keyword">if</span>(need.containsKey(d))&#123;<br>                <span class="hljs-keyword">if</span> (window.get(d) == need.get(d))<span class="hljs-comment">//换成equals</span><br>                    valid--;<br>                window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Integer 在大于127 的时候 不从常量池里拿，是个对象，比较的也就不是数值，所以换成equals</p>
<h2 id="1-19-寻找两个正序数组的中位数"><a href="#1-19-寻找两个正序数组的中位数" class="headerlink" title="1.19 寻找两个正序数组的中位数"></a>1.19 寻找两个正序数组的中位数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length1 = nums1.length, length2 = nums2.length;<br>        <span class="hljs-keyword">int</span> totalLength = length1 + length2;<br>        <span class="hljs-keyword">if</span> (totalLength % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">int</span> midIndex = totalLength / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">double</span> median = getKthElement(nums1, nums2, midIndex + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> median;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> midIndex1 = totalLength / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, midIndex2 = totalLength / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">double</span> median = (getKthElement(nums1, nums2, midIndex1 + <span class="hljs-number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;<br>            <span class="hljs-keyword">return</span> median;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getKthElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> k)</span> </span>&#123;	<br>        <span class="hljs-keyword">int</span> length1 = nums1.length, length2 = nums2.length;<br>        <span class="hljs-keyword">int</span> index1 = <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> kthElement = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-comment">// 边界情况</span><br>            <span class="hljs-keyword">if</span> (index1 == length1) &#123;<br>                <span class="hljs-keyword">return</span> nums2[index2 + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (index2 == length2) &#123;<br>                <span class="hljs-keyword">return</span> nums1[index1 + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> Math.min(nums1[index1], nums2[index2]);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 正常情况</span><br>            <span class="hljs-keyword">int</span> half = k / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> newIndex1 = Math.min(index1 + half, length1) - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> newIndex2 = Math.min(index2 + half, length2) - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];<br>            <span class="hljs-keyword">if</span> (pivot1 &lt;= pivot2) &#123;<br>                k -= (newIndex1 - index1 + <span class="hljs-number">1</span>);<br>                index1 = newIndex1 + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                k -= (newIndex2 - index2 + <span class="hljs-number">1</span>);<br>                index2 = newIndex2 + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-20-最小覆盖子串"><a href="#1-20-最小覆盖子串" class="headerlink" title="1.20 最小覆盖子串"></a>1.20 最小覆盖子串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>    HashMap&lt;Character, Integer&gt; window = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    HashMap&lt;Character, Integer&gt; need = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : t.toCharArray())&#123;<br>        need.put(c, need.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, len = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(right);<br>        right++;<br>        <span class="hljs-keyword">if</span>(need.containsKey(c))&#123;<br>            window.put(c, window.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(window.get(c).equals(need.get(c)))&#123;<br>                valid++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(valid == need.size())&#123;<br>            <span class="hljs-keyword">if</span>(right - left &lt; len)&#123;<br>                start = left;<br>                len = right - left;<br>            &#125;<br>            <span class="hljs-keyword">char</span> d = s.charAt(left);<br>            left++;<br>            <span class="hljs-keyword">if</span>(need.containsKey(d))&#123;<br>                <span class="hljs-keyword">if</span>(window.get(d).equals(need.get(d)))&#123;<br>                    valid--;<br>                &#125;<br>                window.put(d, window.get(d) - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len == Integer.MAX_VALUE ? <span class="hljs-string">&quot;&quot;</span> : s.substring(start, start + len);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意窗口的移动一直是[left,right)左闭右开区间，所以right - left计算的也是子串实际长度，因为java的substring(beginindex,endindex)不包含endindex，所以可以直接代入。</p>
<h2 id="1-21-滑动窗口最大值"><a href="#1-21-滑动窗口最大值" class="headerlink" title="1.21 滑动窗口最大值"></a>1.21 滑动窗口最大值</h2><p>同剑指offer滑动窗口最大值。</p>
<p>首先想使用滑动窗口算法，滑动窗口可以在区间发生变化时，<strong>通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度</strong>。但是在这里滑动窗口无法复用结果进行剪枝。</p>
<p>我们可以将当前窗口最大值和新加入的值进行比较，但在删除最左侧元素时会出现两种情况：</p>
<ul>
<li>窗口最左侧元素不是窗口最大值，可以放心删除</li>
<li>窗口最左侧元素是窗口最大值，根据该窗口最大值是否唯一又两种情况：<ul>
<li>不唯一，放心删除</li>
<li>唯一，删除后重新遍历窗口获得最大值，次操作复杂度O(k)</li>
</ul>
</li>
</ul>
<p>所以可以强行使用滑动窗口，但操作不仅复杂而且时间复杂度为O(nk)</p>
<p>使用双端队列解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//形成初始窗口</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>        <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[i] &gt; deque.peekLast())&#123;<br>            deque.removeLast();<br>        &#125;<br>        deque.add(nums[i]);<br>    &#125;<br>    res[index++] = deque.peekFirst();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-comment">//若上个窗口元素==队列最大值，删除</span><br>        <span class="hljs-keyword">if</span>(deque.peekFirst() == nums[i - k])&#123;<br>            deque.removeFirst();<br>        &#125;<br>        <span class="hljs-comment">//队列添加元素</span><br>        <span class="hljs-keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[i] &gt; deque.peekLast())&#123;<br>            deque.removeLast();<br>        &#125;<br>        deque.addLast(nums[i]);<br>        res[index++] = deque.peekFirst();<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-22-最长连续子序列"><a href="#1-22-最长连续子序列" class="headerlink" title="1.22 最长连续子序列"></a>1.22 最长连续子序列</h2><p>​    我们考虑枚举数组中的每个数 x，考虑以其为起点，不断尝试匹配 $x+1, x+2, \cdots$是否存在，假设最长匹配到了 x+yx+y，那么以 xx 为起点的最长连续序列即为 $x, x+1, x+2, \cdots, x+y$，其长度为 y+1，我们不断枚举并更新答案即可。</p>
<p>​    对于匹配的过程，暴力的方法是 O(n) 遍历数组去看是否存在这个数，但其实更高效的方法是用一个哈希表存储数组中的数，这样查看一个数是否存在即能优化至 O(1) 的时间复杂度。</p>
<p>​    仅仅是这样我们的算法时间复杂度最坏情况下还是会达到 $O(n^2)$（即外层需要枚举 O(n) 个数，内层需要暴力匹配 O(n) 次），无法满足题目的要求。但仔细分析这个过程，我们会发现其中执行了很多不必要的枚举，如果已知有一个 $x, x+1, x+2, \cdots, x+y$ 的连续序列，而我们却重新从$ x+1$，$x+2$ 或者是 x+y 处开始尝试匹配，那么得到的结果肯定不会优于枚举 x 为起点的答案，因此我们在外层循环的时候碰到这种情况跳过即可。</p>
<p>​    那么怎么判断是否跳过呢？由于我们要枚举的数 x 一定是在数组中不存在前驱数 x−1 的，不然按照上面的分析我们会从 x-1开始尝试匹配，因此我们每次在哈希表中检查是否存在 x−1 即能判断是否需要跳过了。</p>
<p>​    增加了判断跳过的逻辑之后，时间复杂度是多少呢？外层循环需要 O(n) 的时间复杂度，只有当一个数是连续序列的第一个数的情况下才会进入内层循环，然后在内层循环中匹配连续序列中的数，因此<strong>数组中的每个数只会进入内层循环一次</strong>。根据上述分析可知，总时间复杂度为 O(n)，符合题目要求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> longestSeq = <span class="hljs-number">0</span>;<br>    HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        set.add(num);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : set)&#123;<br>        <span class="hljs-keyword">int</span> curSeq = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> curNum = num;<br>        <span class="hljs-keyword">if</span>(!set.contains(curNum - <span class="hljs-number">1</span>))&#123;<br>            curSeq = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(set.contains(curNum + <span class="hljs-number">1</span>))&#123;<br>                curNum++;<br>                curSeq++;<br>            &#125;<br>        &#125;<br>        longestSeq = Math.max(longestSeq,curSeq);<br>    &#125;<br>    <span class="hljs-keyword">return</span> longestSeq;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h1><p>链表的解题基本就是递归和迭代，包括快慢指针的技巧，还可以和排序算法结合。</p>
<h2 id="2-1-两数相加"><a href="#2-1-两数相加" class="headerlink" title="2.1 两数相加"></a>2.1 两数相加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br><br>        <span class="hljs-comment">//使用l1链表接收返回结果</span><br>        ListNode p1 = l1;<br>        ListNode p2 = l2;<br>        <span class="hljs-keyword">int</span> sums = p1.val + p2.val;<br>        <span class="hljs-comment">//num代表进位数字</span><br>        <span class="hljs-keyword">int</span> num = sums / <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">//得到结果时记得对10取余</span><br>        p1.val = sums % <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span>(p1.next != <span class="hljs-keyword">null</span> || p2.next!= <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//除非p1和p2同时为空，否则将快空链表填0</span><br>            <span class="hljs-keyword">if</span>(p1.next == <span class="hljs-keyword">null</span>)&#123;<br>                p1.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p2.next == <span class="hljs-keyword">null</span>)&#123;<br>                p2.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>            &#125;<br>            sums = p1.next.val + p2.next.val + num;<br>            <span class="hljs-comment">//num使用后清除，否则影响判断最后是否进位</span><br>            num = <span class="hljs-number">0</span>;<br>            p1.next.val = (sums % <span class="hljs-number">10</span>);<br>            num = sums / <span class="hljs-number">10</span>;<br>            p1 = p1.next;<br>            p2 = p2.next;<br>        &#125;<br>        <span class="hljs-comment">//如果当前还剩余进位，p1再填充一位</span><br>        <span class="hljs-keyword">if</span>(num != <span class="hljs-number">0</span>)&#123;<br>            p1.next = <span class="hljs-keyword">new</span> ListNode(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>要注意的点：</p>
<ol>
<li>链表长度不一致</li>
<li>计算进位</li>
<li>最后还有进位需要在l1上顺延节点</li>
</ol>
<h2 id="2-2-删除链表的倒数第N个节点"><a href="#2-2-删除链表的倒数第N个节点" class="headerlink" title="2.2 删除链表的倒数第N个节点"></a>2.2 删除链表的倒数第N个节点</h2><p>如果不为head设前驱节点pre的话，当节点数为1时是无法进行删除的，所以手动添加前驱节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//添加前驱节点</span><br>        ListNode pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        pre.next = head;<br>        <span class="hljs-comment">//初始化移动节点，双指针移动,p2先走,p1后走,p为p1的前驱，方便删除</span><br>        ListNode p1 = head,p2 = head,p = pre;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//p2先走n步</span><br>            p2 = p2.next;<br>            n--;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p2 != <span class="hljs-keyword">null</span>)&#123;<br>            p2 = p2.next;<br>            p = p1;<br>            p1 = p1.next;<br>        &#125;<br>        <span class="hljs-comment">//删除p1</span><br>        p.next = p1.next;<br>        <span class="hljs-keyword">return</span> pre.next;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-3-合并两个有序链表"><a href="#2-3-合并两个有序链表" class="headerlink" title="2.3 合并两个有序链表"></a>2.3 合并两个有序链表</h2><p>传统解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-comment">//合并链表头节点</span><br>        ListNode head = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//特殊情况</span><br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-comment">//选出头节点</span><br>        <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>            head = l1;<br>            l1 = l1.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            head = l2;<br>            l2 = l2.next;<br>        &#125;<br>        <span class="hljs-comment">//迭代比较合并</span><br>        ListNode l = head;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>                l.next = l2;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>                l.next = l1;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>                l.next = l1;<br>                l = l.next;<br>                l1 = l1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l.next = l2;<br>                l = l.next;<br>                l2 = l2.next;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>递归解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回合并后的头节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        ListNode l = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>            l = l1;<br>            l1 = l1.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = l2;<br>            l2 = l2.next;<br>        &#125;<br>        l.next = mergeTwoLists(l1,l2);<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-4-环形链表"><a href="#2-4-环形链表" class="headerlink" title="2.4 环形链表"></a>2.4 环形链表</h2><p>快慢指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode fast = head;<br>        ListNode slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span>(fast == slow)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-5-环形链表Ⅱ"><a href="#2-5-环形链表Ⅱ" class="headerlink" title="2.5 环形链表Ⅱ"></a>2.5 环形链表Ⅱ</h2><p>​        仍然使用快慢指针，第一次相遇时，设slow走k步，fast走2k步，但是仍然相遇了，说明fast多走的k步正是环的长度。<br>​        假设相遇点距离环起点m步，从head到相遇点为k-m，此时环内继续走k-m也为相遇点，令slow指向head，slow和fast同步走，再次相遇为环起点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode fast = head, slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span>(fast == slow)&#123;<br>                <span class="hljs-comment">//确定有环，slow重走</span><br>                slow = head;<br>                <span class="hljs-keyword">while</span>(fast != slow)&#123;<br>                    fast = fast.next;<br>                    slow = slow.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> slow;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-6-排序链表"><a href="#2-6-排序链表" class="headerlink" title="2.6 排序链表"></a>2.6 排序链表</h2><p>进阶要求是时间复杂度O(nlogn)，空间复杂度O(1)</p>
<p>使用归并排序，归并排序的数组排序迭代空间复杂度为O(n)，递归为O(n)</p>
<p>链表排序迭代空间复杂度O(1)，递归为O(n)</p>
<p>递归解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">//分</span><br>        <span class="hljs-comment">//找到中点</span><br>        ListNode fast = head, slow = head;<br>        <span class="hljs-comment">//slow的前驱结点，用于断链</span><br>        ListNode preSlow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<br>            fast = fast.next.next;<br>            preSlow = slow;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fast != <span class="hljs-keyword">null</span>)&#123;<br>            preSlow = slow;<br>            slow = slow.next;<br>        &#125;<br>        preSlow.next = <span class="hljs-keyword">null</span>;<br>        ListNode left = sortList(head);<br>        ListNode right = sortList(slow);<br><br>        <span class="hljs-comment">//治</span><br>        <span class="hljs-comment">//两个有序链表合并，建立前驱结点排序</span><br>        ListNode node = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode res = node;<br>        <span class="hljs-keyword">while</span>(left != <span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(left.val &lt;= right.val)&#123;<br>                node.next = left;<br>                left = left.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                node.next = right;<br>                right = right.next;<br>            &#125;<br>            node = node.next;<br>        &#125;<br>        node.next = left == <span class="hljs-keyword">null</span> ? right : left;<br>        <span class="hljs-keyword">return</span> res.next;<br>        <br>    &#125;<br></code></pre></td></tr></table></figure>
<p>迭代解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-comment">//初始化变量</span><br>        ListNode h,h1,h2,res,pre;<br>        h = head;<br>        res = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        res.next = head;<br>        <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>,step = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(h != <span class="hljs-keyword">null</span>)&#123;<br>            length++;<br>            h = h.next;<br>        &#125;<br><br>        <span class="hljs-comment">//迭代合并</span><br>        <span class="hljs-keyword">while</span> (step &lt; length) &#123;<br>            pre = res;<br>            h = res.next;<br>            <span class="hljs-keyword">while</span>(h != <span class="hljs-keyword">null</span>)&#123;<br>                h1 = h;<br>                <span class="hljs-keyword">int</span> i = step;<br>                <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; h != <span class="hljs-keyword">null</span>)&#123;<br>                    h = h.next;<br>                    i--;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//此时不足one step</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                h2 = h;<br>                i = step;<br>                <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; h != <span class="hljs-keyword">null</span>)&#123;<br>                    h = h.next;<br>                    i--;<br>                &#125;<br>                <span class="hljs-comment">//合并两组中前一组长度step，后一组step-i</span><br>                <span class="hljs-keyword">int</span> len1 = step,len2 = step - i;<br>                <span class="hljs-comment">//开始合并,有序链表合并</span><br>                <span class="hljs-keyword">while</span>(len1 &gt; <span class="hljs-number">0</span> &amp;&amp; len2 &gt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(h1.val &lt;= h2.val)&#123;<br>                        len1--;<br>                        pre.next = h1;<br>                        h1 = h1.next;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        len2--;<br>                        pre.next = h2;<br>                        h2 = h2.next;<br>                    &#125;<br>                    pre = pre.next;<br>                &#125;<br>                pre.next = len1 == <span class="hljs-number">0</span> ? h2 : h1;<br>                <span class="hljs-keyword">while</span>(len1 &gt; <span class="hljs-number">0</span> || len2 &gt; <span class="hljs-number">0</span>)&#123;<br>                    pre = pre.next;<br>                    len1--;<br>                    len2--;<br>                &#125;<br>                <span class="hljs-comment">//把当前合并链表尾节点和下一个待合并链表头节点连接</span><br>                pre.next = h;<br>                <br>            &#125;    <br>            step *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.next;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-7-相交链表"><a href="#2-7-相交链表" class="headerlink" title="2.7 相交链表"></a>2.7 相交链表</h2><p>剑指offer相遇解法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(headA == headB)&#123;<br>            <span class="hljs-keyword">return</span> headA;<br>        &#125;<br>        ListNode node1 = headA;<br>        ListNode node2 = headB;<br>        <span class="hljs-keyword">boolean</span> flag1 = <span class="hljs-keyword">true</span>,flag2 = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">while</span>(node1!=<span class="hljs-keyword">null</span> || node2 != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(node1 != <span class="hljs-keyword">null</span>)&#123;<br>                node1 = node1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(flag1)&#123;<br>                    node1 = headB;<br>                    flag1 = <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node2 != <span class="hljs-keyword">null</span>)&#123;<br>                node2 = node2.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(flag2)&#123;<br>                    node2 = headA;    <br>                &#125;<br>                flag2 = <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node1 == node2)&#123;<br>                <span class="hljs-keyword">return</span> node1;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-8-反转链表"><a href="#2-8-反转链表" class="headerlink" title="2.8 反转链表"></a>2.8 反转链表</h2><p>迭代解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode node = head.next;<br>        ListNode tmp = <span class="hljs-keyword">null</span>;<br>        head.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span>(node.next != <span class="hljs-keyword">null</span>)&#123;<br>            tmp = node.next;<br>            node.next = head;<br>            head = node;<br>            node = tmp;<br>        &#125;<br>        node.next = head;<br>        head = node;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>递归解法：</p>
<p>更简洁，但会有O(N)的空间复杂度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode last = reverseList(head.next);<br>        head.next.next = head;<br>        head.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-9-回文链表"><a href="#2-9-回文链表" class="headerlink" title="2.9 回文链表"></a>2.9 回文链表</h2><p>链表后序遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"> ListNode left;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        left = head;<br>        <span class="hljs-keyword">return</span> traverse(head);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">traverse</span><span class="hljs-params">(ListNode right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">boolean</span> res = traverse(right.next);<br>    <span class="hljs-comment">// 后序遍历代码,右边无res的话比较的是当前对称节点是否相同而无法记录前面的结果</span><br>    res = res &amp;&amp; (right.val == left.val);<br>    left = left.next;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种解法相当于链表反转和原链表比较，会占用O(N)的空间复杂度。</p>
<p>可以将前半段链表和反转后半段链表比较，这样不会占用格外的空间。关键是利用快慢指针找到链表中点。</p>
<p>优化空间复杂度：</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/3.jpg" srcset="/img/loading.gif" alt="3" style="zoom:50%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode fast = head,slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>)&#123;<br>            fast  = fast.next.next;<br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-comment">//fast == null 链表为奇数，slow为中点</span><br>        <span class="hljs-comment">//fast != null 链表偶数，slow再走一步</span><br>        <span class="hljs-keyword">if</span>(fast != <span class="hljs-keyword">null</span>)&#123;<br>            slow = slow.next;<br>        &#125;<br>        ListNode right = reverse(slow);<br>    	<span class="hljs-comment">//一定要使用right，因为left和right不是完全相同，当链表节点个数为奇数，中点没有参与判断</span><br>        <span class="hljs-keyword">while</span>(right != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(right.val != head.val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            right = right.next;<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>	<span class="hljs-comment">//反转链表</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode tmp = <span class="hljs-keyword">null</span>;<br>        ListNode node = head.next;<br>        head.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">while</span>(node.next != <span class="hljs-keyword">null</span>)&#123;<br>            tmp = node.next;<br>            node.next = head;<br>            head = node;<br>            node = tmp;            <br>        &#125;<br>        node.next = head;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-10-合并k个升序链表"><a href="#2-10-合并k个升序链表" class="headerlink" title="2.10 合并k个升序链表"></a>2.10 合并k个升序链表</h2><p>两两合并，借助归并排序的递归分治思想</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = lists.length;<br>        <span class="hljs-keyword">if</span>(lists == <span class="hljs-keyword">null</span> || length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> merge(lists,<span class="hljs-number">0</span>,length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">merge</span><span class="hljs-params">(ListNode[] lists, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left == right) <span class="hljs-keyword">return</span> lists[left];<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        ListNode l1 = merge(lists, left, mid);<br>        ListNode l2 = merge(lists, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> mergeTwoLists(l1, l2);<br>    &#125;<br><br>	<span class="hljs-comment">//两个有序链表合并</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>        <span class="hljs-comment">//合并链表头节点</span><br>        ListNode head = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">//特殊情况</span><br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-comment">//选出头节点</span><br>        <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>            head = l1;<br>            l1 = l1.next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            head = l2;<br>            l2 = l2.next;<br>        &#125;<br>        <span class="hljs-comment">//迭代比较合并</span><br>        ListNode l = head;<br>        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> || l2 != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(l1 == <span class="hljs-keyword">null</span>)&#123;<br>                l.next = l2;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2 == <span class="hljs-keyword">null</span>)&#123;<br>                l.next = l1;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l1.val &lt;= l2.val)&#123;<br>                l.next = l1;<br>                l = l.next;<br>                l1 = l1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l.next = l2;<br>                l = l.next;<br>                l2 = l2.next;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>优先队列思想：</p>
<p>借助Java默认实现的PriorityQueue小根堆将所有结点都放在小根堆，每次取出的都是最小值。</p>
<p>不断地从小到大取出并连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> length = lists.length;<br>        <span class="hljs-keyword">if</span>(lists == <span class="hljs-keyword">null</span> || length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(lists.length, <span class="hljs-keyword">new</span> Comparator&lt;ListNode&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(ListNode o1, ListNode o2)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (o1.val &lt; o2.val) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (o1.val == o2.val) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;);<br>        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>        ListNode p = dummy;<br>        <span class="hljs-keyword">for</span> (ListNode node : lists) &#123;<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span>) queue.add(node);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            p.next = queue.poll();<br>            p = p.next;<br>            <span class="hljs-keyword">if</span> (p.next != <span class="hljs-keyword">null</span>) queue.add(p.next);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h1 id="3-堆"><a href="#3-堆" class="headerlink" title="3. 堆"></a>3. 堆</h1><h2 id="3-1-数组中的第K个最大元素"><a href="#3-1-数组中的第K个最大元素" class="headerlink" title="3.1 数组中的第K个最大元素"></a>3.1 数组中的第K个最大元素</h2><p>使用内置排序方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    Arrays.sort(nums);<br>    <span class="hljs-keyword">return</span> nums[nums.length - k];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用堆：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    Queue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((v1,v2)-&gt;(v2-v1));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        pq.add(num);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(k-- &gt; <span class="hljs-number">1</span>)&#123;<br>        pq.poll();<br>    &#125;<br>    <span class="hljs-keyword">return</span> pq.poll();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-2-前-K-个高频元素"><a href="#3-2-前-K-个高频元素" class="headerlink" title="3.2 前 K 个高频元素"></a>3.2 前 K 个高频元素</h2><p>值得注意的是遍历hashmap的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; set : map.entrySet())<br></code></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] topKFrequent(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        map.put(num,map.getOrDefault(num,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt;(<span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] m, <span class="hljs-keyword">int</span>[] n)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> m[<span class="hljs-number">1</span>] - n[<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; set : map.entrySet())&#123;<br>        <span class="hljs-keyword">int</span> num = set.getKey(), count = set.getValue();<br>        <span class="hljs-keyword">if</span>(queue.size() &lt; k)&#123;<br>            queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;num, count&#125;);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(count &gt; queue.peek()[<span class="hljs-number">1</span>])&#123;<br>                queue.poll();<br>                queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;num, count&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>          <span class="hljs-keyword">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>        ret[i] = queue.poll()[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="4-栈-队列"><a href="#4-栈-队列" class="headerlink" title="4. 栈/队列"></a>4. 栈/队列</h1><h2 id="4-1-有效的括号"><a href="#4-1-有效的括号" class="headerlink" title="4.1 有效的括号"></a>4.1 有效的括号</h2><p>注意java里面栈的结构是双端队列Deque</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    HashMap&lt;Character, Character&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-string">&#x27;)&#x27;</span>,<span class="hljs-string">&#x27;(&#x27;</span>);<br>    map.put(<span class="hljs-string">&#x27;]&#x27;</span>,<span class="hljs-string">&#x27;[&#x27;</span>);<br>    map.put(<span class="hljs-string">&#x27;&#125;&#x27;</span>,<span class="hljs-string">&#x27;&#123;&#x27;</span>); <br><br>    Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(i);<br>        <span class="hljs-keyword">if</span>(map.containsKey(c))&#123;<br>            <span class="hljs-keyword">if</span>(stack.isEmpty() || map.get(c) != stack.peek())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            stack.pop();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            stack.push(c);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-2-最小栈"><a href="#4-2-最小栈" class="headerlink" title="4.2 最小栈"></a>4.2 最小栈</h2><p>同剑指offer包含min函数的最小栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;<br><br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    Stack&lt;Integer&gt; stack1,stack2;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;<br>        stack1 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        stack2 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        stack1.add(x);<br>        <span class="hljs-keyword">if</span>(stack2.empty() || stack2.peek() &gt;= x)&#123;<br>            stack2.add(x);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack1.pop().equals(stack2.peek()))&#123;<br>            stack2.pop();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack1.peek();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack2.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-3-字符串解码"><a href="#4-3-字符串解码" class="headerlink" title="4.3 字符串解码"></a>4.3 字符串解码</h2><ul>
<li><p>注意Character的内置方法判别数字和字母</p>
</li>
<li><p>LinkedList作为栈的好处是方便逆置</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> ptr = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">decodeString</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    LinkedList&lt;String&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">while</span>(ptr &lt; s.length())&#123;<br>        <span class="hljs-keyword">char</span> cur = s.charAt(ptr);<br>        <span class="hljs-keyword">if</span>(Character.isDigit(cur))&#123;<br>            String digits = getDigits(s);<br>            stack.addLast(digits);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Character.isLetter(cur) || cur == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;<br>            stack.addLast(String.valueOf(s.charAt(ptr++))); <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ++ptr;<br>            LinkedList&lt;String&gt; sub = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>            <span class="hljs-keyword">while</span> (!<span class="hljs-string">&quot;[&quot;</span>.equals(stack.peekLast())) &#123;<br>                sub.addLast(stack.removeLast());<br>            &#125;<br>            Collections.reverse(sub);<br>            <span class="hljs-comment">// 左括号出栈</span><br>            stack.removeLast();<br>            <span class="hljs-comment">// 此时栈顶为当前 sub 对应的字符串应该出现的次数</span><br>            <span class="hljs-keyword">int</span> repTime = Integer.parseInt(stack.removeLast());<br>            StringBuilder t = <span class="hljs-keyword">new</span> StringBuilder();<br>            String o = getString(sub);<br>            <span class="hljs-comment">// 构造字符串</span><br>            <span class="hljs-keyword">while</span> (repTime-- &gt; <span class="hljs-number">0</span>) &#123;<br>                t.append(o);<br>            &#125;<br>            <span class="hljs-comment">// 将构造好的字符串入栈</span><br>            stack.addLast(t.toString());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> getString(stack);<br>&#125;<br><span class="hljs-function">String <span class="hljs-title">getDigits</span><span class="hljs-params">(String s)</span></span>&#123;<br>    StringBuilder nums = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">while</span>(Character.isDigit(s.charAt(ptr)))&#123;<br>        nums.append(s.charAt(ptr++));<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.toString();<br>&#125;<br><span class="hljs-function">String <span class="hljs-title">getString</span><span class="hljs-params">(LinkedList&lt;String&gt; v)</span> </span>&#123;<br>    StringBuffer ret = <span class="hljs-keyword">new</span> StringBuffer();<br>    <span class="hljs-keyword">for</span> (String s : v) &#123;<br>        ret.append(s);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret.toString();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-4-每日温度"><a href="#4-4-每日温度" class="headerlink" title="4.4 每日温度"></a>4.4 每日温度</h2><p>单调栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;<br>    <span class="hljs-comment">//答案数组</span><br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T.length];<br>    <span class="hljs-comment">//单调栈</span><br>    LinkedList&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = T.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">while</span>( !stack.isEmpty() &amp;&amp; T[stack.peek()] &lt;= T[i])&#123;<br>            stack.pop();<br>        &#125;<br>        res[i] = stack.isEmpty() ? <span class="hljs-number">0</span> : (stack.peek() - i);<br>        stack.push(i);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-5-柱状图中最大矩形"><a href="#4-5-柱状图中最大矩形" class="headerlink" title="4.5 柱状图中最大矩形"></a>4.5 柱状图中最大矩形</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = heights.length;<br>    <span class="hljs-keyword">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <br>    Stack&lt;Integer&gt; mono_stack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;<br>            mono_stack.pop();<br>        &#125;<br>        left[i] = (mono_stack.isEmpty() ? -<span class="hljs-number">1</span> : mono_stack.peek());<br>        mono_stack.push(i);<br>    &#125;<br><br>    mono_stack.clear();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">while</span> (!mono_stack.isEmpty() &amp;&amp; heights[mono_stack.peek()] &gt;= heights[i]) &#123;<br>            mono_stack.pop();<br>        &#125;<br>        right[i] = (mono_stack.isEmpty() ? n : mono_stack.peek());<br>        mono_stack.push(i);<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        ans = Math.max(ans, (right[i] - left[i] - <span class="hljs-number">1</span>) * heights[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-6-最大矩形"><a href="#4-6-最大矩形" class="headerlink" title="4.6 最大矩形"></a>4.6 最大矩形</h2><p>先转化成求柱状图中最大矩形问题。</p>
<p>我们首先计算出矩阵的每个元素的左边连续 1的数量，使用二维数组$ \textit{left}$ 记录，其中 $\textit{left}[i][j]$ 为矩阵第 i 行第 j 列元素的左边连续 1 的数量。</p>
<p>具体而言，当考察以 $\textit{matrix}[i][j]$ 为右下角的矩形时，我们枚举满足 $0 \le k \le i$ 的所有可能的 k，此时矩阵的最大宽度就为</p>
<script type="math/tex; mode=display">
\textit{left}[i][j], \textit{left}[i-1][j], \ldots, \textit{left}[k][j]</script><p>的最小值。</p>
<p>对每一列：</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/最大矩形3.png" srcset="/img/loading.gif" alt="最大矩形3" style="zoom: 33%;" /></p>
<p>转化成了柱状图中最大矩形问题。</p>
<p>枚举每一列得到答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximalRectangle</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = matrix.length;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span>[][] left = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><br>        <span class="hljs-comment">//形成柱状图</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    left[i][j] = (j == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : left[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123; <span class="hljs-comment">// 对于每一列，使用基于柱状图的方法</span><br>            <span class="hljs-keyword">int</span>[] up = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];<br>            <span class="hljs-keyword">int</span>[] down = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];<br><br>            Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;<br>                    stack.pop();<br>                &#125;<br>                up[i] = stack.isEmpty() ? -<span class="hljs-number">1</span> : stack.peek();<br>                stack.push(i);<br>            &#125;<br>            stack.clear();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; left[stack.peek()][j] &gt;= left[i][j]) &#123;<br>                    stack.pop();<br>                &#125;<br>                down[i] = stack.isEmpty() ? m : stack.peek();<br>                stack.push(i);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-keyword">int</span> height = down[i] - up[i] - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">int</span> area = height * left[i][j];<br>                ret = Math.max(ret, area);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="5-树"><a href="#5-树" class="headerlink" title="5. 树"></a>5. 树</h1><p>普通二叉树解题基本都离不开各种遍历方法，掌握好遍历方法是做好二叉树的关键。</p>
<p>二叉搜索树的技巧在于利用其自身的特性，如果当前节点会对下面子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。</p>
<h2 id="5-1-对称二叉树"><a href="#5-1-对称二叉树" class="headerlink" title="5.1 对称二叉树"></a>5.1 对称二叉树</h2><p>递归解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">//前序遍历</span><br>	<span class="hljs-keyword">return</span> root == <span class="hljs-keyword">null</span> || recur(root.left,root.right);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode left, TreeNode right)</span></span>&#123;<br>    <span class="hljs-comment">//递归出口</span><br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)&#123;<br>   		<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span> || right == <span class="hljs-keyword">null</span> || left.val != right.val)&#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>	<span class="hljs-keyword">return</span> recur(left.left,right.right) &amp;&amp; recur(left.right,right.left);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>迭代解法：</p>
<p>二叉树的算法通常与遍历有关，无法使用递归的遍历方法情况下，有层序遍历和非递归的前序中序后序的遍历方法。</p>
<p>层序遍历借助队列实现，在本题中可以一个正常层序遍历，一个倒序层序遍历（构建原来树的镜像树）进行比较</p>
<p>实现队列插入时发现不需要判空，jdk文档的说明：</p>
<blockquote>
<p><code>Queue</code> 实现通常不允许插入 <code>null</code> 元素，尽管某些实现（如 <a target="_blank" rel="noopener" href="https://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/LinkedList.html"><code>LinkedList</code></a>）并不禁止插入 <code>null</code>。即使在允许 null 的实现中，也不应该将 <code>null</code> 插入到 <code>Queue</code> 中，因为 <code>null</code> 也用作 <code>poll</code> 方法的一个特殊返回值，表明队列不包含元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;    <br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        queue.offer(root);<br>        queue.offer(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>          TreeNode tmp1 = queue.poll();<br>          TreeNode tmp2 = queue.poll();<br>          <span class="hljs-keyword">if</span>(tmp1 == <span class="hljs-keyword">null</span> &amp;&amp; tmp2 == <span class="hljs-keyword">null</span>)&#123;<br>              <span class="hljs-keyword">continue</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span>(tmp1 == <span class="hljs-keyword">null</span> || tmp2 == <span class="hljs-keyword">null</span> || tmp1.val != tmp2.val)&#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>          &#125;<br>        <span class="hljs-comment">//不需要判空，因为queue的linkedlist允许null</span><br>        queue.add(tmp1.left);<br>        queue.add(tmp2.right);<br>          <br>        queue.add(tmp1.right);<br>        queue.add(tmp2.left);        <br>        &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可不可以不借助队列比较，不去构建镜像比较，将每层直接在原树上借助栈比较，这样有下面的问题</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-number">1</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br>  <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br>  <span class="hljs-number">3</span>    <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p>所以入栈时对于子节点不全为null的树节点，将其空子节点置为-1方便比较。而且也需要借助队列，空间复杂度没有得到优化。</p>
<p>既然可以借助层序遍历，那可不可以借助非递归前序遍历</p>
<p>应该是不可以的，前序遍历的非递归代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; results = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>	    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>        TreeNode cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span> || !stack.empty()) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;<br>                results.add(cur.val);<br>                stack.push(cur);<br>                cur = cur.left;<br>            &#125;<br>            cur = stack.pop();<br>            <span class="hljs-comment">// 转向</span><br>            cur = cur.right;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>因为题目要判定对称二叉树，递归可以使得左右同步的进行，所以可以比较，而非递归的遍历方式是一步步的将左子树走完再去走右子树。</p>
<h2 id="5-2-二叉树最大深度"><a href="#5-2-二叉树最大深度" class="headerlink" title="5.2 二叉树最大深度"></a>5.2 二叉树最大深度</h2><p>递归法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(maxDepth(root.left),maxDepth(root.right));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>迭代法：</p>
<p>使用迭代的方法其实就是记录分支里面最深的深度，参考层序遍历时将每层打印的方法，每记录一层加1可以得到二叉树最大深度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        queue.add(root);<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = queue.size();i &gt; <span class="hljs-number">0</span>;i--)&#123;<br>                TreeNode tmp = queue.poll();<br>                <span class="hljs-keyword">if</span>(tmp.left != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(tmp.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(tmp.right != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(tmp.right);<br>                &#125;<br>            &#125;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-3-翻转二叉树"><a href="#5-3-翻转二叉树" class="headerlink" title="5.3 翻转二叉树"></a>5.3 翻转二叉树</h2><p>递归法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">//递归出口</span><br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    TreeNode tmp = root.left;<br>    <span class="hljs-comment">//前序遍历将每个节点反转</span><br>    root.left = invertTree(root.right);<br>    root.right = invertTree(tmp);<br>	<span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>也可以层序遍历将每个节点翻转</p>
<p>迭代法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            TreeNode tmp = queue.poll();<br>            TreeNode node = tmp.left;<br>            tmp.left = tmp.right;<br>            tmp.right = node;<br>            <span class="hljs-keyword">if</span>(tmp.left != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(tmp.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(tmp.right != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(tmp.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-4-二叉树的直径"><a href="#5-4-二叉树的直径" class="headerlink" title="5.4 二叉树的直径"></a>5.4 二叉树的直径</h2><p>实质为求左右子树深度和的最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> max;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    maxDepth(root);<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> leftDepth = maxDepth(root.left);<br>    <span class="hljs-keyword">int</span> rightDepth = maxDepth(root.right);<br>    max = Math.max(max,leftDepth + rightDepth);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(leftDepth,rightDepth);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-5-合并二叉树"><a href="#5-5-合并二叉树" class="headerlink" title="5.5 合并二叉树"></a>5.5 合并二叉树</h2><p>递归法：</p>
<p>前序递归的合并每一个子树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode t1, TreeNode t2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(t1 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> t2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(t2 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> t1;<br>        &#125;<br>        TreeNode t = <span class="hljs-keyword">new</span> TreeNode(t1.val + t2.val);<br>        t.left = mergeTrees(t1.left,t2.left);<br>        t.right = mergeTrees(t1.right,t2.right);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>迭代法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode t1, TreeNode t2)</span> </span>&#123;<br>	<span class="hljs-comment">//如果 t1和t2中，只要有一个是null，函数就直接返回</span><br>		<span class="hljs-keyword">if</span>(t1==<span class="hljs-keyword">null</span> || t2==<span class="hljs-keyword">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> t1==<span class="hljs-keyword">null</span>? t2 : t1;<br>		&#125;<br>		java.util.LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> java.util.LinkedList&lt;TreeNode&gt;();<br>		queue.add(t1);<br>		queue.add(t2);<br>		<span class="hljs-keyword">while</span>(queue.size()&gt;<span class="hljs-number">0</span>) &#123;<br>			TreeNode r1 = queue.remove();<br>			TreeNode r2 = queue.remove();<br>			r1.val += r2.val;<br>			<span class="hljs-comment">//如果r1和r2的左子树都不为空，就放到队列中</span><br>			<span class="hljs-comment">//如果r1的左子树为空，就把r2的左子树挂到r1的左子树上</span><br>			<span class="hljs-keyword">if</span>(r1.left!=<span class="hljs-keyword">null</span> &amp;&amp; r2.left!=<span class="hljs-keyword">null</span>)&#123;<br>				queue.add(r1.left);<br>				queue.add(r2.left);<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r1.left==<span class="hljs-keyword">null</span>) &#123;<br>				r1.left = r2.left;<br>			&#125;<br>			<span class="hljs-comment">//对于右子树也是一样的</span><br>			<span class="hljs-keyword">if</span>(r1.right!=<span class="hljs-keyword">null</span> &amp;&amp; r2.right!=<span class="hljs-keyword">null</span>) &#123;<br>				queue.add(r1.right);<br>				queue.add(r2.right);<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r1.right==<span class="hljs-keyword">null</span>) &#123;<br>				r1.right = r2.right;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> t1;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-6-二叉树的中序遍历"><a href="#5-6-二叉树的中序遍历" class="headerlink" title="5.6 二叉树的中序遍历"></a>5.6 二叉树的中序遍历</h2><p>递归法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>        &#125;<br>        recur(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        recur(root.left);<br>        res.add(root.val);<br>        recur(root.right);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>迭代法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">//初始化</span><br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    TreeNode cur = root;<br><br>    <span class="hljs-comment">//遍历</span><br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span> || !stack.isEmpty())&#123;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>            stack.push(cur);<br>            cur = cur.left;<br>        &#125;<br>        cur = stack.pop();<br>        res.add(cur.val);<br>        cur = cur.right;<br>    &#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>参考自leetcode颜色标记法：</p>
<p>兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。其核心思想如下：</p>
<ul>
<li>使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。</li>
<li>如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。</li>
<li>如果遇到的节点为灰色，则将节点的值输出。</li>
</ul>
<p>使用这种方法实现的中序遍历如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorNode</span> </span>&#123;<br>        TreeNode node;<br>        String color;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ColorNode</span><span class="hljs-params">(TreeNode node,String color)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.node = node;<br>            <span class="hljs-keyword">this</span>.color = color;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>            <br>        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Stack&lt;ColorNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        stack.push(<span class="hljs-keyword">new</span> ColorNode(root,<span class="hljs-string">&quot;white&quot;</span>));<br>        <br>        <span class="hljs-keyword">while</span>(!stack.empty())&#123;<br>            ColorNode cn = stack.pop();<br>            <br>            <span class="hljs-keyword">if</span>(cn.color.equals(<span class="hljs-string">&quot;white&quot;</span>))&#123;<br>                <span class="hljs-keyword">if</span>(cn.node.right != <span class="hljs-keyword">null</span>) stack.push(<span class="hljs-keyword">new</span> ColorNode(cn.node.right,<span class="hljs-string">&quot;white&quot;</span>));<br>                stack.push(<span class="hljs-keyword">new</span> ColorNode(cn.node,<span class="hljs-string">&quot;gray&quot;</span>));<br>                <span class="hljs-keyword">if</span>(cn.node.left != <span class="hljs-keyword">null</span>)stack.push(<span class="hljs-keyword">new</span> ColorNode(cn.node.left,<span class="hljs-string">&quot;white&quot;</span>));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res.add(cn.node.val);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如要实现前序、后序遍历，只需要调整左右子节点的入栈顺序即可。</p>
<h2 id="5-7-二叉树的层序遍历"><a href="#5-7-二叉树的层序遍历" class="headerlink" title="5.7 二叉树的层序遍历"></a>5.7 二叉树的层序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;TreeNode&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>)&#123;<br>        queue.add(root);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = queue.size();i &gt; <span class="hljs-number">0</span>;i--)&#123;<br>            TreeNode node = queue.poll();<br>            list.add(node.val);<br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(node.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>)&#123;<br>                queue.add(node.right);<br>            &#125;<br>        &#125;<br>        res.add(list);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-8-重建二叉树"><a href="#5-8-重建二叉树" class="headerlink" title="5.8 重建二叉树"></a>5.8 重建二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (preorder.length==<span class="hljs-number">0</span>||inorder.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//递归出口</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; inorder.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(preorder[<span class="hljs-number">0</span>] == inorder[i])&#123;<br>                root.left = buildTree(Arrays.copyOfRange(preorder,<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>),Arrays.copyOfRange(inorder,<span class="hljs-number">0</span>,i));<br>                root.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="hljs-number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="hljs-number">1</span>,inorder.length));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br><br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-9-二叉树展开为链表"><a href="#5-9-二叉树展开为链表" class="headerlink" title="5.9 二叉树展开为链表"></a>5.9 二叉树展开为链表</h2><p>可以使用O(n)的格外空间来接收先序遍历得到的节点，题目的进阶要求为使用O(1)的额外空间，也就是在原来的树上作出改动。</p>
<p>观察发现满足递归特性，将左子树展开结果连接到根节点的右子节点，再连接右子树展开结果。但是递归也会使用O(n)栈空间</p>
<p>已知的额外空间为O(1)的遍历方法为Mirros算法，下面借助Mirros算法思想：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123; <br>            <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span>)&#123;<br>                root = root.right;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                TreeNode pre = root.left;<br>                <span class="hljs-keyword">while</span>(pre.right != <span class="hljs-keyword">null</span>)&#123;<br>                    pre = pre.right;<br>                &#125;<br>                pre.right = root.right;<br>                root.right = root.left;<br>                root.left = <span class="hljs-keyword">null</span>;<br>                root = root.right;<br>            &#125;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-10-二叉树的最近公共祖先"><a href="#5-10-二叉树的最近公共祖先" class="headerlink" title="5.10 二叉树的最近公共祖先"></a>5.10 二叉树的最近公共祖先</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root == p || root == q) &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        TreeNode left = lowestCommonAncestor(root.left,p,q);<br>        TreeNode right = lowestCommonAncestor(root.right,p,q);<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-11-二叉树中的最大路径和"><a href="#5-11-二叉树中的最大路径和" class="headerlink" title="5.11 二叉树中的最大路径和"></a>5.11 二叉树中的最大路径和</h2><p>后序递归遍历，首先计算节点贡献值，节点贡献值=节点值 + Math.max(左节点贡献值 +,右节点贡献值)，最大路径和=Max{每个节点的左右贡献值(&gt;0) + 节点值}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> maxSums = Integer.MIN_VALUE;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>       maxGain(root);<br>       <span class="hljs-keyword">return</span> maxSums;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxGain</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">int</span> leftNum = Math.max(maxGain(root.left),<span class="hljs-number">0</span>);<br>       <span class="hljs-keyword">int</span> rightNum = Math.max(maxGain(root.right),<span class="hljs-number">0</span>);<br>       <span class="hljs-keyword">int</span> grade = leftNum + rightNum + root.val;<br>       maxSums = Math.max(maxSums,grade);<br>       <span class="hljs-keyword">return</span> root.val + Math.max(leftNum,rightNum);<br>   &#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-12-验证二叉搜索树"><a href="#5-12-验证二叉搜索树" class="headerlink" title="5.12 验证二叉搜索树"></a>5.12 验证二叉搜索树</h2><p>两个思路： </p>
<ul>
<li>可以通过验证二叉树的中序序列如果是递增序列说明是二叉搜索树。</li>
<li>验证每个节点左子树都小于根节点值，右子树都大于根节点值，但是找出左子树中的最小值或找出右子树最大值并不容易，可以扩展参数列表让左子树的值不得超过root.val，右子树的值不得小于root.val。</li>
</ul>
<p>思路1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> pre = Long.MIN_VALUE;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!isValidBST(root.left))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pre &gt;= root.val)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    pre = root.val;<br>    <span class="hljs-keyword">return</span> isValidBST(root.right);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>思路2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> helper(root,<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode root,Integer minSum,Integer maxSum)</span></span>&#123;<br>        <span class="hljs-comment">//递归出口</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> val = root.val;<br>        <span class="hljs-comment">//前序遍历</span><br>        <span class="hljs-keyword">if</span>(minSum != <span class="hljs-keyword">null</span> &amp;&amp; val &lt;= minSum)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(maxSum != <span class="hljs-keyword">null</span> &amp;&amp; val &gt;= maxSum)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!helper(root.left,minSum,val))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!helper(root.right,val,maxSum))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-13-二叉搜索树转换为累加树"><a href="#5-13-二叉搜索树转换为累加树" class="headerlink" title="5.13 二叉搜索树转换为累加树"></a>5.13 二叉搜索树转换为累加树</h2><p>题目要求使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。相当于是二叉搜索树的中序逆序遍历，每次遍历到一个节点加上上一个节点就好。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        inOrderTraverse(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inOrderTraverse(root.right);<br>        root.val += sum;<br>        sum = root.val;<br>        inOrderTraverse(root.left);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-14-不同的二叉搜索树"><a href="#5-14-不同的二叉搜索树" class="headerlink" title="5.14 不同的二叉搜索树"></a>5.14 不同的二叉搜索树</h2><p>难点在于推出公式而不是动态规划</p>
<p>题目要求是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：</p>
<ol>
<li>$G(n)$: 长度为 n 的序列能构成的不同二叉搜索树的个数。</li>
<li>$F(i, n)$: 以 i 为根、序列长度为 n 的不同二叉搜索树个数 $(1≤i≤n)$。</li>
</ol>
<p>有以下关系：</p>
<script type="math/tex; mode=display">
G(n)= \sum_{n=1}^n F(i,n)\qquad \qquad(1)</script><p>举例而言，创建以 3 为根、长度为 7 的不同二叉搜索树，整个序列是 $[1, 2, 3, 4, 5, 6, 7]$，我们需要从左子序列 $[1,2]$ 构建左子树，从右子序列 $[4, 5, 6, 7]$ 构建右子树，然后将它们组合（即笛卡尔积）。</p>
<p>对于这个例子，不同二叉搜索树的个数为 $F(3, 7)$。我们将 $[1,2]$ 构建不同左子树的数量表示为G(2), 从$ [4, 5, 6, 7]$ 构建不同右子树的数量表示为 G(4)，注意到 G(n) 和序列的内容无关，只和序列的长度有关。于是，$F(3,7) = G(2) \cdot G(4)$。 因此，我们可以得到以下公式：</p>
<script type="math/tex; mode=display">
F(i, n) = G(i-1) \cdot G(n-i) \qquad \qquad (2)</script><p>将公式 (1)，(2) 结合，可以得到 G(n) 的递归表达式：</p>
<script type="math/tex; mode=display">
G(n) = \sum_{i=1}^{n}G(i-1) \cdot G(n-i) \qquad \qquad (3)</script><p>至此，我们从小到大计算 G 函数即可，因为G(n) 的值依赖于 $G(0) \cdots G(n-1)$。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    res[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    res[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)&#123;<br>            res[i] += res[j - <span class="hljs-number">1</span>] * res[i - j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res[n];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-15-打家劫舍-Ⅲ"><a href="#5-15-打家劫舍-Ⅲ" class="headerlink" title="5.15 打家劫舍 Ⅲ"></a>5.15 打家劫舍 Ⅲ</h2><p>树形dp，对于常见的动态规划遍历的状态是数组，可以采用自顶向下的递归遍历和自底向上的迭代遍历。而树形dp使用递归遍历比较方便。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coq">    <span class="hljs-number">3</span><br>   / \<br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>   \   \ <br>    <span class="hljs-number">3</span>   <span class="hljs-number">1</span><br>重叠的子问题在于选root下一步会递归root.<span class="hljs-built_in">left</span>.<span class="hljs-built_in">right</span><br>不选递归root.<span class="hljs-built_in">left</span>以后，root.<span class="hljs-built_in">left</span>不选又递归root.<span class="hljs-built_in">left</span>.<span class="hljs-built_in">right</span><br></code></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;TreeNode, Integer&gt; memo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(memo.containsKey(root))&#123;<br>        <span class="hljs-keyword">return</span> memo.get(root);<br>    &#125;<br>    <span class="hljs-keyword">int</span> value_do = root.val <br>    + (root.left == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : rob(root.left.left) + rob(root.left.right))<br>    + (root.right == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : rob(root.right.left) + rob(root.right.right));<br>    <span class="hljs-keyword">int</span> value_not = rob(root.left) + rob(root.right);<br><br>    <span class="hljs-keyword">int</span> res = Math.max(value_do, value_not);<br>    memo.put(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-16-路径总和Ⅲ"><a href="#5-16-路径总和Ⅲ" class="headerlink" title="5.16 路径总和Ⅲ"></a>5.16 路径总和Ⅲ</h2><p>回溯+前缀和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// key是前缀和, value是大小为key的前缀和出现的次数</span><br> Map&lt;Integer, Integer&gt; prefixSumCount = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>     <span class="hljs-comment">// 前缀和为0的一条路径</span><br>     prefixSumCount.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>     <span class="hljs-comment">// 前缀和的递归回溯</span><br>     <span class="hljs-keyword">return</span> recursionPathSum(root, sum, <span class="hljs-number">0</span>);<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">recursionPathSum</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> currSum)</span> </span>&#123;<br>     <span class="hljs-comment">// 1.递归终止条件</span><br>     <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     &#125;<br>     <span class="hljs-comment">// 2.本层要做的事情</span><br>     <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>     <span class="hljs-comment">// 当前路径上的和</span><br>     currSum += node.val;<br><br>     <span class="hljs-comment">// currSum-target相当于找路径的起点，起点的sum+target=currSum，当前点到起点的距离就是target</span><br>     res += prefixSumCount.getOrDefault(currSum - target, <span class="hljs-number">0</span>);<br>     <span class="hljs-comment">// 更新路径上当前节点前缀和的个数</span><br>     prefixSumCount.put(currSum, prefixSumCount.getOrDefault(currSum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br><br>     <span class="hljs-comment">// 3.进入下一层</span><br>     res += recursionPathSum(node.left, target, currSum);<br>     res += recursionPathSum(node.right, target, currSum);<br><br>     <span class="hljs-comment">// 4.回到本层，恢复状态，去除当前节点的前缀和数量</span><br>     prefixSumCount.put(currSum, prefixSumCount.get(currSum) - <span class="hljs-number">1</span>);<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-17-二叉树的序列化和反序列化"><a href="#5-17-二叉树的序列化和反序列化" class="headerlink" title="5.17 二叉树的序列化和反序列化"></a>5.17 二叉树的序列化和反序列化</h2><p>同剑指offer序列化二叉树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> </span>&#123;<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[]&quot;</span>;<br>        &#125;<br>        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;[&quot;</span>);<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            TreeNode node = queue.poll();<br>            <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>)&#123;<br>                res.append(node.val + <span class="hljs-string">&quot;,&quot;</span>);<br>                queue.add(node.left);<br>                queue.add(node.right);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res.append(<span class="hljs-string">&quot;null,&quot;</span>);<br>            &#125;<br>        &#125;<br>        res.deleteCharAt(res.length() - <span class="hljs-number">1</span>);<br>        res.append(<span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-keyword">return</span> res.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(data.equals(<span class="hljs-string">&quot;[]&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        String[] vals = data.substring(<span class="hljs-number">1</span>, data.length() - <span class="hljs-number">1</span>).split(<span class="hljs-string">&quot;,&quot;</span>);<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[<span class="hljs-number">0</span>]));<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;()&#123;&#123;add(root);&#125;&#125;;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>            TreeNode node = queue.poll();<br>            <span class="hljs-keyword">if</span>(!vals[i].equals(<span class="hljs-string">&quot;null&quot;</span>))&#123;<br>                node.left = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[i]));<br>                queue.add(node.left);<br>            &#125;<br>            i++;<br>            <span class="hljs-keyword">if</span>(!vals[i].equals(<span class="hljs-string">&quot;null&quot;</span>))&#123;<br>                node.right = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(vals[i]));<br>                queue.add(node.right);<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="6-动态规划"><a href="#6-动态规划" class="headerlink" title="6. 动态规划"></a>6. 动态规划</h1><h2 id="6-1-回文子串"><a href="#6-1-回文子串" class="headerlink" title="6.1 回文子串"></a>6.1 回文子串</h2><p>暴力解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>       <span class="hljs-comment">//循环所有子串</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.length();i++)&#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt; s.length();j++)&#123;<br>               <span class="hljs-keyword">if</span>(isCycle(s.substring(i, j + <span class="hljs-number">1</span>)))&#123;<br>                   res++;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br><span class="hljs-comment">//判断子串是否为回文子串</span><br>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCycle</span><span class="hljs-params">(String str)</span></span>&#123;<br>       <span class="hljs-keyword">int</span> length = str.length() - <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; length;i++)&#123;<br>           <span class="hljs-keyword">if</span>(str.charAt(i)!= str.charAt(length-i))&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>时间复杂度$O(n^3)$，空间复杂度O(1)</p>
<p>动态规划：</p>
<p>符合动态规划吗？</p>
<ul>
<li>存在重叠子问题<ul>
<li>比如abbc这个字符串，判断bb和abbc存在重叠</li>
</ul>
</li>
<li>子问题存在最优子结构<ul>
<li>子串里面也有回文子串</li>
</ul>
</li>
<li>是穷举求最值的问题<ul>
<li>需要穷举子串，因为每个字符都会被视为一个子串</li>
</ul>
</li>
</ul>
<p>根据子问题与子问题的关系写出状态转移方程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//dp[i][j]代表i开始j结尾的子串是否是回文子串</span><br><span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; ((j - i &lt; <span class="hljs-number">2</span>) || (dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>])))&#123;<br>    dp[i][j] = <span class="hljs-keyword">true</span>;<br>    res++;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>$dp[i][j]$：$dp[i][j]$代表i开始j结尾的子串是否是回文子串</p>
<p>初始化：当j-i&lt;2时$dp[i][j]$为true</p>
<p>注意遍历方向：</p>
<p>dp$[i + 1][j - 1]$ 在 $dp[i][j]$的左下角，如图：</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/1611220396-SMuRcS-file_1611220396509" srcset="/img/loading.gif" alt="647.回文子串" style="zoom:50%;" /></p>
<p><strong>所以一定要从下到上，从左到右遍历，这样保证$dp[i + 1][j - 1]$都是经过计算的</strong>。</p>
<p>又因为需要依赖初值$j - i &lt; 2$，所以遍历下半部分</p>
<p>最终代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(String s)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> n = s.length();<br>       <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][n];<br>    	<span class="hljs-comment">//状态转移，遍历方向为下半部分</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt; n;j++)&#123;<br>               <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; ((j - i &lt; <span class="hljs-number">2</span>) || (dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>])))&#123;<br>                   dp[i][j] = <span class="hljs-keyword">true</span>;<br>                   res++;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-2-最长回文子串"><a href="#6-2-最长回文子串" class="headerlink" title="6.2 最长回文子串"></a>6.2 最长回文子串</h2><p>动态规划的条件：</p>
<ul>
<li>存在重叠子问题<ul>
<li>最长回文子串的子串也是回文子串</li>
</ul>
</li>
<li>最优子结构<ul>
<li>最长</li>
</ul>
</li>
<li>穷举求最值问题</li>
</ul>
<p>代码同 回文子串 ，在记录结果时有不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    String res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n][n];<br> 	<span class="hljs-comment">//状态转移，遍历方向为下半部分</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt; n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; ((j - i &lt; <span class="hljs-number">2</span>) || (dp[i+<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>])))&#123;<br>                dp[i][j] = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">if</span>(j - i + <span class="hljs-number">1</span> &gt; res.length())&#123;<br>                    res = s.substring(i,j+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-3-零钱兑换"><a href="#6-3-零钱兑换" class="headerlink" title="6.3 零钱兑换"></a>6.3 零钱兑换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-comment">//dp[i]含义是金额为i的最少硬币个数</span><br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp,amount + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//初始化</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//状态转移</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; amount + <span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; coins.length;j++)&#123;<br>                <span class="hljs-keyword">if</span>(coins[j] &gt; i)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                dp[i] = Math.min(dp[i],dp[i - coins[j]] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == amount + <span class="hljs-number">1</span> ? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-4-分割等和子集"><a href="#6-4-分割等和子集" class="headerlink" title="6.4 分割等和子集"></a>6.4 分割等和子集</h2><p>子集背包问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>            sum += num;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        sum = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-comment">//dp[i][j]前i个数是否存在组合可以为j</span><br>        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>][sum + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">//初始化</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n;i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//状态转移</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt;= sum;j++)&#123;<br>                <span class="hljs-keyword">if</span>(j - nums[i - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>)&#123;<br>                   dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] || dp[i - <span class="hljs-number">1</span>][j - nums[i - <span class="hljs-number">1</span>]];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][sum];<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-5-目标和"><a href="#6-5-目标和" class="headerlink" title="6.5 目标和"></a>6.5 目标和</h2><p>子集背包问题</p>
<p>与分割等和子集类似，目标和问题存在如下关系：</p>
<script type="math/tex; mode=display">
positive - negative = target\\
positive - (sum-positive) = target\\
positive = (target+sum)/2</script><p>现在问题转化为寻找一个子集使得和等于$(target+sum)/2$，用背包问题描述是：</p>
<p><strong>给一个可装载重量为</strong> <strong><code>(target+sum)/2</code></strong> <strong>的背包和</strong> <strong><code>N</code></strong> <strong>个物品，每个物品的重量为</strong> <strong><code>nums[i]</code></strong>。现在让你装物品，存在几种装法，能够恰好将背包装满？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> S)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        sum += num;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum &lt; S || (sum + S) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    sum = (S + sum) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">//dp数组的含义是前i个数字能够凑成和为j的方案</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][sum + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-comment">//和为0的方案只有一种（不装）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= n; i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//转移方程是dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= sum; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= nums[i-<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-comment">// 两种选择的结果之和</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i-<span class="hljs-number">1</span>][j-nums[i-<span class="hljs-number">1</span>]];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 背包的空间不足，只能选择不装物品 i</span><br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n][sum];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-6-零钱兑换Ⅱ"><a href="#6-6-零钱兑换Ⅱ" class="headerlink" title="6.6 零钱兑换Ⅱ"></a>6.6 零钱兑换Ⅱ</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, <span class="hljs-keyword">int</span>[] coins)</span> </span>&#123;<br>    <span class="hljs-comment">//dp[i]含义是金额为i的组合个数</span><br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount + <span class="hljs-number">1</span>];<br>    Arrays.fill(dp,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//初始化</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//状态转移</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> coin : coins)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = coin; i &lt; amount + <span class="hljs-number">1</span>; i++)&#123;<br>            dp[i] += dp[i - coin];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-7-编辑距离"><a href="#6-7-编辑距离" class="headerlink" title="6.7 编辑距离"></a>6.7 编辑距离</h2><p>动态规划的条件：</p>
<ul>
<li>存在重叠子问题<ul>
<li>不同的修改方案有可能存在局部的相同修改</li>
</ul>
</li>
<li>最优子结构<ul>
<li>最少操作数</li>
</ul>
</li>
<li>穷举求最值问题<ul>
<li>修改方式很多，我们可以穷举</li>
</ul>
</li>
</ul>
<ol>
<li><p>定义$dp[i][j]$的含义：</p>
<p>以子串1中以i结尾子串和子串2中以j结尾子串的最少操作数</p>
</li>
<li><p>状态转移方程(右侧分别对应插入、删除、替换)：​</p>
<script type="math/tex; mode=display">
dp[i][j] = \begin{cases} min(dp((i, j - 1) + 1, dp(i - 1, j) + 1),dp[i - 1][j - 1] + 1), & s1[i] != s2[j]\\dp[i - 1][j - 1],&s1[i] == s2[j]\end{cases}</script></li>
<li><p>初始化：</p>
<p>当i或j为0时，代表其中一个子串已经为空，此时直接返回另一剩余子串长度。</p>
</li>
</ol>
<p>自顶向下解法：</p>
<p>使用了备忘录，不使用备忘录会超出时间限制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">    String word1,word2;<br>    <span class="hljs-keyword">int</span> dp[][];<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.word1 = word1;<br>        <span class="hljs-keyword">this</span>.word2 = word2;<br>        <span class="hljs-keyword">int</span> length1 = word1.length();<br>        <span class="hljs-keyword">int</span> length2 = word2.length();<br>        <span class="hljs-keyword">this</span>.dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length1 + <span class="hljs-number">1</span>][length2 + <span class="hljs-number">1</span>];<br>   		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;= length1;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt;= length2;j++)&#123;<br>                dp[i][j] = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    	<span class="hljs-comment">//i，j 初始化指向最后一个索引</span><br>	    <span class="hljs-keyword">return</span> helper(length1, length2);<br>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-comment">//备忘录</span><br>        <span class="hljs-keyword">if</span>(dp[i][j] &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> dp[i][j];<br>        &#125;<br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) &#123;<br>            dp[i][j] = i + j;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//状态转移</span><br>            <span class="hljs-keyword">if</span>(word1.charAt(i - <span class="hljs-number">1</span>) == word2.charAt(j - <span class="hljs-number">1</span>))&#123;<br>                dp[i][j] = helper(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>);  <span class="hljs-comment">//啥都不做</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//插入，删除，替换</span><br>                dp[i][j] =  Math.min(<br>                    Math.min(helper(i, j - <span class="hljs-number">1</span>), helper(i - <span class="hljs-number">1</span>, j)),<br>                    helper(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>           <br>        <span class="hljs-keyword">return</span> dp[i][j];<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>自底向上解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = s1.length(), n = s2.length();<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// base case </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        dp[<span class="hljs-number">0</span>][j] = j;<br>    <span class="hljs-comment">// 自底向上求解</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>            <span class="hljs-keyword">if</span> (s1.charAt(i-<span class="hljs-number">1</span>) == s2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125; <br>            <span class="hljs-keyword">else</span>&#123;<br>                dp[i][j] = Math.min(<br>                    Math.min(dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>,dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>),<br>                    dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>                );<br>            &#125;               <br>                <br>    <span class="hljs-comment">// 储存着整个 s1 和 s2 的最小编辑距离</span><br>    <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-8-最大子序和"><a href="#6-8-最大子序和" class="headerlink" title="6.8 最大子序和"></a>6.8 最大子序和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">int</span> dp_0 = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> dp_1 = <span class="hljs-number">0</span>, res = dp_0;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// dp[i] = max(nums[i], nums[i] + dp[i-1])</span><br>        dp_1 = Math.max(nums[i], nums[i] + dp_0);<br>        dp_0 = dp_1;<br>        <span class="hljs-comment">// 顺便计算最大的结果</span><br>        res = Math.max(res, dp_1);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-9-最长递增子序列"><a href="#6-9-最长递增子序列" class="headerlink" title="6.9 最长递增子序列"></a>6.9 最长递增子序列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> dp[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    Arrays.fill(dp,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j])&#123;<br>                dp[i] = Math.max(dp[i],dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dp.length; i++)&#123;<br>        res = Math.max(res,dp[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-10-买卖股票的最佳时机"><a href="#6-10-买卖股票的最佳时机" class="headerlink" title="6.10 买卖股票的最佳时机"></a>6.10 买卖股票的最佳时机</h2><p>动态规划</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][<span class="hljs-number">2</span>];<br><br>	<span class="hljs-comment">//状态转移</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>    	<span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> == -<span class="hljs-number">1</span>) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 解释：</span><br>            <span class="hljs-comment">//   dp[i][0] </span><br>            <span class="hljs-comment">// = max(dp[-1][0], dp[-1][1] + prices[i])</span><br>            <span class="hljs-comment">// = max(0, -infinity + prices[i]) = 0</span><br>            dp[i][<span class="hljs-number">1</span>] = -prices[i];<br>            <span class="hljs-comment">//解释：</span><br>            <span class="hljs-comment">//   dp[i][1] </span><br>            <span class="hljs-comment">// = max(dp[-1][1], dp[-1][0] - prices[i])</span><br>            <span class="hljs-comment">// = max(-infinity, 0 - prices[i]) </span><br>            <span class="hljs-comment">// = -prices[i]</span><br>            <span class="hljs-keyword">continue</span>;<br>     	&#125;<br>         dp[i][<span class="hljs-number">0</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>],dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i]);<br>         dp[i][<span class="hljs-number">1</span>] = Math.max(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>],-prices[i]);<br>     &#125;<br>	<span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>优化空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// k == 1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit_k_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = prices.length;<br>    <span class="hljs-comment">// base case: dp[-1][0] = 0, dp[-1][1] = -infinity</span><br>    <span class="hljs-keyword">int</span> dp_i_0 = <span class="hljs-number">0</span>, dp_i_1 = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span><br>        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);<br>        <span class="hljs-comment">// dp[i][1] = max(dp[i-1][1], -prices[i])</span><br>        dp_i_1 = Math.max(dp_i_1, -prices[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i_0;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一次遍历的方法，依次遍历，假定每天尝试卖出，搜索当前天之前的历史最低价格</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> prices[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> minprice = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">int</span> maxprofit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>    	<span class="hljs-keyword">if</span> (prices[i] &lt; minprice) &#123;<br>    		minprice = prices[i];<br>    	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prices[i] - minprice &gt; maxprofit) &#123;<br>    		maxprofit = prices[i] - minprice;<br>   		&#125;<br>    &#125;<br>	<span class="hljs-keyword">return</span> maxprofit;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-11-打家劫舍"><a href="#6-11-打家劫舍" class="headerlink" title="6.11 打家劫舍"></a>6.11 打家劫舍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] memo;<br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化备忘录</span><br>    memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 强盗从第 0 间房子开始抢劫</span><br>    <span class="hljs-keyword">return</span> dp(nums, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 返回 dp[start..] 能抢到的最大值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt;= nums.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 避免重复计算</span><br>    <span class="hljs-keyword">if</span> (memo[start] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[start];<br><br>    <span class="hljs-keyword">int</span> res = Math.max(dp(nums, start + <span class="hljs-number">1</span>), <br>                    nums[start] + dp(nums, start + <span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 记入备忘录</span><br>    memo[start] = res;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-12-爬楼梯"><a href="#6-12-爬楼梯" class="headerlink" title="6.12 爬楼梯"></a>6.12 爬楼梯</h2><p>自顶向下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> memo[];<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> dp(memo,n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] memo,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)&#123;<br>        memo[n] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> memo[n];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(memo[n] &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> memo[n];<br>    &#125;<br>    memo[n] = dp(memo,n - <span class="hljs-number">1</span>) + dp(memo,n - <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> memo[n];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>自底向上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">//base case</span><br>    <span class="hljs-keyword">int</span> dp0 = <span class="hljs-number">1</span>,dp1 = <span class="hljs-number">1</span>,dp2 = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//状态转移</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n + <span class="hljs-number">1</span>; i++)&#123;<br>        dp2 = dp0 + dp1;<br>        dp0 = dp1;<br>        dp1 = dp2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp2;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-13-最小路径和"><a href="#6-13-最小路径和" class="headerlink" title="6.13 最小路径和"></a>6.13 最小路径和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> m = grid.length,n = grid[<span class="hljs-number">0</span>].length;<br>       <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br><br>       <span class="hljs-comment">//base case</span><br>       dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>           dp[i][<span class="hljs-number">0</span>] = grid[i][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]; <br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>           dp[<span class="hljs-number">0</span>][j] = grid[<span class="hljs-number">0</span>][j] + dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>]; <br>       &#125;<br>       <span class="hljs-comment">//状态转移</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>               dp[i][j] = Math.min(dp[i - <span class="hljs-number">1</span>][j],dp[i][j - <span class="hljs-number">1</span>]) + grid[i][j]; <br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>   &#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-14-单词拆分"><a href="#6-14-单词拆分" class="headerlink" title="6.14 单词拆分"></a>6.14 单词拆分</h2><p>完全背包问题</p>
<p>wordDict是物品列表，且可以无限使用，非空字符串s是背包。</p>
<p>$dp[i]$为true代表以i结尾的s子串可以拆分为一个或多个在字典中出现的单词。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;<br>    Set&lt;String&gt; wordDictSet = <span class="hljs-keyword">new</span> HashSet(wordDict);<br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">boolean</span> dp[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-comment">//base case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">//状态转移</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">if</span>(dp[j] &amp;&amp; wordDictSet.contains(s.substring(j,i)))&#123;<br>                dp[i] = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-15-乘积最大子数组"><a href="#6-15-乘积最大子数组" class="headerlink" title="6.15 乘积最大子数组"></a>6.15 乘积最大子数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> n = nums.length;<br>     <span class="hljs-keyword">int</span> res = Integer.MIN_VALUE;<br>     <span class="hljs-keyword">int</span> dpMax = <span class="hljs-number">1</span>,dpMin = <span class="hljs-number">1</span>;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>         <span class="hljs-keyword">if</span>(nums[i] &lt; <span class="hljs-number">0</span>)&#123;<br>             <span class="hljs-keyword">int</span> temp = dpMax;<br>             dpMax = dpMin;<br>             dpMin = temp;<br>         &#125;<br>         dpMax = Math.max(dpMax * nums[i],nums[i]);<br>         dpMin = Math.min(dpMin * nums[i],nums[i]);<br>     <br>         res = Math.max(dpMax,res);<br>     &#125;<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-16-最大正方形"><a href="#6-16-最大正方形" class="headerlink" title="6.16 最大正方形"></a>6.16 最大正方形</h2><p>可以使用动态规划降低时间复杂度。我们用$ \textit{dp}(i, j)$ 表示以 $(i, j)$ 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 $\textit{dp}(i, j)$ 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p>
<p>那么如何计算 $\textit{dp}$ 中的每个元素值呢？对于每个位置 $(i, j)$，检查在矩阵中该位置的值：</p>
<p>如果该位置的值是 0，则 $\textit{dp}(i, j) = 0$，因为当前位置不可能在由 1 组成的正方形中；</p>
<p>如果该位置的值是 1，则 $\textit{dp}(i, j)$的值由其上方、左方和左上方的三个相邻位置的$ \textit{dp}$ 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p>
<script type="math/tex; mode=display">
dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1</script><p>先来阐述简单共识</p>
<p>若形成正方形（非单 1），以当前为右下角的视角看，则需要：当前格、上、左、左上都是 1<br>可以换个角度：当前格、上、左、左上都不能受 0 的限制，才能成为正方形</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/最大正方形状态转移.png" srcset="/img/loading.gif" style="zoom:67%;" /></p>
<p>上面详解了 三者取最小 的含义：</p>
<p>图 1：受限于左上的 0<br>图 2：受限于上边的 0<br>图 3：受限于左边的 0<br>数字表示：以此为正方形右下角的最大边长<br>黄色表示：格子 ? 作为右下角的正方形区域<br>就像 木桶的短板理论 那样——附近的最小边长，才与 ? 的最长边长有关。</p>
<ul>
<li>从上述图解中，我们似乎得到的只是「动态规划 推进 的过程」，即「如何从前面的 dp 推出后面的 dp」，甚至还只是感性理解</li>
<li>距离代码我们还缺：dp 具体定义如何，数组多大，初值如何，如何与题目要求的面积相关</li>
<li>dp 具体定义：$dp[i + 1][j + 1]$ 表示 「以第 i 行、第 j 列为右下角的正方形的最大边长」<ul>
<li>为何不是 $dp[i][j]$</li>
<li>回到图解中，任何一个正方形，我们都「依赖」当前格 左、上、左上三个方格的情况</li>
<li>但第一行的上层已经没有格子，第一列左边已经没有格子，需要做特殊 if 判断来处理</li>
<li>为了代码简洁，我们 假设补充 了多一行全 ‘0’、多一列全 ‘0’</li>
</ul>
</li>
</ul>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/035ec1919a802f81078ce40bde8c33d6c0990b486ce3aebd846d1fdf79241221-image.png" srcset="/img/loading.gif" alt=""></p>
<ul>
<li>此时 dp 数组的大小也明确为$ new dp[height + 1][width + 1]$</li>
<li>初始值就是将第一列 $dp[row][0] $、第一行$ dp[0][col] $都赋为 0，相当于已经计算了所有的第一行、第一列的 dp 值</li>
<li>题目要求面积。根据 「面积 = 边长 x 边长」可知，我们只需求出 最大边长 即可<ul>
<li>定义 maxSide 表示最长边长，每次得出一个 dp，就 maxSide = max(maxSide, dp);</li>
<li>最终返回 return maxSide * maxSide;</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-comment">// base condition</span><br>    <span class="hljs-keyword">if</span> (matrix == <span class="hljs-keyword">null</span> || matrix.length &lt; <span class="hljs-number">1</span> || matrix[<span class="hljs-number">0</span>].length &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">int</span> height = matrix.length;<br>    <span class="hljs-keyword">int</span> width = matrix[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">int</span> maxSide = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 相当于已经预处理新增第一行、第一列均为0</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[height + <span class="hljs-number">1</span>][width + <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; height; row++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; width; col++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[row][col] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                dp[row + <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>] = Math.min(Math.min(dp[row + <span class="hljs-number">1</span>][col], dp[row][col + <span class="hljs-number">1</span>]), dp[row][col]) + <span class="hljs-number">1</span>;<br>                maxSide = Math.max(maxSide, dp[row + <span class="hljs-number">1</span>][col + <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSide * maxSide;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-17-完全平方数"><a href="#6-17-完全平方数" class="headerlink" title="6.17 完全平方数"></a>6.17 完全平方数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        dp[i] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;i - j*j &gt;=<span class="hljs-number">0</span>; j++)&#123;<br>            dp[i] = Math.min(dp[i - j * j] + <span class="hljs-number">1</span>,dp[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-18-比特位计数"><a href="#6-18-比特位计数" class="headerlink" title="6.18 比特位计数"></a>6.18 比特位计数</h2><p>对于所有的数字，只有两类：</p>
<p>奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。<br>          举例：<br>         0 = 0       1 = 1<br>         2 = 10      3 = 11<br>偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。<br>           举例：<br>          2 = 10       4 = 100       8 = 1000<br>          3 = 11       6 = 110       12 = 1100<br>另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> num) &#123;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num + <span class="hljs-number">1</span>];<br>    res[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            res[i] = res[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res[i] = res[i / <span class="hljs-number">2</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-19-正则表达式匹配"><a href="#6-19-正则表达式匹配" class="headerlink" title="6.19 正则表达式匹配"></a>6.19 正则表达式匹配</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    <span class="hljs-comment">//s待匹配，p是正则</span><br>    <span class="hljs-keyword">int</span> n = s.length();<br>    <span class="hljs-keyword">int</span> m = p.length();<br>    <span class="hljs-keyword">boolean</span>[][] dp= <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;= m; j++)&#123;<br>            <span class="hljs-comment">//空正则</span><br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)&#123;<br>                dp[i][j] = i == <span class="hljs-number">0</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//非空正则 两种情况*和非*</span><br>                <span class="hljs-keyword">if</span> (p.charAt(j-<span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s.charAt(i-<span class="hljs-number">1</span>) == p.charAt(j-<span class="hljs-number">1</span>) || p.charAt(j-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))&#123;<br>                        dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//遇到*，分为看和不看</span><br>                    <span class="hljs-comment">//看</span><br>                    <span class="hljs-keyword">if</span> (i &gt;=<span class="hljs-number">1</span> &amp;&amp; j&gt;=<span class="hljs-number">2</span> &amp;&amp;(s.charAt(i-<span class="hljs-number">1</span>) == p.charAt(j-<span class="hljs-number">2</span>) || p.charAt(j-<span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))&#123;<br>                        dp[i][j] |= dp[i-<span class="hljs-number">1</span>][j];<br>                    &#125;<br>                    <span class="hljs-comment">//不看</span><br>                    <span class="hljs-keyword">if</span> (j&gt;=<span class="hljs-number">2</span>)&#123;<br>                        dp[i][j] |= dp[i][j-<span class="hljs-number">2</span>];<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n][m];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-20-最长有效括号"><a href="#6-20-最长有效括号" class="headerlink" title="6.20 最长有效括号"></a>6.20 最长有效括号</h2><p>​        我们定义$ \textit{dp}[i]$ 表示以下标 i 字符结尾的最长有效括号的长度。我们将 $\textit{dp}$ 数组全部初始化为 0 。显然有效的子串一定以 $\text{‘)’}$ 结尾，因此我们可以知道以 $\text{‘(’}$结尾的子串对应的 $\textit{dp}$ 值必定为 0 ，我们只需要求解 $\text{‘)’}$ 在 $\textit{dp}$ 数组中对应位置的值。</p>
<p>我们从前往后遍历字符串求解 $\textit{dp}$ 值，我们每两个字符检查一次：</p>
<p>$s[i] = \text{‘)’}$ 且 $s[i - 1] = \text{‘(’}$，也就是字符串形如 “……()”，我们可以推出：</p>
<p>$\textit{dp}[i]=\textit{dp}[i-2]+2$</p>
<p>我们可以进行这样的转移，是因为结束部分的 “()” 是一个有效子字符串，并且将之前有效子字符串的长度增加了2 。</p>
<p>$s[i] = \text{‘)’}$且$ s[i - 1] = \text{‘)’}$，也就是字符串形如 “……))”，我们可以推出：<br>如果$ s[i - \textit{dp}[i - 1] - 1] = \text{‘(’}$，那么</p>
<script type="math/tex; mode=display">
\textit{dp}[i]=\textit{dp}[i-1]+\textit{dp}[i-\textit{dp}[i-1]-2]+2</script><p>我们考虑如果倒数第二个 $\text{‘)’}$是一个有效子字符串的一部分（记作$sub_s$），对于最后一个 $\text{‘)’}$ ，如果它是一个更长子字符串的一部分，那么它一定有一个对应的 $\text{‘(’}$，且它的位置在倒数第二个 $\text{‘)’}$ 所在的有效子字符串的前面（也就是 $sub_s$的前面）。因此，如果子字符串 $sub_s$的前面恰好是 $\text{‘(’}$ ，那么我们就用 2 加上$ sub_s$的长度$（\textit{dp}[i-1]）$去更新 $\textit{dp}[i]$。同时，我们也会把有效子串 $“(sub_s)”$之前的有效子串的长度也加上，也就是再加上 $\textit{dp}[i-\textit{dp}[i-1]-2]$。</p>
<p>最后的答案即为 $\textit{dp}$ 数组中的最大值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s.length()];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.length(); i++)&#123;<br>        <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                dp[i] = (i &gt;= <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i - dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + ((i - dp[i - <span class="hljs-number">1</span>]) &gt;= <span class="hljs-number">2</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        res = Math.max(res, dp[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-21-接雨水"><a href="#6-21-接雨水" class="headerlink" title="6.21 接雨水"></a>6.21 接雨水</h2><p>当前位置接水=min(right_max,left_max) - height[i]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span>(height == <span class="hljs-keyword">null</span> || height.length == <span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>     &#125;<br>     <span class="hljs-keyword">int</span> n = height.length;<br>     <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">int</span>[] left_max = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>     <span class="hljs-keyword">int</span>[] right_max = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>     left_max[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>];<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>         left_max[i] = Math.max(left_max[i - <span class="hljs-number">1</span>], height[i]);<br>     &#125;<br>     right_max[n - <span class="hljs-number">1</span>] = height[n - <span class="hljs-number">1</span>];<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; j--)&#123;<br>         right_max[j] = Math.max(right_max[j + <span class="hljs-number">1</span>], height[j]);<br>     &#125;<br>     <span class="hljs-comment">//第一个和最后一个不能装水</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; n - <span class="hljs-number">1</span>; k++)&#123;<br>         res += Math.min(left_max[k], right_max[k]) - height[k];<br>     &#125;<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-22-戳气球"><a href="#6-22-戳气球" class="headerlink" title="6.22 戳气球"></a>6.22 戳气球</h2><p>添加虚拟气球和寻找状态选择是重点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">//在nums两侧添加虚拟气球构成新数组</span><br>    <span class="hljs-keyword">int</span>[] points = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">2</span>];<br>    points[<span class="hljs-number">0</span>] = points[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;    <br>        points[i] = nums[i - <span class="hljs-number">1</span>];<br>    &#125; <br>    <span class="hljs-comment">//dp[i][j]代表(i,j)获得硬币最大数量</span><br>    <span class="hljs-comment">//base case 初始化0</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">2</span>][n + <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n + <span class="hljs-number">2</span>; j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++)&#123;<br>                dp[i][j] = Math.max(<br>                    dp[i][j],<br>                    dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="6-23-跳跃游戏"><a href="#6-23-跳跃游戏" class="headerlink" title="6.23 跳跃游戏"></a>6.23 跳跃游戏</h2><p> 贪心问题</p>
<p>遍历每个位置，若当前位置可到达，则根据当前位置i和nums[i]更新覆盖范围</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> mostLength = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i &lt;= mostLength)&#123;<br>            mostLength = Math.max(mostLength, nums[i] + i);<br>            <span class="hljs-keyword">if</span>(mostLength &gt;= n - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="7-回溯"><a href="#7-回溯" class="headerlink" title="7. 回溯"></a>7. 回溯</h1><h2 id="7-1-全排列"><a href="#7-1-全排列" class="headerlink" title="7.1 全排列"></a>7.1 全排列</h2><p>选择LinkedList是因为要在链表尾频繁操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br> <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>     LinkedList&lt;Integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>     backtrack(nums, track);<br>     <span class="hljs-keyword">return</span> res;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span></span>&#123;<br>     <span class="hljs-comment">//结束条件</span><br>     <span class="hljs-keyword">if</span>(track.size() == nums.length)&#123;<br>         res.add(<span class="hljs-keyword">new</span> LinkedList(track));<br>         <span class="hljs-keyword">return</span>;<br>     &#125;<br><br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>         <span class="hljs-comment">//不满足条件</span><br>         <span class="hljs-keyword">if</span>(track.contains(nums[i]))&#123;<br>             <span class="hljs-keyword">continue</span>;<br>         &#125;<br>         <span class="hljs-comment">//做选择</span><br>         track.add(nums[i]);<br>         backtrack(nums,track);<br>         track.removeLast();<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<h2 id="7-2-子集"><a href="#7-2-子集" class="headerlink" title="7.2 子集"></a>7.2 子集</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-comment">// 记录走过的路径</span><br>    LinkedList&lt;Integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    backtrack(nums, <span class="hljs-number">0</span>, track);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> start, LinkedList&lt;Integer&gt; track)</span> </span>&#123;<br>    res.add(<span class="hljs-keyword">new</span> LinkedList(track));<br>    <span class="hljs-comment">// 注意 i 从 start 开始递增</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; nums.length(); i++) &#123;<br>        <span class="hljs-comment">// 做选择</span><br>        track.add(nums[i]);<br>        <span class="hljs-comment">// 回溯</span><br>        backtrack(nums, i + <span class="hljs-number">1</span>, track);<br>        <span class="hljs-comment">// 撤销选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="7-3-括号生成"><a href="#7-3-括号生成" class="headerlink" title="7.3 括号生成"></a>7.3 括号生成</h2><p>两个规则：</p>
<ul>
<li>一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解。</li>
<li>对于一个「合法」的括号字符串组合 <code>p</code>，必然对于任何 <code>0 &lt;= i &lt; len(p)</code> 都有：子串 <code>p[0..i]</code> 中左括号的数量都大于或等于右括号的数量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">//结果数组</span><br>    LinkedList&lt;String&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">//回溯路径</span><br>    StringBuilder track = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-comment">// 可用的左括号和右括号数量初始化为 n</span><br>    backtrack(n, n, track, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, StringBuilder track, LinkedList&lt;String&gt; res)</span></span>&#123;<br>    <span class="hljs-comment">//剩下可用左括号多，不合法</span><br>    <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//剩余可用&lt;0,不合法</span><br>    <span class="hljs-keyword">if</span>(left &lt; <span class="hljs-number">0</span> || right &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//剩余括号正好为0合法</span><br>    <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>)&#123;<br>        String s = track.toString();<br>        res.add(s);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//放左括号</span><br>    track.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>    backtrack(left - <span class="hljs-number">1</span>, right, track, res);<br>    track.deleteCharAt(track.length() - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//放右括号</span><br>    track.append(<span class="hljs-string">&#x27;)&#x27;</span>);<br>    backtrack(left, right - <span class="hljs-number">1</span>, track, res);<br>    track.deleteCharAt(track.length() - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="7-4-电话号码的字母组合"><a href="#7-4-电话号码的字母组合" class="headerlink" title="7.4 电话号码的字母组合"></a>7.4 电话号码的字母组合</h2><p>借鉴子集思路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(String digits)</span> </span>&#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    <span class="hljs-keyword">if</span> (digits.length() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    Map&lt;Character, String&gt; phoneMap = <span class="hljs-keyword">new</span> HashMap&lt;Character, String&gt;() &#123;&#123;<br>        put(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&quot;abc&quot;</span>);<br>        put(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;def&quot;</span>);<br>        put(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&quot;ghi&quot;</span>);<br>        put(<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br>        put(<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&quot;mno&quot;</span>);<br>        put(<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>);<br>        put(<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&quot;tuv&quot;</span>);<br>        put(<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>);<br>    &#125;&#125;;<br>    StringBuilder track = <span class="hljs-keyword">new</span> StringBuilder();<br>    backtrack(res, track, digits, <span class="hljs-number">0</span>, phoneMap);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(List&lt;String&gt; res, StringBuilder track, String digits, <span class="hljs-keyword">int</span> index, Map&lt;Character, String&gt; phoneMap)</span></span>&#123;<br><br>    <span class="hljs-keyword">if</span>(index == digits.length())&#123;<br>        String s = track.toString();<br>        res.add(s);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    String s = phoneMap.get(digits.charAt(index));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++)&#123;<br>        track.append(s.charAt(i));<br>        backtrack(res, track, digits, index + <span class="hljs-number">1</span>, phoneMap);<br>        track.deleteCharAt(track.length() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="7-5-组合总和"><a href="#7-5-组合总和" class="headerlink" title="7.5 组合总和"></a>7.5 组合总和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>    List&lt;Integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    backtrack(candidates, target, track, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target, List&lt;Integer&gt; track, <span class="hljs-keyword">int</span> index)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(index == candidates.length)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;<br>        res.add(<span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//不选当前数</span><br>    backtrack(candidates, target, track, index + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//选择当前数，需要判断+回溯</span><br>    <span class="hljs-keyword">if</span>(target - candidates[index] &gt;= <span class="hljs-number">0</span>)&#123;<br>        track.add(candidates[index]);<br>        backtrack(candidates, target - candidates[index], track, index);<br>        track.remove(track.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="7-6-单词搜索"><a href="#7-6-单词搜索" class="headerlink" title="7.6 单词搜索"></a>7.6 单词搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.length; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].length; j++)&#123;<br>            <span class="hljs-keyword">if</span>(dfs(board, word, <span class="hljs-number">0</span>, i, j))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br><br>    <span class="hljs-keyword">if</span>(index == word.length())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(i &gt;= board.length || i &lt; <span class="hljs-number">0</span> || j &gt;= board[<span class="hljs-number">0</span>].length <br>    || j &lt; <span class="hljs-number">0</span>|| board[i][j] != word.charAt(index))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(board[i][j] == word.charAt(index))&#123;<br>        <span class="hljs-keyword">char</span> tmp = board[i][j];<br>        <span class="hljs-comment">//选择</span><br>        board[i][j] = <span class="hljs-string">&#x27;/&#x27;</span>;<br>        <span class="hljs-comment">//递归</span><br>        <span class="hljs-keyword">if</span>(dfs(board, word, index + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, j) || dfs(board, word, index + <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>, j)<br>        || dfs(board, word, index + <span class="hljs-number">1</span>, i, j + <span class="hljs-number">1</span>) ||  dfs(board, word, index + <span class="hljs-number">1</span>, i, j - <span class="hljs-number">1</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        board[i][j] = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="7-7-岛屿数量"><a href="#7-7-岛屿数量" class="headerlink" title="7.7 岛屿数量"></a>7.7 岛屿数量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(dfs(grid, i, j))&#123;<br>                res++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= grid.length || j &lt; <span class="hljs-number">0</span> || j &gt;= grid[<span class="hljs-number">0</span>].length || grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>    dfs(grid, i + <span class="hljs-number">1</span>, j);<br>    dfs(grid, i - <span class="hljs-number">1</span>, j);<br>    dfs(grid, i, j + <span class="hljs-number">1</span>);<br>    dfs(grid, i, j - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="7-8-课程表"><a href="#7-8-课程表" class="headerlink" title="7.8 课程表"></a>7.8 课程表</h2><p>我们可以将深度优先搜索的流程与拓扑排序的求解联系起来，用一个栈来存储所有已经搜索完成的节点。</p>
<p>对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 u 的时候，u 本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。</p>
<p>假设我们当前搜索到了节点 u，如果它的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时我们就可以把 u 入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 u 处于栈顶的位置，那么 u 出现在所有 u 的相邻节点的前面。因此对于 u 这个节点而言，它是满足拓扑排序的要求的。</p>
<p>这样以来，我们对图进行一遍深度优先搜索。当每个节点进行回溯的时候，我们把该节点放入栈中。最终从栈顶到栈底的序列就是一种拓扑排序。</p>
<p>算法</p>
<p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p>
<ul>
<li>「未搜索」：我们还没有搜索到这个节点；</li>
<li>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</li>
<li>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</li>
</ul>
<p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p>
<p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p>
<p>如果 v为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p>
<p>如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p>
<p>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。</p>
<p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p>
<p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">//edges是邻接表</span><br>List&lt;List&lt;Integer&gt;&gt; edges;<br>   <span class="hljs-keyword">int</span>[] visited;<br>   <span class="hljs-keyword">boolean</span> valid = <span class="hljs-keyword">true</span>;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites)</span> </span>&#123;<br>       edges = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++)&#123;<br>           edges.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;());<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num[] : prerequisites)&#123;<br>           edges.get(num[<span class="hljs-number">1</span>]).add(num[<span class="hljs-number">0</span>]);<br>       &#125;<br>       visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses &amp;&amp; valid; i++)&#123;<br>           <span class="hljs-keyword">if</span>(visited[i] == <span class="hljs-number">0</span>)&#123;<br>               dfs(i);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> valid;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>       visited[k] = <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : edges.get(k))&#123;<br>           <span class="hljs-keyword">if</span>(visited[i] == <span class="hljs-number">0</span>)&#123;<br>               dfs(i);<br>               <span class="hljs-keyword">if</span>(!valid)&#123;<br>                   <span class="hljs-keyword">return</span>;<br>               &#125;<br>           &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(visited[i] == <span class="hljs-number">1</span>)&#123;<br>               valid = <span class="hljs-keyword">false</span>;<br>               <span class="hljs-keyword">return</span>;<br>           &#125;<br>       &#125;<br>       visited[k] = <span class="hljs-number">2</span>;<br>   &#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="7-9-删除无效括号"><a href="#7-9-删除无效括号" class="headerlink" title="7.9 删除无效括号"></a>7.9 删除无效括号</h2><p>先遍历计算出需要删除得左括号和右括号个数，再递归尝试可能得结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> len;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] charArray;<br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; validExpressions = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">removeInvalidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.len = s.length();<br>        <span class="hljs-keyword">this</span>.charArray = s.toCharArray();<br><br>        <span class="hljs-comment">// 第 1 步：遍历一次，计算多余的左右括号</span><br>        <span class="hljs-keyword">int</span> leftRemove = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> rightRemove = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">if</span> (charArray[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                leftRemove++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (charArray[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-comment">// 遇到右括号的时候，须要根据已经存在的左括号数量决定</span><br>                <span class="hljs-keyword">if</span> (leftRemove == <span class="hljs-number">0</span>) &#123;<br>                    rightRemove++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (leftRemove &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 关键：一个右括号出现可以抵销之前遇到的左括号</span><br>                    leftRemove--;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 第 2 步：回溯算法，尝试每一种可能的删除操作</span><br>        StringBuilder path = <span class="hljs-keyword">new</span> StringBuilder();<br>        dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, leftRemove, rightRemove, path);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.validExpressions);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index       当前遍历到的下标</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> leftCount   已经遍历到的左括号的个数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rightCount  已经遍历到的右括号的个数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> leftRemove  最少应该删除的左括号的个数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rightRemove 最少应该删除的右括号的个数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path        一个可能的结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> leftCount, <span class="hljs-keyword">int</span> rightCount, <span class="hljs-keyword">int</span> leftRemove, <span class="hljs-keyword">int</span> rightRemove, StringBuilder path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == len) &#123;<br>            <span class="hljs-keyword">if</span> (leftRemove == <span class="hljs-number">0</span> &amp;&amp; rightRemove == <span class="hljs-number">0</span>) &#123;<br>                validExpressions.add(path.toString());<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">char</span> character = charArray[index];<br>        <span class="hljs-comment">// 可能的操作 1：删除当前遍历到的字符</span><br>        <span class="hljs-keyword">if</span> (character == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; leftRemove &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 由于 leftRemove &gt; 0，并且当前遇到的是左括号，因此可以尝试删除当前遇到的左括号</span><br>            dfs(index + <span class="hljs-number">1</span>, leftCount, rightCount, leftRemove - <span class="hljs-number">1</span>, rightRemove, path);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (character == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; rightRemove &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 由于 rightRemove &gt; 0，并且当前遇到的是右括号，因此可以尝试删除当前遇到的右括号</span><br>            dfs(index + <span class="hljs-number">1</span>, leftCount, rightCount, leftRemove, rightRemove - <span class="hljs-number">1</span>, path);<br>        &#125;<br><br>        <span class="hljs-comment">// 可能的操作 2：保留当前遍历到的字符</span><br>        <span class="hljs-comment">// 做选择</span><br>        path.append(character);<br>        <span class="hljs-comment">//递归</span><br>        <span class="hljs-keyword">if</span> (character != <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; character != <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 如果不是括号，继续深度优先遍历</span><br>            dfs(index + <span class="hljs-number">1</span>, leftCount, rightCount, leftRemove, rightRemove, path);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (character == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 考虑左括号</span><br>            dfs(index + <span class="hljs-number">1</span>, leftCount + <span class="hljs-number">1</span>, rightCount, leftRemove, rightRemove, path);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightCount &lt; leftCount) &#123;<br>            <span class="hljs-comment">// 考虑右括号</span><br>            dfs(index + <span class="hljs-number">1</span>, leftCount, rightCount + <span class="hljs-number">1</span>, leftRemove, rightRemove, path);<br>        &#125;<br>        <span class="hljs-comment">//撤销选择</span><br>        path.deleteCharAt(path.length() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="8-位运算"><a href="#8-位运算" class="headerlink" title="8. 位运算"></a>8. 位运算</h1><h2 id="8-1-只出现一次的数字"><a href="#8-1-只出现一次的数字" class="headerlink" title="8.1 只出现一次的数字"></a>8.1 只出现一次的数字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        res ^= num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="8-2-汉明距离"><a href="#8-2-汉明距离" class="headerlink" title="8.2 汉明距离"></a>8.2 汉明距离</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> z = x ^ y;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(z != <span class="hljs-number">0</span>)&#123;<br>        z = z &amp; (z - <span class="hljs-number">1</span>);<br>        count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="9-字符串"><a href="#9-字符串" class="headerlink" title="9. 字符串"></a>9. 字符串</h1><h2 id="9-1-字母异位词分组"><a href="#9-1-字母异位词分组" class="headerlink" title="9.1 字母异位词分组"></a>9.1 字母异位词分组</h2><p>ArrayList构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList(Collection&lt;? extends E&gt; c)<br>构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。<br></code></pre></td></tr></table></figure>
<p>HashMap values方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;V&gt; <span class="hljs-title">values</span><span class="hljs-params">()</span></span><br><span class="hljs-function">返回此映射所包含的值的 Collection 视图。</span><br></code></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;<br>    HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span>(String str : strs)&#123;<br>        <span class="hljs-keyword">char</span>[] array = str.toCharArray();<br>        Arrays.sort(array);<br>        String key = <span class="hljs-keyword">new</span> String(array);<br>        List&lt;String&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;());<br>        list.add(str);<br>        map.put(key, list);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(map.values());<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="10-设计"><a href="#10-设计" class="headerlink" title="10. 设计"></a>10. 设计</h1><h2 id="10-1-LRU缓存机制"><a href="#10-1-LRU缓存机制" class="headerlink" title="10.1 LRU缓存机制"></a>10.1 LRU缓存机制</h2><p>LRU算法的实现依赖于LinkedListHashMap的结构，要明白为什么使用LinkedHashMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> cap;<br>LinkedHashMap&lt;Integer, Integer&gt; cache = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.cap = capacity;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!cache.containsKey(key)) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将 key 变为最近使用</span><br>    makeRecently(key);<br>    <span class="hljs-keyword">return</span> cache.get(key);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(cache.containsKey(key))&#123;<br>        cache.put(key, value);<br>        makeRecently(key);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cache.size() &gt;= <span class="hljs-keyword">this</span>.cap)&#123;<br>        <span class="hljs-comment">//删除最久未使用元素</span><br>        <span class="hljs-keyword">int</span> oldKey = cache.keySet().iterator().next();<br>        cache.remove(oldKey);<br>    &#125;<br>    cache.put(key, value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRecently</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> value = cache.get(key);<br>    cache.remove(key);<br>    cache.put(key, value);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="10-2-实现Tire-前缀树"><a href="#10-2-实现Tire-前缀树" class="headerlink" title="10.2 实现Tire(前缀树)"></a>10.2 实现Tire(前缀树)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br><br>    <span class="hljs-keyword">boolean</span> isEnd = <span class="hljs-keyword">false</span>;<br>    Trie[] next = <span class="hljs-keyword">new</span> Trie[<span class="hljs-number">26</span>];<br>    <br><br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>    <br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Trie root = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">char</span>[] chars = word.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)&#123;<br>                root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> Trie();<br>            &#125;<br>            root = root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        root.isEnd = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if the word is in the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Trie root = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">char</span>[] chars = word.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            root = root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> root.isEnd;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>        Trie root = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">char</span>[] chars = prefix.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            root = root.next[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="11-并查集"><a href="#11-并查集" class="headerlink" title="11. 并查集"></a>11. 并查集</h1><h2 id="11-1-除法求值"><a href="#11-1-除法求值" class="headerlink" title="11.1 除法求值"></a>11.1 除法求值</h2><p>这个题应该被列为hard，先copy</p>
<p>​        这道题是在「力扣」第 990 题（等式方程的可满足性）的基础上，在变量和变量之间有了倍数关系。由于变量之间的倍数关系具有传递性，处理有传递性关系的问题，可以使用「并查集」，我们需要在并查集的「合并」与「查询」操作中 维护这些变量之间的倍数关系。</p>
<p>​        说明：请注意题目中的「注意」和「数据范围」，例如：每个 Ai 或 Bi 是一个表示单个变量的字符串。所以用例 equation = [“ab”, “cd”] ，这里的 ab 视为一个变量，不表示 a * b。如果面试中遇到这样的问题，一定要和面试官确认清楚题目的条件。还有 1 &lt;= equations.length &lt;= 20 和 values[i] &gt; 0.0 可以避免一些特殊情况的讨论。</p>
<p><strong>方法：并查集</strong></p>
<p>分析示例 1：</p>
<p>a / b = 2.0 说明 a = 2b， a 和 b 在同一个集合中；</p>
<p>b / c = 3.0 说明 b = 3c ，b 和 c 在同一个集合中。</p>
<p>求 $\cfrac{a}{c}$   ，可以把 a = 2b，b=3c 依次代入，得到 $\cfrac{a}{c} = \cfrac{2b} {c} = \cfrac{2 \cdot 3c} {c} = 6.0$<br>求$\cfrac{b}{a}$，很显然根据 a = 2b，知道 $\cfrac{b}{a} = 0.5$ ，也可以把 b 和 a 都转换成为 c 的倍数，$\cfrac{b}{a} = \cfrac{b} {2b} = \cfrac{3c} {6c} = \cfrac{1}{2} = 0.5 $</p>
<p>​        我们计算了两个结果，不难知道：可以将题目给出的 equation 中的两个变量所在的集合进行「合并」，同在一个集合中的两个变量就可以通过某种方式计算出它们的比值。具体来说，可以把 不同的变量的比值转换成为相同的变量的比值，这样在做除法的时候就可以消去相同的变量，然后再计算转换成相同变量以后的系数的比值，就是题目要求的结果。统一了比较的标准，可以以 O(1)的时间复杂度完成计算。</p>
<p>​        如果两个变量不在同一个集合中， 返回 −1.0。并且根据题目的意思，如果两个变量中 至少有一个 变量没有出现在所有 equations 出现的字符集合中，也返回 -1.0。</p>
<p><strong>构建有向图</strong></p>
<p>​        通过例 1 的分析，我们就知道了，题目给出的 equations 和 values 可以表示成一个图，equations 中出现的变量就是图的顶点，「分子」于「分母」的比值可以表示成一个有向关系（因为「分子」和「分母」是有序的，不可以对换），并且这个图是一个带权图，values 就是对应的有向边的权值。例 1 中给出的 equations 和 values 表示的「图形表示」、「数学表示」和「代码表示」如下表所示。其中 parent[a] = b 表示：结点 a 的（直接）父亲结点是 b，与之对应的有向边的权重，记为 weight[a] = 2.0，即 weight[a] 表示结点 a 到它的 直接父亲结点 的有向边的权重。</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值.png" srcset="/img/loading.gif" alt="除法求值" style="zoom:50%;" /></p>
<p><strong>「统一变量」与「路径压缩」的关系</strong></p>
<p>​        刚刚在分析例 1 的过程中，提到了：可以把一个一个 query 中的不同变量转换成 同一个变量，这样在计算 query 的时候就可以以 O(1)的时间复杂度计算出结果，在「并查集」的一个优化技巧中，「路径压缩」就恰好符合了这样的应用场景。</p>
<p>​        为了避免并查集所表示的树形结构高度过高，影响查询性能。「路径压缩」就是针对树的高度的优化。「路径压缩」的效果是：在查询一个结点 a 的根结点同时，把结点 a 到根结点的沿途所有结点的父亲结点都指向根结点。如下图所示，除了根结点以外，所有的结点的父亲结点都指向了根结点。特别地，也可以认为根结点的父亲结点就是根结点自己。如下国所示：路径压缩前后，并查集所表示的两棵树形结构等价，路径压缩以后的树的高度为 2，查询性能最好。</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值1.png" srcset="/img/loading.gif" alt="除法求值1" style="zoom:50%;" /></p>
<p>​        由于有「路径压缩」的优化，两个同在一个连通分量中的不同的变量，它们分别到根结点（父亲结点）的权值的比值，就是题目的要求的结果。</p>
<p><strong>如何在「查询」操作的「路径压缩」优化中维护权值变化</strong></p>
<p>​    如下图所示，我们在结点 a 执行一次「查询」操作。路径压缩会先一层一层向上先找到根结点 d，然后依次把 c、b 、a 的父亲结点指向根结点 d。</p>
<ul>
<li>c 的父亲结点已经是根结点了，它的权值不用更改；</li>
<li>b 的父亲结点要修改成根结点，它的权值就是从当前结点到根结点经过的所有有向边的权值的乘积，因此是 3.0 乘以 4.0 也就是 12.0；</li>
<li>a 的父亲结点要修改成根结点，它的权值就是依然是从当前结点到根结点经过的所有有向边的权值的乘积，但是我们 没有必要把这三条有向边的权值乘起来，这是因为 b 到 c，c 到 d 这两条有向边的权值的乘积，我们在把 b 指向 d 的时候已经计算出来了。因此，a 到根结点的权值就等于 b 到根结点 d 的新的权值乘以 a 到 b 的原来的有向边的权值。</li>
</ul>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值2.png" srcset="/img/loading.gif" alt="除法求值2" style="zoom: 33%;" /></p>
<p><strong>如何在「合并」操作中维护权值的变化</strong></p>
<p>「合并」操作基于这样一个 很重要的前提：我们将要合并的两棵树的高度最多为 2，换句话说两棵树都必需是「路径压缩」以后的效果，两棵树的叶子结点到根结点最多只需要经过一条有向边。</p>
<p>​    例如已知$ \cfrac{a}{b} = 3.0$ ，$\cfrac{d}{c} = 4.0$  ，又已知 $\cfrac{a}{d} = 6.0$  ，现在合并结点 a 和 d 所在的集合，其实就是把 a 的根结点 b 指向 d 的根结 c，那么如何计算 b 指向 c 的这条有向边的权重呢？</p>
<p>​    根据 a 经过 b 可以到达 c，a 经过 d 也可以到达 c，因此 两条路径上的有向边的权值的乘积是一定相等的。设 b 到 c 的权值为 x，那么 $3.0 \cdot x = 6.0 \cdot 4.0$ ，得 $x=8.0$。</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值3.png" srcset="/img/loading.gif" alt="除法求值3" style="zoom: 67%;" /></p>
<p><strong>一个容易忽略的细节</strong></p>
<p>​        接下来还有一个小的细节问题：在合并以后，产生了一棵高度为 3 的树，那么我们在执行查询的时候，例如下图展示的绿色结点和黄色结点，绿色结点并不直接指向根结点，在计算这两个变量的比值的时候，计算边的权值的比值得到的结果是不对的。</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值4.png" srcset="/img/loading.gif" alt="除法求值4" style="zoom:50%;" /></p>
<p>​        但其实不用担心这个问题，并查集的「查询」操作会执行「路径压缩」，所以真正在计算两个变量的权值的时候，绿色结点已经指向了根结点，和黄色结点的根结点相同。因此可以用它们指向根结点的有向边的权值的比值作为两个变量的比值。</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值5.png" srcset="/img/loading.gif" alt="除法求值5" style="zoom:50%;" /></p>
<p>​    我们通过这个细节向大家强调：一边查询一边修改结点指向是并查集的特色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="hljs-keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;<br>        <span class="hljs-keyword">int</span> equationsSize = equations.size();<br><br>        UnionFind unionFind = <span class="hljs-keyword">new</span> UnionFind(<span class="hljs-number">2</span> * equationsSize);<br>        <span class="hljs-comment">// 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码</span><br>        Map&lt;String, Integer&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">2</span> * equationsSize);<br>        <span class="hljs-keyword">int</span> id = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; equationsSize; i++) &#123;<br>            List&lt;String&gt; equation = equations.get(i);<br>            String var1 = equation.get(<span class="hljs-number">0</span>);<br>            String var2 = equation.get(<span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span> (!hashMap.containsKey(var1)) &#123;<br>                hashMap.put(var1, id);<br>                id++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!hashMap.containsKey(var2)) &#123;<br>                hashMap.put(var2, id);<br>                id++;<br>            &#125;<br>            unionFind.union(hashMap.get(var1), hashMap.get(var2), values[i]);<br>        &#125;<br><br>        <span class="hljs-comment">// 第 2 步：做查询</span><br>        <span class="hljs-keyword">int</span> queriesSize = queries.size();<br>        <span class="hljs-keyword">double</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[queriesSize];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; queriesSize; i++) &#123;<br>            String var1 = queries.get(i).get(<span class="hljs-number">0</span>);<br>            String var2 = queries.get(i).get(<span class="hljs-number">1</span>);<br><br>            Integer id1 = hashMap.get(var1);<br>            Integer id2 = hashMap.get(var2);<br><br>            <span class="hljs-keyword">if</span> (id1 == <span class="hljs-keyword">null</span> || id2 == <span class="hljs-keyword">null</span>) &#123;<br>                res[i] = -<span class="hljs-number">1.0d</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res[i] = unionFind.isConnected(id1, id2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>&#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 指向的父结点的权值</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span>[] weight;<br><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">this</span>.weight = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                parent[i] = i;<br>                weight[i] = <span class="hljs-number">1.0d</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">double</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            parent[rootX] = rootY;<br>          	<span class="hljs-comment">// 关系式的推导请见「参考代码」下方的示意图</span><br>            weight[rootX] = weight[y] * value / weight[x];<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 路径压缩</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> 根结点的 id</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (x != parent[x]) &#123;<br>                <span class="hljs-keyword">int</span> origin = parent[x];<br>                parent[x] = find(parent[x]);<br>                weight[x] *= weight[origin];<br>            &#125;<br>            <span class="hljs-keyword">return</span> parent[x];<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> rootX = find(x);<br>            <span class="hljs-keyword">int</span> rootY = find(y);<br>            <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>                <span class="hljs-keyword">return</span> weight[x] / weight[y];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1.0d</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>说明：代码 weight[rootX] = weight[y] * value / weight[x]; 的推导过程，主要需要明白各个变量的含义，由两条路径有向边的权值乘积相等得到相等关系，然后做等价变换即可。</p>
<p><img src="http://hexo-bolg-image.oss-cn-beijing.aliyuncs.com/img/除法求值6.png" srcset="/img/loading.gif" alt="除法求值6" style="zoom:50%;" /></p>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：$O((N + Q)\log A)$<ul>
<li>构建并查集 $O(N \log A)$ ，这里 N 为输入方程 equations 的长度，每一次执行合并操作的时间复杂度是 $O(\log A)$，这里 A 是 equations 里不同字符的个数；</li>
<li>查询并查集 $O(Q \log A)$，这里 Q 为查询数组 queries 的长度，每一次查询时执行「路径压缩」的时间复杂度是 $O(\log A)$。</li>
</ul>
</li>
<li>空间复杂度：O(A)：创建字符与 id 的对应关系 hashMap 长度为 A，并查集底层使用的两个数组 parent 和 weight 存储每个变量的连通分量信息，parent 和 weight 的长度均为 A。</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
                    
                      <a class="hover-with-bg" href="/tags/TOP100/">TOP100</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/03/11/2020%E6%80%BB%E7%BB%93/">
                        <span class="hidden-mobile">2020年终总结</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
